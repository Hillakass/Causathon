'use strict';

var rxjs = require('rxjs');
var message_errors = require('./errors/message.errors.js');
require('@polkadot/util');
require('./utils/generate.js');
require('./utils/prefixes.js');
require('./utils/separator.js');
var validate = require('./utils/validate.js');
require('@polkadot/api');
require('@polkadot/util-crypto');
var createPayload = require('./utils/create-payload.js');
var getExtrinsic = require('./utils/getExtrinsic.js');
var Transaction = require('./Transaction.js');

class GearMessage extends Transaction.GearTransaction {
    /**
     * ## Send Message
     * @param message
     * @param metaOrHexRegistry Metadata
     * @param typeIndexOrTypeName type index in registry or type name
     * @returns Submitted result
     */
    send({ destination, value, gasLimit, payload, ...rest }, metaOrHexRegistry, typeIndexOrTypeName) {
        validate.validateValue(value, this._api);
        validate.validateGasLimit(gasLimit, this._api);
        const _payload = createPayload.encodePayload(payload, metaOrHexRegistry, 'handle', typeIndexOrTypeName);
        try {
            const txArgs = [destination, _payload, gasLimit, value || 0];
            if (this._api.specVersion >= 1010) {
                txArgs.push('keepAlive' in rest ? rest.keepAlive : true);
            }
            else {
                txArgs.push('prepaid' in rest ? rest.prepaid : false);
            }
            this.extrinsic = getExtrinsic.getExtrinsic(this._api, 'gear', 'sendMessage', txArgs);
            return this.extrinsic;
        }
        catch (error) {
            throw new message_errors.SendMessageError(error.message);
        }
    }
    /**
     * Sends reply message
     * @param args Message parameters
     * @param metaOrHexRegistry Metadata
     * @param typeIndexOrTypeName type index in registry or type name
     * @returns Submitted result
     */
    async sendReply({ value, gasLimit, replyToId, payload, account, ...rest }, metaOrHexRegistry, typeIndexOrTypeName) {
        validate.validateValue(value, this._api);
        validate.validateGasLimit(gasLimit, this._api);
        if (account) {
            await validate.validateMailboxItem(account, replyToId, this._api);
        }
        const _payload = createPayload.encodePayload(payload, metaOrHexRegistry, 'reply', typeIndexOrTypeName);
        try {
            const txArgs = [replyToId, _payload, gasLimit, value || 0];
            if (this._api.specVersion >= 1010) {
                txArgs.push('keepAlive' in rest ? rest.keepAlive : true);
            }
            else {
                txArgs.push('prepaid' in rest ? rest.prepaid : false);
            }
            this.extrinsic = getExtrinsic.getExtrinsic(this._api, 'gear', 'sendReply', txArgs);
            return this.extrinsic;
        }
        catch (error) {
            throw new message_errors.SendReplyError();
        }
    }
    listenToReplies(programId, bufferSize = 5) {
        let unsub;
        const subject = new rxjs.ReplaySubject(bufferSize);
        this._api.gearEvents
            .subscribeToGearEvent('UserMessageSent', ({ data }) => {
            if (data.message.source.eq(programId)) {
                if (data.message.details.isSome) {
                    data.message.details.unwrap().to.toHex();
                    {
                        subject.next([data.message.details.unwrap().to.toHex(), data]);
                    }
                }
            }
        })
            .then((result) => {
            unsub = result;
        });
        return (messageId) => {
            return new Promise((resolve) => {
                subject.subscribe({
                    next: ([id, data]) => {
                        if (id === messageId) {
                            subject.complete();
                            unsub();
                            resolve(data);
                        }
                    },
                });
            });
        };
    }
}

exports.GearMessage = GearMessage;
