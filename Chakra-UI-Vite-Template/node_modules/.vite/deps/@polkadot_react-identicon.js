import {
  import_index
} from "./chunk-2VH2HQQI.js";
import {
  blake2b,
  ed25519KeypairFromSeed,
  ed25519Verify,
  esm_default,
  hmacSha256,
  hmacSha512,
  isReady,
  keccak256,
  keccak512,
  secp256k1Compress,
  secp256k1Expand,
  secp256k1FromSeed,
  secp256k1Recover,
  sha256,
  sha512,
  sr25519DeriveKeypairHard,
  sr25519DeriveKeypairSoft,
  sr25519Verify,
  twox,
  waitReady
} from "./chunk-GXCWJNGX.js";
import {
  memoize,
  require_copy_to_clipboard,
  require_hoist_non_react_statics_cjs
} from "./chunk-HTAGNLOO.js";
import {
  require_react_is
} from "./chunk-5KYEZKIK.js";
import {
  require_jsx_runtime
} from "./chunk-HYETAKZG.js";
import {
  require_react
} from "./chunk-J5ONLETY.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM,
  global,
  import_process,
  init_shim,
  require_buffer
} from "./chunk-LTWQHXZQ.js";

// node_modules/@polkadot/react-identicon/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/@polkadot/react-identicon/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    init_shim();
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number2, base, endian) {
        if (BN2.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports3.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e3) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init2(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number2, base, endian) {
        assert(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j4, w3;
        var off = 0;
        if (endian === "be") {
          for (i3 = number2.length - 1, j4 = 0; i3 >= 0; i3 -= 3) {
            w3 = number2[i3] | number2[i3 - 1] << 8 | number2[i3 - 2] << 16;
            this.words[j4] |= w3 << off & 67108863;
            this.words[j4 + 1] = w3 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j4++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j4 = 0; i3 < number2.length; i3 += 3) {
            w3 = number2[i3] | number2[i3 + 1] << 8 | number2[i3 + 2] << 16;
            this.words[j4] |= w3 << off & 67108863;
            this.words[j4 + 1] = w3 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j4++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c3 = string.charCodeAt(index);
        if (c3 >= 48 && c3 <= 57) {
          return c3 - 48;
        } else if (c3 >= 65 && c3 <= 70) {
          return c3 - 55;
        } else if (c3 >= 97 && c3 <= 102) {
          return c3 - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r3 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r3 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r3;
      }
      BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var off = 0;
        var j4 = 0;
        var w3;
        if (endian === "be") {
          for (i3 = number2.length - 1; i3 >= start; i3 -= 2) {
            w3 = parseHexByte(number2, start, i3) << off;
            this.words[j4] |= w3 & 67108863;
            if (off >= 18) {
              off -= 18;
              j4 += 1;
              this.words[j4] |= w3 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i3 = parseLength % 2 === 0 ? start + 1 : start; i3 < number2.length; i3 += 2) {
            w3 = parseHexByte(number2, start, i3) << off;
            this.words[j4] |= w3 & 67108863;
            if (off >= 18) {
              off -= 18;
              j4 += 1;
              this.words[j4] |= w3 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str2, start, end, mul) {
        var r3 = 0;
        var b3 = 0;
        var len = Math.min(str2.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str2.charCodeAt(i3) - 48;
          r3 *= mul;
          if (c3 >= 49) {
            b3 = c3 - 49 + 10;
          } else if (c3 >= 17) {
            b3 = c3 - 17 + 10;
          } else {
            b3 = c3;
          }
          assert(c3 >= 0 && b3 < mul, "Invalid character");
          r3 += b3;
        }
        return r3;
      }
      BN2.prototype._parseBase = function _parseBase(number2, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i3 = start; i3 < end; i3 += limbLen) {
          word = parseBase(number2, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number2, i3, number2.length, base);
          for (i3 = 0; i3 < mod2; i3++) {
            pow3 *= base;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone() {
        var r3 = new BN2(null);
        this.copy(r3);
        return r3;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e3) {
          BN2.prototype.inspect = inspect;
        }
      } else {
        BN2.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding2) {
        base = base || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w3 = this.words[i3];
            var word = ((w3 << off | carry) & 16777215).toString(16);
            carry = w3 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r3 = c3.modrn(groupBase).toString(base);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN2.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i3 = 0, shift = 0; i3 < this.length; i3++) {
          var word = this.words[i3] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i3 = 0, shift = 0; i3 < this.length; i3++) {
          var word = this.words[i3] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w3) {
          return 32 - Math.clz32(w3);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w3) {
          var t3 = w3;
          var r3 = 0;
          if (t3 >= 4096) {
            r3 += 13;
            t3 >>>= 13;
          }
          if (t3 >= 64) {
            r3 += 7;
            t3 >>>= 7;
          }
          if (t3 >= 8) {
            r3 += 4;
            t3 >>>= 4;
          }
          if (t3 >= 2) {
            r3 += 2;
            t3 >>>= 2;
          }
          return r3 + t3;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w3) {
        if (w3 === 0)
          return 26;
        var t3 = w3;
        var r3 = 0;
        if ((t3 & 8191) === 0) {
          r3 += 13;
          t3 >>>= 13;
        }
        if ((t3 & 127) === 0) {
          r3 += 7;
          t3 >>>= 7;
        }
        if ((t3 & 15) === 0) {
          r3 += 4;
          t3 >>>= 4;
        }
        if ((t3 & 3) === 0) {
          r3 += 2;
          t3 >>>= 2;
        }
        if ((t3 & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w3 = this.words[this.length - 1];
        var hi = this._countBits(w3);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w3 = new Array(num.bitLength());
        for (var bit = 0; bit < w3.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w3[bit] = num.words[off] >>> wbit & 1;
        }
        return w3;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r3 = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b3 = this._zeroBits(this.words[i3]);
          r3 += b3;
          if (b3 !== 26)
            break;
        }
        return r3;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b3;
        if (this.length > num.length) {
          b3 = num;
        } else {
          b3 = this;
        }
        for (var i3 = 0; i3 < b3.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b3.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a3;
        var b3;
        if (this.length > num.length) {
          a3 = this;
          b3 = num;
        } else {
          a3 = num;
          b3 = this;
        }
        for (var i3 = 0; i3 < b3.length; i3++) {
          this.words[i3] = a3.words[i3] ^ b3.words[i3];
        }
        if (this !== a3) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = a3.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a3, b3;
        if (this.length > num.length) {
          a3 = this;
          b3 = num;
        } else {
          a3 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b3.length; i3++) {
          r3 = (a3.words[i3] | 0) + (b3.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r3 = (a3.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a3.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        return this;
      };
      BN2.prototype.add = function add2(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a3, b3;
        if (cmp > 0) {
          a3 = this;
          b3 = num;
        } else {
          a3 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b3.length; i3++) {
          r3 = (a3.words[i3] | 0) - (b3.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r3 = (a3.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        if (carry === 0 && i3 < a3.length && a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a3 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a3 = self2.words[0] | 0;
        var b3 = num.words[0] | 0;
        var r3 = a3 * b3;
        var lo = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j4 = Math.max(0, k2 - self2.length + 1); j4 <= maxJ; j4++) {
            var i3 = k2 - j4 | 0;
            a3 = self2.words[i3] | 0;
            b3 = num.words[j4] | 0;
            r3 = a3 * b3 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a3 = self2.words;
        var b3 = num.words;
        var o3 = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a3[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a3[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a3[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a3[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a4 = a3[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a3[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a3[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a3[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a3[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a3[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b3[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b3[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b3[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b3[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b4 = b3[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b3[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b3[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b3[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b3[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b3[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o3[0] = w0;
        o3[1] = w1;
        o3[2] = w22;
        o3[3] = w3;
        o3[4] = w4;
        o3[5] = w5;
        o3[6] = w6;
        o3[7] = w7;
        o3[8] = w8;
        o3[9] = w9;
        o3[10] = w10;
        o3[11] = w11;
        o3[12] = w12;
        o3[13] = w13;
        o3[14] = w14;
        o3[15] = w15;
        o3[16] = w16;
        o3[17] = w17;
        o3[18] = w18;
        if (c3 !== 0) {
          o3[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j4 = Math.max(0, k2 - self2.length + 1); j4 <= maxJ; j4++) {
            var i3 = k2 - j4;
            var a3 = self2.words[i3] | 0;
            var b3 = num.words[j4] | 0;
            var r3 = a3 * b3;
            var lo = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x3, y3) {
        this.x = x3;
        this.y = y3;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t3 = new Array(N4);
        var l4 = BN2.prototype._countBits(N4) - 1;
        for (var i3 = 0; i3 < N4; i3++) {
          t3[i3] = this.revBin(i3, l4, N4);
        }
        return t3;
      };
      FFTM.prototype.revBin = function revBin(x3, l4, N4) {
        if (x3 === 0 || x3 === N4 - 1)
          return x3;
        var rb = 0;
        for (var i3 = 0; i3 < l4; i3++) {
          rb |= (x3 & 1) << l4 - i3 - 1;
          x3 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i3 = 0; i3 < N4; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s3 = 1; s3 < N4; s3 <<= 1) {
          var l4 = s3 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l4);
          var itwdf = Math.sin(2 * Math.PI / l4);
          for (var p2 = 0; p2 < N4; p2 += l4) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j4 = 0; j4 < s3; j4++) {
              var re2 = rtws[p2 + j4];
              var ie2 = itws[p2 + j4];
              var ro = rtws[p2 + j4 + s3];
              var io = itws[p2 + j4 + s3];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p2 + j4] = re2 + ro;
              itws[p2 + j4] = ie2 + io;
              rtws[p2 + j4 + s3] = re2 - ro;
              itws[p2 + j4 + s3] = ie2 - io;
              if (j4 !== l4) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m3) {
        var N4 = Math.max(m3, n3) | 1;
        var odd = N4 & 1;
        var i3 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i3 = 0; i3 < N4 / 2; i3++) {
          var t3 = rws[i3];
          rws[i3] = rws[N4 - i3 - 1];
          rws[N4 - i3 - 1] = t3;
          t3 = iws[i3];
          iws[i3] = -iws[N4 - i3 - 1];
          iws[N4 - i3 - 1] = -t3;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i3 = 0; i3 < N4 / 2; i3++) {
          var w3 = Math.round(ws[2 * i3 + 1] / N4) * 8192 + Math.round(ws[2 * i3] / N4) + carry;
          ws[i3] = w3 & 67108863;
          if (w3 < 67108864) {
            carry = 0;
          } else {
            carry = w3 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N4; ++i3) {
          rws[i3] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i3 = 0; i3 < N4; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x3, y3, out) {
        var N4 = 2 * this.guessLen13b(x3.length, y3.length);
        var rbt = this.makeRBT(N4);
        var _2 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x3.words, x3.length, rws, N4);
        this.convert13b(y3.words, y3.length, nrws, N4);
        this.transform(rws, _2, rwst, iwst, N4, rbt);
        this.transform(nrws, _2, nrwst, niwst, N4, rbt);
        for (var i3 = 0; i3 < N4; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _2, N4, rbt);
        this.conjugate(rmws, _2, N4);
        this.normalize13b(rmws, N4);
        out.negative = x3.negative ^ y3.negative;
        out.length = x3.length + y3.length;
        return out._strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w3 = (this.words[i3] | 0) * num;
          var lo = (w3 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w3 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i3] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow3(num) {
        var w3 = toBitArray(num);
        if (w3.length === 0)
          return new BN2(1);
        var res = this;
        for (var i3 = 0; i3 < w3.length; i3++, res = res.sqr()) {
          if (w3[i3] !== 0)
            break;
        }
        if (++i3 < w3.length) {
          for (var q2 = res.sqr(); i3 < w3.length; i3++, q2 = q2.sqr()) {
            if (w3[i3] === 0)
              continue;
            res = res.mul(q2);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s3 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i3;
        if (r3 !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c3 = (this.words[i3] | 0) - newCarry << r3;
            this.words[i3] = c3 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s3 !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s3] = this.words[i3];
          }
          for (i3 = 0; i3 < s3; i3++) {
            this.words[i3] = 0;
          }
          this.length += s3;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h2;
        if (hint) {
          h2 = (hint - hint % 26) / 26;
        } else {
          h2 = 0;
        }
        var r3 = bits % 26;
        var s3 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h2 -= s3;
        h2 = Math.max(0, h2);
        if (maskedWords) {
          for (var i3 = 0; i3 < s3; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s3;
        }
        if (s3 === 0) {
        } else if (this.length > s3) {
          this.length -= s3;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s3];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h2); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s3 = (bit - r3) / 26;
        var q2 = 1 << r3;
        if (this.length <= s3)
          return false;
        var w3 = this.words[s3];
        return !!(w3 & q2);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s3 = (bits - r3) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s3) {
          return this;
        }
        if (r3 !== 0) {
          s3++;
        }
        this.length = Math.min(s3, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i3;
        this._expand(len);
        var w3;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w3 = (this.words[i3 + shift] | 0) + carry;
          var right = (num.words[i3] | 0) * mul;
          w3 -= right & 67108863;
          carry = (w3 >> 26) - (right / 67108864 | 0);
          this.words[i3 + shift] = w3 & 67108863;
        }
        for (; i3 < this.length - shift; i3++) {
          w3 = (this.words[i3 + shift] | 0) + carry;
          carry = w3 >> 26;
          this.words[i3 + shift] = w3 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w3 = -(this.words[i3] | 0) + carry;
          carry = w3 >> 26;
          this.words[i3] = w3 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a3 = this.clone();
        var b3 = num;
        var bhi = b3.words[b3.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b3 = b3.ushln(shift);
          a3.iushln(shift);
          bhi = b3.words[b3.length - 1] | 0;
        }
        var m3 = a3.length - b3.length;
        var q2;
        if (mode !== "mod") {
          q2 = new BN2(null);
          q2.length = m3 + 1;
          q2.words = new Array(q2.length);
          for (var i3 = 0; i3 < q2.length; i3++) {
            q2.words[i3] = 0;
          }
        }
        var diff = a3.clone()._ishlnsubmul(b3, 1, m3);
        if (diff.negative === 0) {
          a3 = diff;
          if (q2) {
            q2.words[m3] = 1;
          }
        }
        for (var j4 = m3 - 1; j4 >= 0; j4--) {
          var qj = (a3.words[b3.length + j4] | 0) * 67108864 + (a3.words[b3.length + j4 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a3._ishlnsubmul(b3, qj, j4);
          while (a3.negative !== 0) {
            qj--;
            a3.negative = 0;
            a3._ishlnsubmul(b3, 1, j4);
            if (!a3.isZero()) {
              a3.negative ^= 1;
            }
          }
          if (q2) {
            q2.words[j4] = qj;
          }
        }
        if (q2) {
          q2._strip();
        }
        a3._strip();
        if (mode !== "div" && shift !== 0) {
          a3.iushrn(shift);
        }
        return {
          div: q2 || null,
          mod: a3
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p2 * acc + (this.words[i3] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w3 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w3 / num | 0;
          carry = w3 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p2) {
        assert(p2.negative === 0);
        assert(!p2.isZero());
        var x3 = this;
        var y3 = p2.clone();
        if (x3.negative !== 0) {
          x3 = x3.umod(p2);
        } else {
          x3 = x3.clone();
        }
        var A = new BN2(1);
        var B2 = new BN2(0);
        var C3 = new BN2(0);
        var D2 = new BN2(1);
        var g3 = 0;
        while (x3.isEven() && y3.isEven()) {
          x3.iushrn(1);
          y3.iushrn(1);
          ++g3;
        }
        var yp = y3.clone();
        var xp = x3.clone();
        while (!x3.isZero()) {
          for (var i3 = 0, im = 1; (x3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            x3.iushrn(i3);
            while (i3-- > 0) {
              if (A.isOdd() || B2.isOdd()) {
                A.iadd(yp);
                B2.isub(xp);
              }
              A.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (y3.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            y3.iushrn(j4);
            while (j4-- > 0) {
              if (C3.isOdd() || D2.isOdd()) {
                C3.iadd(yp);
                D2.isub(xp);
              }
              C3.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x3.cmp(y3) >= 0) {
            x3.isub(y3);
            A.isub(C3);
            B2.isub(D2);
          } else {
            y3.isub(x3);
            C3.isub(A);
            D2.isub(B2);
          }
        }
        return {
          a: C3,
          b: D2,
          gcd: y3.iushln(g3)
        };
      };
      BN2.prototype._invmp = function _invmp(p2) {
        assert(p2.negative === 0);
        assert(!p2.isZero());
        var a3 = this;
        var b3 = p2.clone();
        if (a3.negative !== 0) {
          a3 = a3.umod(p2);
        } else {
          a3 = a3.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b3.clone();
        while (a3.cmpn(1) > 0 && b3.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            a3.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (b3.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            b3.iushrn(j4);
            while (j4-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a3.cmp(b3) >= 0) {
            a3.isub(b3);
            x1.isub(x22);
          } else {
            b3.isub(a3);
            x22.isub(x1);
          }
        }
        var res;
        if (a3.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd2(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a3 = this.clone();
        var b3 = num.clone();
        a3.negative = 0;
        b3.negative = 0;
        for (var shift = 0; a3.isEven() && b3.isEven(); shift++) {
          a3.iushrn(1);
          b3.iushrn(1);
        }
        do {
          while (a3.isEven()) {
            a3.iushrn(1);
          }
          while (b3.isEven()) {
            b3.iushrn(1);
          }
          var r3 = a3.cmp(b3);
          if (r3 < 0) {
            var t3 = a3;
            a3 = b3;
            b3 = t3;
          } else if (r3 === 0 || b3.cmpn(1) === 0) {
            break;
          }
          a3.isub(b3);
        } while (true);
        return b3.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r3 = bit % 26;
        var s3 = (bit - r3) / 26;
        var q2 = 1 << r3;
        if (this.length <= s3) {
          this._expand(s3 + 1);
          this.words[s3] |= q2;
          return this;
        }
        var carry = q2;
        for (var i3 = s3; carry !== 0 && i3 < this.length; i3++) {
          var w3 = this.words[i3] | 0;
          w3 += carry;
          carry = w3 >>> 26;
          w3 &= 67108863;
          this.words[i3] = w3;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w3 = this.words[0] | 0;
          res = w3 === num ? 0 : w3 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a3 = this.words[i3] | 0;
          var b3 = num.words[i3] | 0;
          if (a3 === b3)
            continue;
          if (a3 < b3) {
            res = -1;
          } else if (a3 > b3) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p2) {
        this.name = name;
        this.p = new BN2(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          if (r3.strip !== void 0) {
            r3.strip();
          } else {
            r3._strip();
          }
        }
        return r3;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output2) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output2.words[i3] = input.words[i3];
        }
        output2.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output2.words[output2.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next = input.words[i3] | 0;
          input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w3 = num.words[i3] | 0;
          lo += w3 * 977;
          num.words[i3] = lo & 67108863;
          lo = w3 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi = (num.words[i3] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i3] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m3) {
        if (typeof m3 === "string") {
          var prime = BN2._prime(m3);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m3.gtn(1), "modulus must be greater than 1");
          this.m = m3;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a3) {
        assert(a3.negative === 0, "red works only with positives");
        assert(a3.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a3, b3) {
        assert((a3.negative | b3.negative) === 0, "red works only with positives");
        assert(
          a3.red && a3.red === b3.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a3) {
        if (this.prime)
          return this.prime.ireduce(a3)._forceRed(this);
        move(a3, a3.umod(this.m)._forceRed(this));
        return a3;
      };
      Red.prototype.neg = function neg(a3) {
        if (a3.isZero()) {
          return a3.clone();
        }
        return this.m.sub(a3)._forceRed(this);
      };
      Red.prototype.add = function add2(a3, b3) {
        this._verify2(a3, b3);
        var res = a3.add(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a3, b3) {
        this._verify2(a3, b3);
        var res = a3.iadd(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a3, b3) {
        this._verify2(a3, b3);
        var res = a3.sub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a3, b3) {
        this._verify2(a3, b3);
        var res = a3.isub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a3, num) {
        this._verify1(a3);
        return this.imod(a3.ushln(num));
      };
      Red.prototype.imul = function imul(a3, b3) {
        this._verify2(a3, b3);
        return this.imod(a3.imul(b3));
      };
      Red.prototype.mul = function mul(a3, b3) {
        this._verify2(a3, b3);
        return this.imod(a3.mul(b3));
      };
      Red.prototype.isqr = function isqr(a3) {
        return this.imul(a3, a3.clone());
      };
      Red.prototype.sqr = function sqr(a3) {
        return this.mul(a3, a3);
      };
      Red.prototype.sqrt = function sqrt(a3) {
        if (a3.isZero())
          return a3.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a3, pow3);
        }
        var q2 = this.m.subn(1);
        var s3 = 0;
        while (!q2.isZero() && q2.andln(1) === 0) {
          s3++;
          q2.iushrn(1);
        }
        assert(!q2.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN2(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c3 = this.pow(z2, q2);
        var r3 = this.pow(a3, q2.addn(1).iushrn(1));
        var t3 = this.pow(a3, q2);
        var m3 = s3;
        while (t3.cmp(one) !== 0) {
          var tmp = t3;
          for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert(i3 < m3);
          var b3 = this.pow(c3, new BN2(1).iushln(m3 - i3 - 1));
          r3 = r3.redMul(b3);
          c3 = b3.redSqr();
          t3 = t3.redMul(c3);
          m3 = i3;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a3) {
        var inv = a3._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a3, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a3.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a3;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a3);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j4 = start - 1; j4 >= 0; j4--) {
            var bit = word >> j4 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j4 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m3) {
        Red.call(this, m3);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a3, b3) {
        if (a3.isZero() || b3.isZero()) {
          a3.words[0] = 0;
          a3.length = 1;
          return a3;
        }
        var t3 = a3.imul(b3);
        var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t3.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a3, b3) {
        if (a3.isZero() || b3.isZero())
          return new BN2(0)._forceRed(this);
        var t3 = a3.mul(b3);
        var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t3.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a3) {
        var res = this.imod(a3._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/ethereum-blockies-base64/dist/main.js
var require_main = __commonJS({
  "node_modules/ethereum-blockies-base64/dist/main.js"(exports2, module2) {
    init_shim();
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports2 === "object")
        exports2["ethereum-blockies-base64"] = factory();
      else
        root["ethereum-blockies-base64"] = factory();
    })(exports2, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
              return installedModules[moduleId].exports;
            var module3 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: false
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.loaded = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.p = "";
          return __webpack_require__(0);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __webpack_require__) {
            const pnglib = __webpack_require__(1);
            const hsl2rgb = __webpack_require__(2);
            const randseed = new Array(4);
            function seedrand(seed) {
              for (let i3 = 0; i3 < randseed.length; i3++) {
                randseed[i3] = 0;
              }
              for (let i3 = 0; i3 < seed.length; i3++) {
                randseed[i3 % 4] = (randseed[i3 % 4] << 5) - randseed[i3 % 4] + seed.charCodeAt(i3);
              }
            }
            function rand() {
              const t3 = randseed[0] ^ randseed[0] << 11;
              randseed[0] = randseed[1];
              randseed[1] = randseed[2];
              randseed[2] = randseed[3];
              randseed[3] = randseed[3] ^ randseed[3] >> 19 ^ t3 ^ t3 >> 8;
              return (randseed[3] >>> 0) / (1 << 31 >>> 0);
            }
            function createColor() {
              const h2 = Math.floor(rand() * 360);
              const s3 = rand() * 60 + 40;
              const l4 = (rand() + rand() + rand() + rand()) * 25;
              return [h2 / 360, s3 / 100, l4 / 100];
            }
            function createImageData(size) {
              const width = size;
              const height = size;
              const dataWidth = Math.ceil(width / 2);
              const mirrorWidth = width - dataWidth;
              const data = [];
              for (let y3 = 0; y3 < height; y3++) {
                let row = [];
                for (let x3 = 0; x3 < dataWidth; x3++) {
                  row[x3] = Math.floor(rand() * 2.3);
                }
                const r3 = row.slice(0, mirrorWidth).reverse();
                row = row.concat(r3);
                for (let i3 = 0; i3 < row.length; i3++) {
                  data.push(row[i3]);
                }
              }
              return data;
            }
            function fillRect(png, x3, y3, w3, h2, color) {
              for (let i3 = 0; i3 < w3; i3++) {
                for (let j4 = 0; j4 < h2; j4++) {
                  png.buffer[png.index(x3 + i3, y3 + j4)] = color;
                }
              }
            }
            function buildOpts(opts) {
              if (!opts.seed) {
                throw new Error("No seed provided");
              }
              seedrand(opts.seed);
              return Object.assign({
                size: 8,
                scale: 16,
                color: createColor(),
                bgcolor: createColor(),
                spotcolor: createColor()
              }, opts);
            }
            function makeBlockie2(address) {
              const opts = buildOpts({ seed: address.toLowerCase() });
              const imageData = createImageData(opts.size);
              const width = Math.sqrt(imageData.length);
              const p2 = new pnglib(opts.size * opts.scale, opts.size * opts.scale, 3);
              const bgcolor = p2.color(...hsl2rgb(...opts.bgcolor));
              const color = p2.color(...hsl2rgb(...opts.color));
              const spotcolor = p2.color(...hsl2rgb(...opts.spotcolor));
              for (let i3 = 0; i3 < imageData.length; i3++) {
                const row = Math.floor(i3 / width);
                const col = i3 % width;
                if (imageData[i3]) {
                  const pngColor = imageData[i3] == 1 ? color : spotcolor;
                  fillRect(p2, col * opts.scale, row * opts.scale, opts.scale, opts.scale, pngColor);
                }
              }
              return `data:image/png;base64,${p2.getBase64()}`;
            }
            module3.exports = makeBlockie2;
          },
          /* 1 */
          /***/
          function(module3, exports3) {
            module3.exports = function(width, height, depth) {
              function write(buffer, offs) {
                for (var i4 = 2; i4 < arguments.length; i4++) {
                  for (var j5 = 0; j5 < arguments[i4].length; j5++) {
                    buffer[offs++] = arguments[i4].charAt(j5);
                  }
                }
              }
              function byte2(w3) {
                return String.fromCharCode(w3 >> 8 & 255, w3 & 255);
              }
              function byte4(w3) {
                return String.fromCharCode(w3 >> 24 & 255, w3 >> 16 & 255, w3 >> 8 & 255, w3 & 255);
              }
              function byte2lsb(w3) {
                return String.fromCharCode(w3 & 255, w3 >> 8 & 255);
              }
              this.width = width;
              this.height = height;
              this.depth = depth;
              this.pix_size = height * (width + 1);
              this.data_size = 2 + this.pix_size + 5 * Math.floor((65534 + this.pix_size) / 65535) + 4;
              this.ihdr_offs = 0;
              this.ihdr_size = 4 + 4 + 13 + 4;
              this.plte_offs = this.ihdr_offs + this.ihdr_size;
              this.plte_size = 4 + 4 + 3 * depth + 4;
              this.trns_offs = this.plte_offs + this.plte_size;
              this.trns_size = 4 + 4 + depth + 4;
              this.idat_offs = this.trns_offs + this.trns_size;
              this.idat_size = 4 + 4 + this.data_size + 4;
              this.iend_offs = this.idat_offs + this.idat_size;
              this.iend_size = 4 + 4 + 4;
              this.buffer_size = this.iend_offs + this.iend_size;
              this.buffer = new Array();
              this.palette = new Object();
              this.pindex = 0;
              var _crc32 = new Array();
              for (var i3 = 0; i3 < this.buffer_size; i3++) {
                this.buffer[i3] = "\0";
              }
              write(this.buffer, this.ihdr_offs, byte4(this.ihdr_size - 12), "IHDR", byte4(width), byte4(height), "\b");
              write(this.buffer, this.plte_offs, byte4(this.plte_size - 12), "PLTE");
              write(this.buffer, this.trns_offs, byte4(this.trns_size - 12), "tRNS");
              write(this.buffer, this.idat_offs, byte4(this.idat_size - 12), "IDAT");
              write(this.buffer, this.iend_offs, byte4(this.iend_size - 12), "IEND");
              var header = 8 + (7 << 4) << 8 | 3 << 6;
              header += 31 - header % 31;
              write(this.buffer, this.idat_offs + 8, byte2(header));
              for (var i3 = 0; (i3 << 16) - 1 < this.pix_size; i3++) {
                var size, bits;
                if (i3 + 65535 < this.pix_size) {
                  size = 65535;
                  bits = "\0";
                } else {
                  size = this.pix_size - (i3 << 16) - i3;
                  bits = "";
                }
                write(this.buffer, this.idat_offs + 8 + 2 + (i3 << 16) + (i3 << 2), bits, byte2lsb(size), byte2lsb(~size));
              }
              for (var i3 = 0; i3 < 256; i3++) {
                var c3 = i3;
                for (var j4 = 0; j4 < 8; j4++) {
                  if (c3 & 1) {
                    c3 = -306674912 ^ c3 >> 1 & 2147483647;
                  } else {
                    c3 = c3 >> 1 & 2147483647;
                  }
                }
                _crc32[i3] = c3;
              }
              this.index = function(x3, y3) {
                var i4 = y3 * (this.width + 1) + x3 + 1;
                var j5 = this.idat_offs + 8 + 2 + 5 * Math.floor(i4 / 65535 + 1) + i4;
                return j5;
              };
              this.color = function(red, green, blue, alpha) {
                alpha = alpha >= 0 ? alpha : 255;
                var color = ((alpha << 8 | red) << 8 | green) << 8 | blue;
                if (typeof this.palette[color] == "undefined") {
                  if (this.pindex == this.depth)
                    return "\0";
                  var ndx = this.plte_offs + 8 + 3 * this.pindex;
                  this.buffer[ndx + 0] = String.fromCharCode(red);
                  this.buffer[ndx + 1] = String.fromCharCode(green);
                  this.buffer[ndx + 2] = String.fromCharCode(blue);
                  this.buffer[this.trns_offs + 8 + this.pindex] = String.fromCharCode(alpha);
                  this.palette[color] = String.fromCharCode(this.pindex++);
                }
                return this.palette[color];
              };
              this.getBase64 = function() {
                var s3 = this.getDump();
                var ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                var c1, c22, c32, e1, e22, e3, e4;
                var l4 = s3.length;
                var i4 = 0;
                var r3 = "";
                do {
                  c1 = s3.charCodeAt(i4);
                  e1 = c1 >> 2;
                  c22 = s3.charCodeAt(i4 + 1);
                  e22 = (c1 & 3) << 4 | c22 >> 4;
                  c32 = s3.charCodeAt(i4 + 2);
                  if (l4 < i4 + 2) {
                    e3 = 64;
                  } else {
                    e3 = (c22 & 15) << 2 | c32 >> 6;
                  }
                  if (l4 < i4 + 3) {
                    e4 = 64;
                  } else {
                    e4 = c32 & 63;
                  }
                  r3 += ch.charAt(e1) + ch.charAt(e22) + ch.charAt(e3) + ch.charAt(e4);
                } while ((i4 += 3) < l4);
                return r3;
              };
              this.getDump = function() {
                var BASE = 65521;
                var NMAX = 5552;
                var s1 = 1;
                var s22 = 0;
                var n3 = NMAX;
                for (var y3 = 0; y3 < this.height; y3++) {
                  for (var x3 = -1; x3 < this.width; x3++) {
                    s1 += this.buffer[this.index(x3, y3)].charCodeAt(0);
                    s22 += s1;
                    if ((n3 -= 1) == 0) {
                      s1 %= BASE;
                      s22 %= BASE;
                      n3 = NMAX;
                    }
                  }
                }
                s1 %= BASE;
                s22 %= BASE;
                write(this.buffer, this.idat_offs + this.idat_size - 8, byte4(s22 << 16 | s1));
                function crc32(png, offs, size2) {
                  var crc = -1;
                  for (var i4 = 4; i4 < size2 - 4; i4 += 1) {
                    crc = _crc32[(crc ^ png[offs + i4].charCodeAt(0)) & 255] ^ crc >> 8 & 16777215;
                  }
                  write(png, offs + size2 - 4, byte4(crc ^ -1));
                }
                crc32(this.buffer, this.ihdr_offs, this.ihdr_size);
                crc32(this.buffer, this.plte_offs, this.plte_size);
                crc32(this.buffer, this.trns_offs, this.trns_size);
                crc32(this.buffer, this.idat_offs, this.idat_size);
                crc32(this.buffer, this.iend_offs, this.iend_size);
                return "PNG\r\n\n" + this.buffer.join("");
              };
            };
          },
          /* 2 */
          /***/
          function(module3, exports3) {
            function hue2rgb(p2, q2, t3) {
              if (t3 < 0)
                t3 += 1;
              if (t3 > 1)
                t3 -= 1;
              if (t3 < 1 / 6)
                return p2 + (q2 - p2) * 6 * t3;
              if (t3 < 1 / 2)
                return q2;
              if (t3 < 2 / 3)
                return p2 + (q2 - p2) * (2 / 3 - t3) * 6;
              return p2;
            }
            function hsl2rgb(h2, s3, l4) {
              let r3, g3, b3;
              if (s3 == 0) {
                r3 = g3 = b3 = l4;
              } else {
                const q2 = l4 < 0.5 ? l4 * (1 + s3) : l4 + s3 - l4 * s3;
                const p2 = 2 * l4 - q2;
                r3 = hue2rgb(p2, q2, h2 + 1 / 3);
                g3 = hue2rgb(p2, q2, h2);
                b3 = hue2rgb(p2, q2, h2 - 1 / 3);
              }
              return [Math.round(r3 * 255), Math.round(g3 * 255), Math.round(b3 * 255), 255];
            }
            module3.exports = hsl2rgb;
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports2, module2) {
    init_shim();
    module2.exports = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/react-copy-to-clipboard/lib/Component.js
var require_Component = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/Component.js"(exports2) {
    "use strict";
    init_shim();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CopyToClipboard = void 0;
    var _react = _interopRequireDefault(require_react());
    var _copyToClipboard = _interopRequireDefault(require_copy_to_clipboard());
    var _excluded = ["text", "onCopy", "options", "children"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = null != arguments[i3] ? arguments[i3] : {};
        i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i3;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
          key = sourceSymbolKeys[i3];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i3;
      for (i3 = 0; i3 < sourceKeys.length; i3++) {
        key = sourceKeys[i3];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o3, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o4, p3) {
        o4.__proto__ = p3;
        return o4;
      };
      return _setPrototypeOf(o3, p2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e3) {
        return false;
      }
    }
    function _getPrototypeOf(o3) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
        return o4.__proto__ || Object.getPrototypeOf(o4);
      };
      return _getPrototypeOf(o3);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var CopyToClipboard2 = function(_React$PureComponent) {
      _inherits(CopyToClipboard3, _React$PureComponent);
      var _super = _createSuper(CopyToClipboard3);
      function CopyToClipboard3() {
        var _this;
        _classCallCheck(this, CopyToClipboard3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
          var _this$props = _this.props, text2 = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
          var elem = _react["default"].Children.only(children);
          var result = (0, _copyToClipboard["default"])(text2, options);
          if (onCopy) {
            onCopy(text2, result);
          }
          if (elem && elem.props && typeof elem.props.onClick === "function") {
            elem.props.onClick(event);
          }
        });
        return _this;
      }
      _createClass(CopyToClipboard3, [{
        key: "render",
        value: function render() {
          var _this$props2 = this.props, _text = _this$props2.text, _onCopy = _this$props2.onCopy, _options = _this$props2.options, children = _this$props2.children, props = _objectWithoutProperties(_this$props2, _excluded);
          var elem = _react["default"].Children.only(children);
          return _react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
            onClick: this.onClick
          }));
        }
      }]);
      return CopyToClipboard3;
    }(_react["default"].PureComponent);
    exports2.CopyToClipboard = CopyToClipboard2;
    _defineProperty(CopyToClipboard2, "defaultProps", {
      onCopy: void 0,
      options: void 0
    });
  }
});

// node_modules/react-copy-to-clipboard/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var _require = require_Component();
    var CopyToClipboard2 = _require.CopyToClipboard;
    CopyToClipboard2.CopyToClipboard = CopyToClipboard2;
    module2.exports = CopyToClipboard2;
  }
});

// node_modules/store/src/util.js
var require_util = __commonJS({
  "node_modules/store/src/util.js"(exports2, module2) {
    init_shim();
    var assign = make_assign();
    var create = make_create();
    var trim = make_trim();
    var Global = typeof window !== "undefined" ? window : global;
    module2.exports = {
      assign,
      create,
      trim,
      bind,
      slice,
      each,
      map,
      pluck,
      isList,
      isFunction: isFunction2,
      isObject: isObject2,
      Global
    };
    function make_assign() {
      if (Object.assign) {
        return Object.assign;
      } else {
        return function shimAssign(obj, props1, props2, etc) {
          for (var i3 = 1; i3 < arguments.length; i3++) {
            each(Object(arguments[i3]), function(val, key) {
              obj[key] = val;
            });
          }
          return obj;
        };
      }
    }
    function make_create() {
      if (Object.create) {
        return function create2(obj, assignProps1, assignProps2, etc) {
          var assignArgsList = slice(arguments, 1);
          return assign.apply(this, [Object.create(obj)].concat(assignArgsList));
        };
      } else {
        let F3 = function() {
        };
        var F2 = F3;
        return function create2(obj, assignProps1, assignProps2, etc) {
          var assignArgsList = slice(arguments, 1);
          F3.prototype = obj;
          return assign.apply(this, [new F3()].concat(assignArgsList));
        };
      }
    }
    function make_trim() {
      if (String.prototype.trim) {
        return function trim2(str2) {
          return String.prototype.trim.call(str2);
        };
      } else {
        return function trim2(str2) {
          return str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
        };
      }
    }
    function bind(obj, fn) {
      return function() {
        return fn.apply(obj, Array.prototype.slice.call(arguments, 0));
      };
    }
    function slice(arr, index) {
      return Array.prototype.slice.call(arr, index || 0);
    }
    function each(obj, fn) {
      pluck(obj, function(val, key) {
        fn(val, key);
        return false;
      });
    }
    function map(obj, fn) {
      var res = isList(obj) ? [] : {};
      pluck(obj, function(v3, k2) {
        res[k2] = fn(v3, k2);
        return false;
      });
      return res;
    }
    function pluck(obj, fn) {
      if (isList(obj)) {
        for (var i3 = 0; i3 < obj.length; i3++) {
          if (fn(obj[i3], i3)) {
            return obj[i3];
          }
        }
      } else {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (fn(obj[key], key)) {
              return obj[key];
            }
          }
        }
      }
    }
    function isList(val) {
      return val != null && typeof val != "function" && typeof val.length == "number";
    }
    function isFunction2(val) {
      return val && {}.toString.call(val) === "[object Function]";
    }
    function isObject2(val) {
      return val && {}.toString.call(val) === "[object Object]";
    }
  }
});

// node_modules/store/src/store-engine.js
var require_store_engine = __commonJS({
  "node_modules/store/src/store-engine.js"(exports2, module2) {
    init_shim();
    var util = require_util();
    var slice = util.slice;
    var pluck = util.pluck;
    var each = util.each;
    var bind = util.bind;
    var create = util.create;
    var isList = util.isList;
    var isFunction2 = util.isFunction;
    var isObject2 = util.isObject;
    module2.exports = {
      createStore
    };
    var storeAPI = {
      version: "2.0.12",
      enabled: false,
      // get returns the value of the given key. If that value
      // is undefined, it returns optionalDefaultValue instead.
      get: function(key, optionalDefaultValue) {
        var data = this.storage.read(this._namespacePrefix + key);
        return this._deserialize(data, optionalDefaultValue);
      },
      // set will store the given value at key and returns value.
      // Calling set with value === undefined is equivalent to calling remove.
      set: function(key, value) {
        if (value === void 0) {
          return this.remove(key);
        }
        this.storage.write(this._namespacePrefix + key, this._serialize(value));
        return value;
      },
      // remove deletes the key and value stored at the given key.
      remove: function(key) {
        this.storage.remove(this._namespacePrefix + key);
      },
      // each will call the given callback once for each key-value pair
      // in this store.
      each: function(callback) {
        var self2 = this;
        this.storage.each(function(val, namespacedKey) {
          callback.call(self2, self2._deserialize(val), (namespacedKey || "").replace(self2._namespaceRegexp, ""));
        });
      },
      // clearAll will remove all the stored key-value pairs in this store.
      clearAll: function() {
        this.storage.clearAll();
      },
      // additional functionality that can't live in plugins
      // ---------------------------------------------------
      // hasNamespace returns true if this store instance has the given namespace.
      hasNamespace: function(namespace) {
        return this._namespacePrefix == "__storejs_" + namespace + "_";
      },
      // createStore creates a store.js instance with the first
      // functioning storage in the list of storage candidates,
      // and applies the the given mixins to the instance.
      createStore: function() {
        return createStore.apply(this, arguments);
      },
      addPlugin: function(plugin) {
        this._addPlugin(plugin);
      },
      namespace: function(namespace) {
        return createStore(this.storage, this.plugins, namespace);
      }
    };
    function _warn() {
      var _console = typeof console == "undefined" ? null : console;
      if (!_console) {
        return;
      }
      var fn = _console.warn ? _console.warn : _console.log;
      fn.apply(_console, arguments);
    }
    function createStore(storages, plugins, namespace) {
      if (!namespace) {
        namespace = "";
      }
      if (storages && !isList(storages)) {
        storages = [storages];
      }
      if (plugins && !isList(plugins)) {
        plugins = [plugins];
      }
      var namespacePrefix = namespace ? "__storejs_" + namespace + "_" : "";
      var namespaceRegexp = namespace ? new RegExp("^" + namespacePrefix) : null;
      var legalNamespaces = /^[a-zA-Z0-9_\-]*$/;
      if (!legalNamespaces.test(namespace)) {
        throw new Error("store.js namespaces can only have alphanumerics + underscores and dashes");
      }
      var _privateStoreProps = {
        _namespacePrefix: namespacePrefix,
        _namespaceRegexp: namespaceRegexp,
        _testStorage: function(storage) {
          try {
            var testStr = "__storejs__test__";
            storage.write(testStr, testStr);
            var ok = storage.read(testStr) === testStr;
            storage.remove(testStr);
            return ok;
          } catch (e3) {
            return false;
          }
        },
        _assignPluginFnProp: function(pluginFnProp, propName) {
          var oldFn = this[propName];
          this[propName] = function pluginFn() {
            var args = slice(arguments, 0);
            var self2 = this;
            function super_fn() {
              if (!oldFn) {
                return;
              }
              each(arguments, function(arg, i3) {
                args[i3] = arg;
              });
              return oldFn.apply(self2, args);
            }
            var newFnArgs = [super_fn].concat(args);
            return pluginFnProp.apply(self2, newFnArgs);
          };
        },
        _serialize: function(obj) {
          return JSON.stringify(obj);
        },
        _deserialize: function(strVal, defaultVal) {
          if (!strVal) {
            return defaultVal;
          }
          var val = "";
          try {
            val = JSON.parse(strVal);
          } catch (e3) {
            val = strVal;
          }
          return val !== void 0 ? val : defaultVal;
        },
        _addStorage: function(storage) {
          if (this.enabled) {
            return;
          }
          if (this._testStorage(storage)) {
            this.storage = storage;
            this.enabled = true;
          }
        },
        _addPlugin: function(plugin) {
          var self2 = this;
          if (isList(plugin)) {
            each(plugin, function(plugin2) {
              self2._addPlugin(plugin2);
            });
            return;
          }
          var seenPlugin = pluck(this.plugins, function(seenPlugin2) {
            return plugin === seenPlugin2;
          });
          if (seenPlugin) {
            return;
          }
          this.plugins.push(plugin);
          if (!isFunction2(plugin)) {
            throw new Error("Plugins must be function values that return objects");
          }
          var pluginProperties = plugin.call(this);
          if (!isObject2(pluginProperties)) {
            throw new Error("Plugins must return an object of function properties");
          }
          each(pluginProperties, function(pluginFnProp, propName) {
            if (!isFunction2(pluginFnProp)) {
              throw new Error("Bad plugin property: " + propName + " from plugin " + plugin.name + ". Plugins should only return functions.");
            }
            self2._assignPluginFnProp(pluginFnProp, propName);
          });
        },
        // Put deprecated properties in the private API, so as to not expose it to accidential
        // discovery through inspection of the store object.
        // Deprecated: addStorage
        addStorage: function(storage) {
          _warn("store.addStorage(storage) is deprecated. Use createStore([storages])");
          this._addStorage(storage);
        }
      };
      var store2 = create(_privateStoreProps, storeAPI, {
        plugins: []
      });
      store2.raw = {};
      each(store2, function(prop, propName) {
        if (isFunction2(prop)) {
          store2.raw[propName] = bind(store2, prop);
        }
      });
      each(storages, function(storage) {
        store2._addStorage(storage);
      });
      each(plugins, function(plugin) {
        store2._addPlugin(plugin);
      });
      return store2;
    }
  }
});

// node_modules/store/storages/localStorage.js
var require_localStorage = __commonJS({
  "node_modules/store/storages/localStorage.js"(exports2, module2) {
    init_shim();
    var util = require_util();
    var Global = util.Global;
    module2.exports = {
      name: "localStorage",
      read,
      write,
      each,
      remove,
      clearAll
    };
    function localStorage() {
      return Global.localStorage;
    }
    function read(key) {
      return localStorage().getItem(key);
    }
    function write(key, data) {
      return localStorage().setItem(key, data);
    }
    function each(fn) {
      for (var i3 = localStorage().length - 1; i3 >= 0; i3--) {
        var key = localStorage().key(i3);
        fn(read(key), key);
      }
    }
    function remove(key) {
      return localStorage().removeItem(key);
    }
    function clearAll() {
      return localStorage().clear();
    }
  }
});

// node_modules/store/storages/oldFF-globalStorage.js
var require_oldFF_globalStorage = __commonJS({
  "node_modules/store/storages/oldFF-globalStorage.js"(exports2, module2) {
    init_shim();
    var util = require_util();
    var Global = util.Global;
    module2.exports = {
      name: "oldFF-globalStorage",
      read,
      write,
      each,
      remove,
      clearAll
    };
    var globalStorage = Global.globalStorage;
    function read(key) {
      return globalStorage[key];
    }
    function write(key, data) {
      globalStorage[key] = data;
    }
    function each(fn) {
      for (var i3 = globalStorage.length - 1; i3 >= 0; i3--) {
        var key = globalStorage.key(i3);
        fn(globalStorage[key], key);
      }
    }
    function remove(key) {
      return globalStorage.removeItem(key);
    }
    function clearAll() {
      each(function(key, _2) {
        delete globalStorage[key];
      });
    }
  }
});

// node_modules/store/storages/oldIE-userDataStorage.js
var require_oldIE_userDataStorage = __commonJS({
  "node_modules/store/storages/oldIE-userDataStorage.js"(exports2, module2) {
    init_shim();
    var util = require_util();
    var Global = util.Global;
    module2.exports = {
      name: "oldIE-userDataStorage",
      write,
      read,
      each,
      remove,
      clearAll
    };
    var storageName = "storejs";
    var doc = Global.document;
    var _withStorageEl = _makeIEStorageElFunction();
    var disable = (Global.navigator ? Global.navigator.userAgent : "").match(/ (MSIE 8|MSIE 9|MSIE 10)\./);
    function write(unfixedKey, data) {
      if (disable) {
        return;
      }
      var fixedKey = fixKey(unfixedKey);
      _withStorageEl(function(storageEl) {
        storageEl.setAttribute(fixedKey, data);
        storageEl.save(storageName);
      });
    }
    function read(unfixedKey) {
      if (disable) {
        return;
      }
      var fixedKey = fixKey(unfixedKey);
      var res = null;
      _withStorageEl(function(storageEl) {
        res = storageEl.getAttribute(fixedKey);
      });
      return res;
    }
    function each(callback) {
      _withStorageEl(function(storageEl) {
        var attributes = storageEl.XMLDocument.documentElement.attributes;
        for (var i3 = attributes.length - 1; i3 >= 0; i3--) {
          var attr = attributes[i3];
          callback(storageEl.getAttribute(attr.name), attr.name);
        }
      });
    }
    function remove(unfixedKey) {
      var fixedKey = fixKey(unfixedKey);
      _withStorageEl(function(storageEl) {
        storageEl.removeAttribute(fixedKey);
        storageEl.save(storageName);
      });
    }
    function clearAll() {
      _withStorageEl(function(storageEl) {
        var attributes = storageEl.XMLDocument.documentElement.attributes;
        storageEl.load(storageName);
        for (var i3 = attributes.length - 1; i3 >= 0; i3--) {
          storageEl.removeAttribute(attributes[i3].name);
        }
        storageEl.save(storageName);
      });
    }
    var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");
    function fixKey(key) {
      return key.replace(/^\d/, "___$&").replace(forbiddenCharsRegex, "___");
    }
    function _makeIEStorageElFunction() {
      if (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {
        return null;
      }
      var scriptTag = "script", storageOwner, storageContainer, storageEl;
      try {
        storageContainer = new ActiveXObject("htmlfile");
        storageContainer.open();
        storageContainer.write("<" + scriptTag + ">document.w=window</" + scriptTag + '><iframe src="/favicon.ico"></iframe>');
        storageContainer.close();
        storageOwner = storageContainer.w.frames[0].document;
        storageEl = storageOwner.createElement("div");
      } catch (e3) {
        storageEl = doc.createElement("div");
        storageOwner = doc.body;
      }
      return function(storeFunction) {
        var args = [].slice.call(arguments, 0);
        args.unshift(storageEl);
        storageOwner.appendChild(storageEl);
        storageEl.addBehavior("#default#userData");
        storageEl.load(storageName);
        storeFunction.apply(this, args);
        storageOwner.removeChild(storageEl);
        return;
      };
    }
  }
});

// node_modules/store/storages/cookieStorage.js
var require_cookieStorage = __commonJS({
  "node_modules/store/storages/cookieStorage.js"(exports2, module2) {
    init_shim();
    var util = require_util();
    var Global = util.Global;
    var trim = util.trim;
    module2.exports = {
      name: "cookieStorage",
      read,
      write,
      each,
      remove,
      clearAll
    };
    var doc = Global.document;
    function read(key) {
      if (!key || !_has(key)) {
        return null;
      }
      var regexpStr = "(?:^|.*;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";
      return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"));
    }
    function each(callback) {
      var cookies = doc.cookie.split(/; ?/g);
      for (var i3 = cookies.length - 1; i3 >= 0; i3--) {
        if (!trim(cookies[i3])) {
          continue;
        }
        var kvp = cookies[i3].split("=");
        var key = unescape(kvp[0]);
        var val = unescape(kvp[1]);
        callback(val, key);
      }
    }
    function write(key, data) {
      if (!key) {
        return;
      }
      doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
    }
    function remove(key) {
      if (!key || !_has(key)) {
        return;
      }
      doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
    }
    function clearAll() {
      each(function(_2, key) {
        remove(key);
      });
    }
    function _has(key) {
      return new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(doc.cookie);
    }
  }
});

// node_modules/store/storages/sessionStorage.js
var require_sessionStorage = __commonJS({
  "node_modules/store/storages/sessionStorage.js"(exports2, module2) {
    init_shim();
    var util = require_util();
    var Global = util.Global;
    module2.exports = {
      name: "sessionStorage",
      read,
      write,
      each,
      remove,
      clearAll
    };
    function sessionStorage() {
      return Global.sessionStorage;
    }
    function read(key) {
      return sessionStorage().getItem(key);
    }
    function write(key, data) {
      return sessionStorage().setItem(key, data);
    }
    function each(fn) {
      for (var i3 = sessionStorage().length - 1; i3 >= 0; i3--) {
        var key = sessionStorage().key(i3);
        fn(read(key), key);
      }
    }
    function remove(key) {
      return sessionStorage().removeItem(key);
    }
    function clearAll() {
      return sessionStorage().clear();
    }
  }
});

// node_modules/store/storages/memoryStorage.js
var require_memoryStorage = __commonJS({
  "node_modules/store/storages/memoryStorage.js"(exports2, module2) {
    init_shim();
    module2.exports = {
      name: "memoryStorage",
      read,
      write,
      each,
      remove,
      clearAll
    };
    var memoryStorage = {};
    function read(key) {
      return memoryStorage[key];
    }
    function write(key, data) {
      memoryStorage[key] = data;
    }
    function each(callback) {
      for (var key in memoryStorage) {
        if (memoryStorage.hasOwnProperty(key)) {
          callback(memoryStorage[key], key);
        }
      }
    }
    function remove(key) {
      delete memoryStorage[key];
    }
    function clearAll(key) {
      memoryStorage = {};
    }
  }
});

// node_modules/store/storages/all.js
var require_all = __commonJS({
  "node_modules/store/storages/all.js"(exports2, module2) {
    init_shim();
    module2.exports = [
      // Listed in order of usage preference
      require_localStorage(),
      require_oldFF_globalStorage(),
      require_oldIE_userDataStorage(),
      require_cookieStorage(),
      require_sessionStorage(),
      require_memoryStorage()
    ];
  }
});

// node_modules/store/plugins/lib/json2.js
var require_json2 = __commonJS({
  "node_modules/store/plugins/lib/json2.js"(exports, module) {
    init_shim();
    if (typeof JSON !== "object") {
      JSON = {};
    }
    (function() {
      "use strict";
      var rx_one = /^[\],:{}\s]*$/;
      var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
      var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
      var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
      var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      function f(n3) {
        return n3 < 10 ? "0" + n3 : n3;
      }
      function this_value() {
        return this.valueOf();
      }
      if (typeof Date.prototype.toJSON !== "function") {
        Date.prototype.toJSON = function() {
          return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
        };
        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
      }
      var gap;
      var indent;
      var meta;
      var rep;
      function quote(string) {
        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string) ? '"' + string.replace(rx_escapable, function(a3) {
          var c3 = meta[a3];
          return typeof c3 === "string" ? c3 : "\\u" + ("0000" + a3.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i3;
        var k2;
        var v3;
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            return quote(value);
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
            return String(value);
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i3 = 0; i3 < length; i3 += 1) {
                partial[i3] = str(i3, value) || "null";
              }
              v3 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v3;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i3 = 0; i3 < length; i3 += 1) {
                if (typeof rep[i3] === "string") {
                  k2 = rep[i3];
                  v3 = str(k2, value);
                  if (v3) {
                    partial.push(quote(k2) + (gap ? ": " : ":") + v3);
                  }
                }
              }
            } else {
              for (k2 in value) {
                if (Object.prototype.hasOwnProperty.call(value, k2)) {
                  v3 = str(k2, value);
                  if (v3) {
                    partial.push(quote(k2) + (gap ? ": " : ":") + v3);
                  }
                }
              }
            }
            v3 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v3;
        }
      }
      if (typeof JSON.stringify !== "function") {
        meta = {
          // table of character substitutions
          "\b": "\\b",
          "	": "\\t",
          "\n": "\\n",
          "\f": "\\f",
          "\r": "\\r",
          '"': '\\"',
          "\\": "\\\\"
        };
        JSON.stringify = function(value, replacer, space) {
          var i3;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i3 = 0; i3 < space; i3 += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
      if (typeof JSON.parse !== "function") {
        JSON.parse = function(text, reviver) {
          var j;
          function walk(holder, key) {
            var k2;
            var v3;
            var value = holder[key];
            if (value && typeof value === "object") {
              for (k2 in value) {
                if (Object.prototype.hasOwnProperty.call(value, k2)) {
                  v3 = walk(value, k2);
                  if (v3 !== void 0) {
                    value[k2] = v3;
                  } else {
                    delete value[k2];
                  }
                }
              }
            }
            return reviver.call(holder, key, value);
          }
          text = String(text);
          rx_dangerous.lastIndex = 0;
          if (rx_dangerous.test(text)) {
            text = text.replace(rx_dangerous, function(a3) {
              return "\\u" + ("0000" + a3.charCodeAt(0).toString(16)).slice(-4);
            });
          }
          if (rx_one.test(
            text.replace(rx_two, "@").replace(rx_three, "]").replace(rx_four, "")
          )) {
            j = eval("(" + text + ")");
            return typeof reviver === "function" ? walk({ "": j }, "") : j;
          }
          throw new SyntaxError("JSON.parse");
        };
      }
    })();
  }
});

// node_modules/store/plugins/json2.js
var require_json22 = __commonJS({
  "node_modules/store/plugins/json2.js"(exports2, module2) {
    init_shim();
    module2.exports = json2Plugin;
    function json2Plugin() {
      require_json2();
      return {};
    }
  }
});

// node_modules/store/dist/store.legacy.js
var require_store_legacy = __commonJS({
  "node_modules/store/dist/store.legacy.js"(exports2, module2) {
    init_shim();
    var engine = require_store_engine();
    var storages = require_all();
    var plugins = [require_json22()];
    module2.exports = engine.createStore(storages, plugins);
  }
});

// node_modules/@polkadot/react-identicon/index.js
init_shim();

// node_modules/@polkadot/react-identicon/detectPackage.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/detectPackage.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/detectOther.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-textdecoder/browser.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-global/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-global/packageInfo.js
init_shim();
var packageInfo = { name: "@polkadot/x-global", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-global/index.js
function evaluateThis(fn) {
  return fn("return this");
}
var xglobal = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : evaluateThis(Function);
function extractGlobal(name, fallback) {
  return typeof xglobal[name] === "undefined" ? fallback : xglobal[name];
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-textdecoder/fallback.js
init_shim();
var TextDecoder2 = class {
  constructor(encoding) {
    __publicField(this, "__encoding");
    this.__encoding = encoding;
  }
  decode(value) {
    let result = "";
    for (let i3 = 0, count = value.length; i3 < count; i3++) {
      result += String.fromCharCode(value[i3]);
    }
    return result;
  }
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-textdecoder/packageInfo.js
init_shim();
var packageInfo2 = { name: "@polkadot/x-textdecoder", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-textdecoder/browser.js
var TextDecoder3 = extractGlobal("TextDecoder", TextDecoder2);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-textencoder/browser.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-textencoder/fallback.js
init_shim();
var TextEncoder2 = class {
  encode(value) {
    const count = value.length;
    const u8a3 = new Uint8Array(count);
    for (let i3 = 0; i3 < count; i3++) {
      u8a3[i3] = value.charCodeAt(i3);
    }
    return u8a3;
  }
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-textencoder/packageInfo.js
init_shim();
var packageInfo3 = { name: "@polkadot/x-textencoder", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-textencoder/browser.js
var TextEncoder3 = extractGlobal("TextEncoder", TextEncoder2);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/detectOther.js
var detectOther_default = [packageInfo2, packageInfo3];

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/packageInfo.js
init_shim();
var packageInfo4 = { name: "@polkadot/util", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/versionDetect.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/function.js
init_shim();
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/versionDetect.js
var DEDUPE = "Either remove and explicitly install matching versions or dedupe using your package manager.\nThe following conflicting packages were found:";
var POLKADOTJS_DISABLE_ESM_CJS_WARNING_FLAG = "POLKADOTJS_DISABLE_ESM_CJS_WARNING";
function getEntry(name) {
  const _global = xglobal;
  if (!_global.__polkadotjs) {
    _global.__polkadotjs = {};
  }
  if (!_global.__polkadotjs[name]) {
    _global.__polkadotjs[name] = [];
  }
  return _global.__polkadotjs[name];
}
function formatDisplay(all, fmt) {
  let max = 0;
  for (let i3 = 0, count = all.length; i3 < count; i3++) {
    max = Math.max(max, all[i3].version.length);
  }
  return all.map((d3) => `	${fmt(d3.version.padEnd(max), d3).join("	")}`).join("\n");
}
function formatInfo(version, { name }) {
  return [
    version,
    name
  ];
}
function formatVersion(version, { path, type }) {
  let extracted;
  if (path && path.length >= 5) {
    const nmIndex = path.indexOf("node_modules");
    extracted = nmIndex === -1 ? path : path.substring(nmIndex);
  } else {
    extracted = "<unknown>";
  }
  return [
    `${`${type || ""}`.padStart(3)} ${version}`,
    extracted
  ];
}
function getPath(infoPath, pathOrFn) {
  if (infoPath) {
    return infoPath;
  } else if (isFunction(pathOrFn)) {
    try {
      return pathOrFn() || "";
    } catch {
      return "";
    }
  }
  return pathOrFn || "";
}
function warn(pre, all, fmt) {
  console.warn(`${pre}
${DEDUPE}
${formatDisplay(all, fmt)}`);
}
function detectPackage({ name, path, type, version }, pathOrFn, deps = []) {
  var _a, _b;
  if (!name.startsWith("@polkadot")) {
    throw new Error(`Invalid package descriptor ${name}`);
  }
  const entry = getEntry(name);
  entry.push({ path: getPath(path, pathOrFn), type, version });
  const entriesSameVersion = entry.every((e3) => e3.version === version);
  const esmCjsWarningDisabled = ((_b = (_a = xglobal.process) == null ? void 0 : _a.env) == null ? void 0 : _b[POLKADOTJS_DISABLE_ESM_CJS_WARNING_FLAG]) === "1";
  const multipleEntries = entry.length !== 1;
  const disableWarnings = esmCjsWarningDisabled && entriesSameVersion;
  if (multipleEntries && !disableWarnings) {
    warn(`${name} has multiple versions, ensure that there is only one installed.`, entry, formatVersion);
  } else {
    const mismatches = deps.filter((d3) => d3 && d3.version !== version);
    if (mismatches.length) {
      warn(`${name} requires direct dependencies exactly matching version ${version}.`, mismatches, formatInfo);
    }
  }
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/detectPackage.js
detectPackage(packageInfo4, null, detectOther_default);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bundle.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/array/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/array/chunk.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/array/filter.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/array/flatten.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/array/range.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/array/shuffle.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/array/unzip.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/array/zip.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/assert.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bi/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bi/min.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bi/helpers.js
init_shim();
function createCmp(cmp) {
  return (...items) => {
    const count = items.length;
    if (count === 0) {
      throw new Error("Must provide one or more arguments");
    }
    let result = items[0];
    for (let i3 = 1; i3 < count; i3++) {
      if (cmp(items[i3], result)) {
        result = items[i3];
      }
    }
    return result;
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bi/min.js
var nMax = createCmp((a3, b3) => a3 > b3);
var nMin = createCmp((a3, b3) => a3 < b3);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bi/sqrt.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-bigint/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-bigint/packageInfo.js
init_shim();
var packageInfo5 = { name: "@polkadot/x-bigint", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/node_modules/@polkadot/x-bigint/index.js
function invalidFallback() {
  return Number.NaN;
}
var BigInt2 = extractGlobal("BigInt", invalidFallback);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bi/consts.js
init_shim();
var _0n = BigInt2(0);
var _1n = BigInt2(1);
var _2n = BigInt2(2);
var _3n = BigInt2(3);
var _4n = BigInt2(4);
var _5n = BigInt2(5);
var _6n = BigInt2(6);
var _7n = BigInt2(7);
var _8n = BigInt2(8);
var _9n = BigInt2(9);
var _10n = BigInt2(10);
var _100n = BigInt2(100);
var _1000n = BigInt2(1e3);
var _1Mn = BigInt2(1e6);
var _1Bn = BigInt2(1e9);
var _1Qn = _1Bn * _1Bn;
var _2pow53n = BigInt2(Number.MAX_SAFE_INTEGER);
var _sqrt2pow53n = BigInt2(94906265);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bi/toBigInt.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/hex/toBigInt.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/toBigInt.js
init_shim();
var U8_MAX = BigInt2(256);
var U16_MAX = BigInt2(256 * 256);
var U64_MAX = BigInt2("0x10000000000000000");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/hex/toU8a.js
init_shim();
var CHR = "0123456789abcdef";
var U8 = new Uint8Array(256);
var U16 = new Uint8Array(256 * 256);
for (let i3 = 0, count = CHR.length; i3 < count; i3++) {
  U8[CHR[i3].charCodeAt(0) | 0] = i3 | 0;
  if (i3 > 9) {
    U8[CHR[i3].toUpperCase().charCodeAt(0) | 0] = i3 | 0;
  }
}
for (let i3 = 0; i3 < 256; i3++) {
  const s3 = i3 << 8;
  for (let j4 = 0; j4 < 256; j4++) {
    U16[s3 | j4] = U8[i3] << 4 | U8[j4];
  }
}
function hexToU8a(value, bitLength = -1) {
  if (!value) {
    return new Uint8Array();
  }
  let s3 = value.startsWith("0x") ? 2 : 0;
  const decLength = Math.ceil((value.length - s3) / 2);
  const endLength = Math.ceil(bitLength === -1 ? decLength : bitLength / 8);
  const result = new Uint8Array(endLength);
  const offset = endLength > decLength ? endLength - decLength : 0;
  for (let i3 = offset; i3 < endLength; i3++, s3 += 2) {
    result[i3] = U16[value.charCodeAt(s3) << 8 | value.charCodeAt(s3 + 1)];
  }
  return result;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/bn.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bn/bn.js
init_shim();
var import_bn = __toESM(require_bn(), 1);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/bn.js
function isBn(value) {
  return import_bn.default.isBN(value);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/hex.js
init_shim();
var REGEX_HEX_PREFIXED = /^0x[\da-fA-F]+$/;
var REGEX_HEX_NOPREFIX = /^[\da-fA-F]+$/;
function isHex(value, bitLength = -1, ignoreLength) {
  return typeof value === "string" && (value === "0x" || REGEX_HEX_PREFIXED.test(value)) && (bitLength === -1 ? ignoreLength || value.length % 2 === 0 : value.length === 2 + Math.ceil(bitLength / 4));
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/toBigInt.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/helpers.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/object.js
init_shim();
function isObject(value) {
  return !!value && typeof value === "object";
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/helpers.js
function isOn(...fns) {
  return (value) => (isObject(value) || isFunction(value)) && fns.every((f3) => isFunction(value[f3]));
}
function isOnFunction(...fns) {
  return (value) => isFunction(value) && fns.every((f3) => isFunction(value[f3]));
}
function isOnObject(...fns) {
  return (value) => isObject(value) && fns.every((f3) => isFunction(value[f3]));
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/toBigInt.js
var isToBigInt = isOn("toBigInt");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/toBn.js
init_shim();
var isToBn = isOn("toBn");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bi/toHex.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/cmp.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/toU8a.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/buffer.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/has.js
init_shim();
var hasBigInt = typeof BigInt2 === "function" && typeof BigInt2.asIntN === "function";
var hasBuffer = typeof xglobal.Buffer === "function" && typeof xglobal.Buffer.isBuffer === "function";
var hasProcess = typeof xglobal.process === "object";

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/buffer.js
function isBuffer(value) {
  return hasBuffer && !!value && isFunction(value.readDoubleLE) && xglobal.Buffer.isBuffer(value);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/u8a.js
init_shim();
function isU8a(value) {
  return (value && value.constructor) === Uint8Array || value instanceof Uint8Array;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/string/toU8a.js
init_shim();
var encoder = new TextEncoder3();
function stringToU8a(value) {
  return value ? encoder.encode(value.toString()) : new Uint8Array();
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/toU8a.js
function u8aToU8a(value) {
  return isU8a(value) ? isBuffer(value) ? new Uint8Array(value) : value : isHex(value) ? hexToU8a(value) : Array.isArray(value) ? new Uint8Array(value) : stringToU8a(value);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/concat.js
init_shim();
function u8aConcat(...list) {
  const count = list.length;
  const u8as = new Array(count);
  let length = 0;
  for (let i3 = 0; i3 < count; i3++) {
    u8as[i3] = u8aToU8a(list[i3]);
    length += u8as[i3].length;
  }
  return u8aConcatStrict(u8as, length);
}
function u8aConcatStrict(u8as, length = 0) {
  const count = u8as.length;
  let offset = 0;
  if (!length) {
    for (let i3 = 0; i3 < count; i3++) {
      length += u8as[i3].length;
    }
  }
  const result = new Uint8Array(length);
  for (let i3 = 0; i3 < count; i3++) {
    result.set(u8as[i3], offset);
    offset += u8as[i3].length;
  }
  return result;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/empty.js
init_shim();
function u8aEmpty(value) {
  const len = value.length | 0;
  for (let i3 = 0; i3 < len; i3++) {
    if (value[i3] | 0) {
      return false;
    }
  }
  return true;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/eq.js
init_shim();
function u8aEq(a3, b3) {
  const u8aa = u8aToU8a(a3);
  const u8ab = u8aToU8a(b3);
  if (u8aa.length === u8ab.length) {
    const dvA = new DataView(u8aa.buffer, u8aa.byteOffset);
    const dvB = new DataView(u8ab.buffer, u8ab.byteOffset);
    const mod2 = u8aa.length % 4 | 0;
    const length = u8aa.length - mod2 | 0;
    for (let i3 = 0; i3 < length; i3 += 4) {
      if (dvA.getUint32(i3) !== dvB.getUint32(i3)) {
        return false;
      }
    }
    for (let i3 = length, count = u8aa.length; i3 < count; i3++) {
      if (u8aa[i3] !== u8ab[i3]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/fixLength.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/sorted.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/toBn.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/toBuffer.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/toFloat.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/toHex.js
init_shim();
var U82 = new Array(256);
var U162 = new Array(256 * 256);
for (let n3 = 0; n3 < 256; n3++) {
  U82[n3] = n3.toString(16).padStart(2, "0");
}
for (let i3 = 0; i3 < 256; i3++) {
  const s3 = i3 << 8;
  for (let j4 = 0; j4 < 256; j4++) {
    U162[s3 | j4] = U82[i3] + U82[j4];
  }
}
function hex(value, result) {
  const mod2 = value.length % 2 | 0;
  const length = value.length - mod2 | 0;
  for (let i3 = 0; i3 < length; i3 += 2) {
    result += U162[value[i3] << 8 | value[i3 + 1]];
  }
  if (mod2) {
    result += U82[value[length] | 0];
  }
  return result;
}
function u8aToHex(value, bitLength = -1, isPrefixed = true) {
  const empty = isPrefixed ? "0x" : "";
  if (!(value == null ? void 0 : value.length)) {
    return empty;
  } else if (bitLength > 0) {
    const length = Math.ceil(bitLength / 8);
    if (value.length > length) {
      return `${hex(value.subarray(0, length / 2), empty)}…${hex(value.subarray(value.length - length / 2), "")}`;
    }
  }
  return hex(value, empty);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/toNumber.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/toString.js
init_shim();
var decoder = new TextDecoder3("utf-8");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/u8a/wrap.js
init_shim();
var U8A_WRAP_ETHEREUM = u8aToU8a("Ethereum Signed Message:\n");
var U8A_WRAP_PREFIX = u8aToU8a("<Bytes>");
var U8A_WRAP_POSTFIX = u8aToU8a("</Bytes>");
var WRAP_LEN = U8A_WRAP_PREFIX.length + U8A_WRAP_POSTFIX.length;

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bi/toU8a.js
init_shim();
var DIV = BigInt2(256);
var NEG_MASK = BigInt2(255);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bn/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bn/fromHex.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/hex/toBn.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/hex/stripPrefix.js
init_shim();
function hexStripPrefix(value) {
  if (!value || value === "0x") {
    return "";
  } else if (REGEX_HEX_PREFIXED.test(value)) {
    return value.substring(2);
  } else if (REGEX_HEX_NOPREFIX.test(value)) {
    return value;
  }
  throw new Error(`Expected hex value to convert, found '${value}'`);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/hex/toBn.js
function hexToBn(value, { isLe = false, isNegative = false } = {}) {
  if (!value || value === "0x") {
    return new import_bn.default(0);
  }
  const stripped = hexStripPrefix(value);
  const bn = new import_bn.default(stripped, 16, isLe ? "le" : "be");
  return isNegative ? bn.fromTwos(stripped.length * 4) : bn;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bn/min.js
init_shim();
var bnMax = createCmp((a3, b3) => a3.gt(b3));
var bnMin = createCmp((a3, b3) => a3.lt(b3));

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bn/sqrt.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bn/consts.js
init_shim();
var BN_ZERO = new import_bn.default(0);
var BN_ONE = new import_bn.default(1);
var BN_TWO = new import_bn.default(2);
var BN_THREE = new import_bn.default(3);
var BN_FOUR = new import_bn.default(4);
var BN_FIVE = new import_bn.default(5);
var BN_SIX = new import_bn.default(6);
var BN_SEVEN = new import_bn.default(7);
var BN_EIGHT = new import_bn.default(8);
var BN_NINE = new import_bn.default(9);
var BN_TEN = new import_bn.default(10);
var BN_HUNDRED = new import_bn.default(100);
var BN_THOUSAND = new import_bn.default(1e3);
var BN_MILLION = new import_bn.default(1e6);
var BN_BILLION = new import_bn.default(1e9);
var BN_QUINTILL = BN_BILLION.mul(BN_BILLION);
var BN_MAX_INTEGER = new import_bn.default(Number.MAX_SAFE_INTEGER);
var BN_SQRT_MAX_INTEGER = new import_bn.default(94906265);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bn/toBn.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/bigInt.js
init_shim();
function isBigInt(value) {
  return typeof value === "bigint";
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bn/toBn.js
function bnToBn(value) {
  return value ? import_bn.default.isBN(value) ? value : isHex(value) ? hexToBn(value.toString()) : isBigInt(value) ? new import_bn.default(value.toString()) : isToBn(value) ? value.toBn() : isToBigInt(value) ? new import_bn.default(value.toBigInt().toString()) : new import_bn.default(value) : new import_bn.default(0);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bn/toHex.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/bn/toU8a.js
init_shim();
var DEFAULT_OPTS = { bitLength: -1, isLe: true, isNegative: false };
function bnToU8a(value, { bitLength = -1, isLe = true, isNegative = false } = DEFAULT_OPTS) {
  const valueBn = bnToBn(value);
  const byteLength = bitLength === -1 ? Math.ceil(valueBn.bitLength() / 8) : Math.ceil((bitLength || 0) / 8);
  if (!value) {
    return bitLength === -1 ? new Uint8Array(1) : new Uint8Array(byteLength);
  }
  const output2 = new Uint8Array(byteLength);
  const bn = isNegative ? valueBn.toTwos(byteLength * 8) : valueBn;
  output2.set(bn.toArray(isLe ? "le" : "be", byteLength), 0);
  return output2;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/buffer/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/buffer/toU8a.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/compact/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/compact/addLength.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/compact/toU8a.js
init_shim();
var MAX_U8 = BN_TWO.pow(new import_bn.default(8 - 2)).isub(BN_ONE);
var MAX_U16 = BN_TWO.pow(new import_bn.default(16 - 2)).isub(BN_ONE);
var MAX_U32 = BN_TWO.pow(new import_bn.default(32 - 2)).isub(BN_ONE);
var BL_16 = { bitLength: 16 };
var BL_32 = { bitLength: 32 };
function compactToU8a(value) {
  const bn = bnToBn(value);
  if (bn.lte(MAX_U8)) {
    return new Uint8Array([bn.toNumber() << 2]);
  } else if (bn.lte(MAX_U16)) {
    return bnToU8a(bn.shln(2).iadd(BN_ONE), BL_16);
  } else if (bn.lte(MAX_U32)) {
    return bnToU8a(bn.shln(2).iadd(BN_TWO), BL_32);
  }
  const u8a3 = bnToU8a(bn);
  let length = u8a3.length;
  while (u8a3[length - 1] === 0) {
    length--;
  }
  if (length < 4) {
    throw new Error("Invalid length, previous checks match anything less than 2^30");
  }
  return u8aConcatStrict([
    // subtract 4 as minimum (also catered for in decoding)
    new Uint8Array([(length - 4 << 2) + 3]),
    u8a3.subarray(0, length)
  ]);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/compact/addLength.js
function compactAddLength(input) {
  return u8aConcatStrict([
    compactToU8a(input.length),
    input
  ]);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/compact/fromU8a.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/compact/stripLength.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/extractTime.js
init_shim();
var MIN_MS = 60 * 1e3;
var HR_MS = MIN_MS * 60;
var DAY_MS = HR_MS * 24;

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/float/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/float/toU8a.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/format/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/format/formatBalance.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/boolean.js
init_shim();
function isBoolean(value) {
  return typeof value === "boolean";
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/format/formatDecimal.js
init_shim();
var NUMBER_REGEX = new RegExp("(\\d+?)(?=(\\d{3})+(?!\\d)|$)", "g");
function formatDecimal(value, separator = ",") {
  const isNegative = value[0].startsWith("-");
  const matched = isNegative ? value.substring(1).match(NUMBER_REGEX) : value.match(NUMBER_REGEX);
  return matched ? `${isNegative ? "-" : ""}${matched.join(separator)}` : value;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/format/getSeparator.js
init_shim();
function getSeparator(locale) {
  return {
    decimal: 0.1.toLocaleString(locale).substring(1, 2),
    thousand: 1e3.toLocaleString(locale).substring(1, 2)
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/format/si.js
init_shim();
var SI_MID = 8;
var SI = [
  { power: -24, text: "yocto", value: "y" },
  { power: -21, text: "zepto", value: "z" },
  { power: -18, text: "atto", value: "a" },
  { power: -15, text: "femto", value: "f" },
  { power: -12, text: "pico", value: "p" },
  { power: -9, text: "nano", value: "n" },
  { power: -6, text: "micro", value: "µ" },
  { power: -3, text: "milli", value: "m" },
  { power: 0, text: "Unit", value: "-" },
  { power: 3, text: "Kilo", value: "k" },
  { power: 6, text: "Mill", value: "M" },
  { power: 9, text: "Bill", value: "B" },
  { power: 12, text: "Tril", value: "T" },
  { power: 15, text: "Peta", value: "P" },
  { power: 18, text: "Exa", value: "E" },
  { power: 21, text: "Zeta", value: "Z" },
  { power: 24, text: "Yotta", value: "Y" }
];
function findSi(type) {
  for (let i3 = 0, count = SI.length; i3 < count; i3++) {
    if (SI[i3].value === type) {
      return SI[i3];
    }
  }
  return SI[SI_MID];
}
function calcSi(text2, decimals, forceUnit) {
  if (forceUnit) {
    return findSi(forceUnit);
  }
  const siDefIndex = SI_MID - 1 + Math.ceil((text2.length - decimals) / 3);
  return SI[siDefIndex] || SI[siDefIndex < 0 ? 0 : SI.length - 1];
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/format/formatBalance.js
var DEFAULT_DECIMALS = 0;
var DEFAULT_UNIT = SI[SI_MID].text;
var defaultDecimals = DEFAULT_DECIMALS;
var defaultUnit = DEFAULT_UNIT;
function _formatBalance(input, { decimals = defaultDecimals, forceUnit, locale = "en", withAll = false, withSi = true, withSiFull = false, withUnit = true, withZero = true } = {}) {
  let text2 = bnToBn(input).toString();
  if (text2.length === 0 || text2 === "0") {
    return "0";
  }
  let sign = "";
  if (text2[0].startsWith("-")) {
    sign = "-";
    text2 = text2.substring(1);
  }
  const si = calcSi(text2, decimals, forceUnit);
  const mid = text2.length - (decimals + si.power);
  const pre = mid <= 0 ? "0" : text2.substring(0, mid);
  let post = text2.padStart(mid < 0 ? decimals : 1, "0").substring(mid < 0 ? 0 : mid).padEnd(withAll ? Math.max(decimals, 4) : 4, "0").substring(0, withAll ? Math.max(4, decimals + si.power) : 4);
  if (!withZero) {
    let end = post.length - 1;
    do {
      if (post[end] === "0") {
        end--;
      }
    } while (post[end] === "0");
    post = post.substring(0, end + 1);
  }
  const unit = isBoolean(withUnit) ? SI[SI_MID].text : withUnit;
  const units = withSi || withSiFull ? si.value === "-" ? withUnit ? ` ${unit}` : "" : ` ${withSiFull ? `${si.text}${withUnit ? " " : ""}` : si.value}${withUnit ? unit : ""}` : "";
  const { decimal, thousand } = getSeparator(locale);
  return `${sign}${formatDecimal(pre, thousand)}${post && `${decimal}${post}`}${units}`;
}
var formatBalance = _formatBalance;
formatBalance.calcSi = (text2, decimals = defaultDecimals) => calcSi(text2, decimals);
formatBalance.findSi = findSi;
formatBalance.getDefaults = () => {
  return {
    decimals: defaultDecimals,
    unit: defaultUnit
  };
};
formatBalance.getOptions = (decimals = defaultDecimals) => {
  return SI.filter(({ power }) => power < 0 ? decimals + power >= 0 : true);
};
formatBalance.setDefaults = ({ decimals, unit }) => {
  defaultDecimals = (Array.isArray(decimals) ? decimals[0] : decimals) ?? defaultDecimals;
  defaultUnit = (Array.isArray(unit) ? unit[0] : unit) ?? defaultUnit;
  SI[SI_MID].text = defaultUnit;
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/format/formatDate.js
init_shim();
function zeroPad(value) {
  return value.toString().padStart(2, "0");
}
function formatDate(date) {
  const year = date.getFullYear().toString();
  const month = zeroPad(date.getMonth() + 1);
  const day = zeroPad(date.getDate());
  const hour = zeroPad(date.getHours());
  const minute = zeroPad(date.getMinutes());
  const second = zeroPad(date.getSeconds());
  return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/format/formatElapsed.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/format/formatNumber.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/hex/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/hex/addPrefix.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/hex/hasPrefix.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/hex/fixLength.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/hex/toNumber.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/hex/toString.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/array.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/ascii.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/string.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/childClass.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/class.js
init_shim();
var isClass = isOnFunction("isPrototypeOf", "hasOwnProperty");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/codec.js
init_shim();
var checkCodec = isOnObject("toHex", "toHuman", "toU8a");
var checkRegistry = isOnObject("get");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/compact.js
init_shim();
var isCompact = isOnObject("toBigInt", "toBn", "toNumber", "unwrap");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/error.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/instanceOf.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/ip.js
init_shim();
var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6s = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6s}:){7}(?:${v6s}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6s}:){6}(?:${v4}|:${v6s}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6s}:){5}(?::${v4}|(?::${v6s}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6s}:){4}(?:(?::${v6s}){0,1}:${v4}|(?::${v6s}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6s}:){3}(?:(?::${v6s}){0,2}:${v4}|(?::${v6s}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6s}:){2}(?:(?::${v6s}){0,3}:${v4}|(?::${v6s}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6s}:){1}(?:(?::${v6s}){0,4}:${v4}|(?::${v6s}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6s}){0,5}:${v4}|(?::${v6s}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v4}$`);
var v6exact = new RegExp(`^${v6}$`);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/jsonObject.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/stringify.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/null.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/number.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/observable.js
init_shim();
var isObservable = isOn("next");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/promise.js
init_shim();
var isPromise = isOnObject("catch", "then");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/riscv.js
init_shim();
var ELF_MAGIC = new Uint8Array([127, 69, 76, 70]);
var PVM_MAGIC = new Uint8Array([80, 86, 77, 0]);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/testChain.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/undefined.js
init_shim();
function isUndefined(value) {
  return value === void 0;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/utf8.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/is/wasm.js
init_shim();
var WASM_MAGIC = new Uint8Array([0, 97, 115, 109]);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/lazy.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/logger.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/noop.js
init_shim();
function noop() {
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/logger.js
var logTo = {
  debug: "log",
  error: "error",
  log: "log",
  warn: "warn"
};
function formatOther(value) {
  if (value && isObject(value) && value.constructor === Object) {
    const result = {};
    for (const [k2, v3] of Object.entries(value)) {
      result[k2] = loggerFormat(v3);
    }
    return result;
  }
  return value;
}
function loggerFormat(value) {
  if (Array.isArray(value)) {
    return value.map(loggerFormat);
  } else if (isBn(value)) {
    return value.toString();
  } else if (isU8a(value) || isBuffer(value)) {
    return u8aToHex(u8aToU8a(value));
  }
  return formatOther(value);
}
function formatWithLength(maxLength) {
  return (v3) => {
    if (maxLength <= 0) {
      return v3;
    }
    const r3 = `${v3}`;
    return r3.length < maxLength ? v3 : `${r3.substring(0, maxLength)} ...`;
  };
}
function apply(log, type, values, maxSize = -1) {
  if (values.length === 1 && isFunction(values[0])) {
    const fnResult = values[0]();
    return apply(log, type, Array.isArray(fnResult) ? fnResult : [fnResult], maxSize);
  }
  console[logTo[log]](formatDate(/* @__PURE__ */ new Date()), type, ...values.map(loggerFormat).map(formatWithLength(maxSize)));
}
function isDebugOn(e3, type) {
  return !!e3 && (e3 === "*" || type === e3 || e3.endsWith("*") && type.startsWith(e3.slice(0, -1)));
}
function isDebugOff(e3, type) {
  return !!e3 && (e3.startsWith("-") && (type === e3.slice(1) || e3.endsWith("*") && type.startsWith(e3.slice(1, -1))));
}
function getDebugFlag(env, type) {
  let flag = false;
  for (const e3 of env) {
    if (isDebugOn(e3, type)) {
      flag = true;
    } else if (isDebugOff(e3, type)) {
      flag = false;
    }
  }
  return flag;
}
function parseEnv(type) {
  var _a, _b, _c, _d;
  const maxSize = parseInt(((_b = (_a = xglobal.process) == null ? void 0 : _a.env) == null ? void 0 : _b["DEBUG_MAX"]) || "-1", 10);
  return [
    getDebugFlag((((_d = (_c = xglobal.process) == null ? void 0 : _c.env) == null ? void 0 : _d["DEBUG"]) || "").toLowerCase().split(","), type),
    isNaN(maxSize) ? -1 : maxSize
  ];
}
function logger(origin) {
  const type = `${origin.toUpperCase()}:`.padStart(16);
  const [isDebug, maxSize] = parseEnv(origin.toLowerCase());
  return {
    debug: isDebug ? (...values) => apply("debug", type, values, maxSize) : noop,
    error: (...values) => apply("error", type, values),
    log: (...values) => apply("log", type, values),
    noop,
    warn: (...values) => apply("warn", type, values)
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/memoize.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/nextTick.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/number/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/number/toHex.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/number/toU8a.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/object/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/object/clear.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/object/copy.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/object/spread.js
init_shim();
function objectSpread(dest, ...sources) {
  for (let i3 = 0, count = sources.length; i3 < count; i3++) {
    const src = sources[i3];
    if (src) {
      if (typeof src.entries === "function") {
        for (const [key, value] of src.entries()) {
          dest[key] = value;
        }
      } else {
        Object.assign(dest, src);
      }
    }
  }
  return dest;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/object/entries.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/object/keys.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/object/property.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/object/values.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/promisify.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/string/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/string/camelCase.js
init_shim();
var CC_TO_UP = new Array(256);
var CC_TO_LO = new Array(256);
for (let i3 = 0, count = CC_TO_UP.length; i3 < count; i3++) {
  CC_TO_LO[i3] = String.fromCharCode(i3).toLowerCase();
  CC_TO_UP[i3] = String.fromCharCode(i3).toUpperCase();
}
function formatAllCaps(w3) {
  return w3.slice(0, w3.length - 1).toLowerCase() + CC_TO_UP[w3.charCodeAt(w3.length - 1)];
}
function converter(format) {
  return (value) => {
    const parts = value.replace(/[-_., ]+/g, " ").trim().split(" ");
    let result = "";
    for (let i3 = 0, count = parts.length; i3 < count; i3++) {
      const w3 = parts[i3];
      result += format(/^[\dA-Z]+$/.test(w3) ? w3.toLowerCase() : w3.replace(/^[\dA-Z]{2,}[^a-z]/, formatAllCaps), i3);
    }
    return result;
  };
}
var stringCamelCase = converter((w3, i3) => (i3 ? CC_TO_UP[w3.charCodeAt(0)] : CC_TO_LO[w3.charCodeAt(0)]) + w3.slice(1));
var stringPascalCase = converter((w3) => CC_TO_UP[w3.charCodeAt(0)] + w3.slice(1));

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/string/lowerFirst.js
init_shim();
function converter2(map) {
  return (value) => value ? map[value.charCodeAt(0)] + value.slice(1) : "";
}
var stringLowerFirst = converter2(CC_TO_LO);
var stringUpperFirst = converter2(CC_TO_UP);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/string/shorten.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util/string/toHex.js
init_shim();

// node_modules/@polkadot/react-identicon/detectOther.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/packageInfo.js
init_shim();
var packageInfo6 = { name: "@polkadot/ui-settings", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "3.5.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/packageInfo.js
init_shim();
var packageInfo7 = { name: "@polkadot/ui-shared", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "3.5.1" };

// node_modules/@polkadot/react-identicon/detectOther.js
var detectOther_default2 = [packageInfo6, packageInfo7];

// node_modules/@polkadot/react-identicon/packageInfo.js
init_shim();
var packageInfo8 = { name: "@polkadot/react-identicon", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "3.5.1" };

// node_modules/@polkadot/react-identicon/detectPackage.js
detectPackage(packageInfo8, null, detectOther_default2);

// node_modules/@polkadot/react-identicon/bundle.js
init_shim();

// node_modules/@polkadot/react-identicon/icons/index.js
init_shim();

// node_modules/@polkadot/react-identicon/icons/Beachball.js
init_shim();
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/detectPackage.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/detectOther.js
init_shim();
var detectOther_default3 = [];

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/detectPackage.js
detectPackage(packageInfo7, null, detectOther_default3);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/bundle.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/shape/circle.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/defaults.js
init_shim();
var COLORS = [
  // https://sashat.me/2017/01/11/list-of-20-simple-distinct-colors/
  "#ffe119",
  "#4363d8",
  "#f58231",
  "#fabebe",
  "#e6beff",
  "#800000",
  "#000075",
  "#a9a9a9",
  "#ffffff",
  "#000000"
];
var SHAPE_COUNT = 5;

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/svg/circle.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/svg/svg.js
init_shim();
var SVG_NS = "http://www.w3.org/2000/svg";
function svg(type) {
  return document.createElementNS(SVG_NS, type);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/svg/circle.js
function circle(r3, cx, cy) {
  const elem = svg("circle");
  elem.setAttributeNS("", "cx", `${cx}`);
  elem.setAttributeNS("", "cy", `${cy}`);
  elem.setAttributeNS("", "r", `${r3}`);
  return elem;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/shape/circle.js
function circle2(seeder2, fill, diameter, count) {
  const center = diameter / 2;
  const angle = seeder2() * 360;
  const radius = (SHAPE_COUNT - count) / SHAPE_COUNT * (diameter / 2) + diameter / 8 * seeder2();
  const offset = diameter / 4 * (seeder2() + (count + 1) / SHAPE_COUNT);
  const cx = offset * Math.sin(angle) + center;
  const cy = offset * Math.cos(angle) + center;
  const svg2 = circle(radius, cx, cy);
  svg2.setAttributeNS("", "fill", fill);
  return svg2;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/svg/element.js
init_shim();
function element(size, type = "svg", x3 = 0, y3 = 0) {
  const elem = svg(type);
  elem.setAttributeNS("", "x", `${x3}`);
  elem.setAttributeNS("", "y", `${y3}`);
  elem.setAttributeNS("", "width", `${size}`);
  elem.setAttributeNS("", "height", `${size}`);
  return elem;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/colors.js
init_shim();

// node_modules/colord/index.mjs
init_shim();
var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
var t = function(r3) {
  return "string" == typeof r3 ? r3.length > 0 : "number" == typeof r3;
};
var n = function(r3, t3, n3) {
  return void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = Math.pow(10, t3)), Math.round(n3 * r3) / n3 + 0;
};
var e = function(r3, t3, n3) {
  return void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = 1), r3 > n3 ? n3 : r3 > t3 ? r3 : t3;
};
var u = function(r3) {
  return (r3 = isFinite(r3) ? r3 % 360 : 0) > 0 ? r3 : r3 + 360;
};
var a = function(r3) {
  return { r: e(r3.r, 0, 255), g: e(r3.g, 0, 255), b: e(r3.b, 0, 255), a: e(r3.a) };
};
var o = function(r3) {
  return { r: n(r3.r), g: n(r3.g), b: n(r3.b), a: n(r3.a, 3) };
};
var i = /^#([0-9a-f]{3,8})$/i;
var s = function(r3) {
  var t3 = r3.toString(16);
  return t3.length < 2 ? "0" + t3 : t3;
};
var h = function(r3) {
  var t3 = r3.r, n3 = r3.g, e3 = r3.b, u3 = r3.a, a3 = Math.max(t3, n3, e3), o3 = a3 - Math.min(t3, n3, e3), i3 = o3 ? a3 === t3 ? (n3 - e3) / o3 : a3 === n3 ? 2 + (e3 - t3) / o3 : 4 + (t3 - n3) / o3 : 0;
  return { h: 60 * (i3 < 0 ? i3 + 6 : i3), s: a3 ? o3 / a3 * 100 : 0, v: a3 / 255 * 100, a: u3 };
};
var b = function(r3) {
  var t3 = r3.h, n3 = r3.s, e3 = r3.v, u3 = r3.a;
  t3 = t3 / 360 * 6, n3 /= 100, e3 /= 100;
  var a3 = Math.floor(t3), o3 = e3 * (1 - n3), i3 = e3 * (1 - (t3 - a3) * n3), s3 = e3 * (1 - (1 - t3 + a3) * n3), h2 = a3 % 6;
  return { r: 255 * [e3, i3, o3, o3, s3, e3][h2], g: 255 * [s3, e3, e3, i3, o3, o3][h2], b: 255 * [o3, o3, s3, e3, e3, i3][h2], a: u3 };
};
var g = function(r3) {
  return { h: u(r3.h), s: e(r3.s, 0, 100), l: e(r3.l, 0, 100), a: e(r3.a) };
};
var d = function(r3) {
  return { h: n(r3.h), s: n(r3.s), l: n(r3.l), a: n(r3.a, 3) };
};
var f2 = function(r3) {
  return b((n3 = (t3 = r3).s, { h: t3.h, s: (n3 *= ((e3 = t3.l) < 50 ? e3 : 100 - e3) / 100) > 0 ? 2 * n3 / (e3 + n3) * 100 : 0, v: e3 + n3, a: t3.a }));
  var t3, n3, e3;
};
var c = function(r3) {
  return { h: (t3 = h(r3)).h, s: (u3 = (200 - (n3 = t3.s)) * (e3 = t3.v) / 100) > 0 && u3 < 200 ? n3 * e3 / 100 / (u3 <= 100 ? u3 : 200 - u3) * 100 : 0, l: u3 / 2, a: t3.a };
  var t3, n3, e3, u3;
};
var l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var y = { string: [[function(r3) {
  var t3 = i.exec(r3);
  return t3 ? (r3 = t3[1]).length <= 4 ? { r: parseInt(r3[0] + r3[0], 16), g: parseInt(r3[1] + r3[1], 16), b: parseInt(r3[2] + r3[2], 16), a: 4 === r3.length ? n(parseInt(r3[3] + r3[3], 16) / 255, 2) : 1 } : 6 === r3.length || 8 === r3.length ? { r: parseInt(r3.substr(0, 2), 16), g: parseInt(r3.substr(2, 2), 16), b: parseInt(r3.substr(4, 2), 16), a: 8 === r3.length ? n(parseInt(r3.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r3) {
  var t3 = v.exec(r3) || m.exec(r3);
  return t3 ? t3[2] !== t3[4] || t3[4] !== t3[6] ? null : a({ r: Number(t3[1]) / (t3[2] ? 100 / 255 : 1), g: Number(t3[3]) / (t3[4] ? 100 / 255 : 1), b: Number(t3[5]) / (t3[6] ? 100 / 255 : 1), a: void 0 === t3[7] ? 1 : Number(t3[7]) / (t3[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t3) {
  var n3 = l.exec(t3) || p.exec(t3);
  if (!n3)
    return null;
  var e3, u3, a3 = g({ h: (e3 = n3[1], u3 = n3[2], void 0 === u3 && (u3 = "deg"), Number(e3) * (r[u3] || 1)), s: Number(n3[3]), l: Number(n3[4]), a: void 0 === n3[5] ? 1 : Number(n3[5]) / (n3[6] ? 100 : 1) });
  return f2(a3);
}, "hsl"]], object: [[function(r3) {
  var n3 = r3.r, e3 = r3.g, u3 = r3.b, o3 = r3.a, i3 = void 0 === o3 ? 1 : o3;
  return t(n3) && t(e3) && t(u3) ? a({ r: Number(n3), g: Number(e3), b: Number(u3), a: Number(i3) }) : null;
}, "rgb"], [function(r3) {
  var n3 = r3.h, e3 = r3.s, u3 = r3.l, a3 = r3.a, o3 = void 0 === a3 ? 1 : a3;
  if (!t(n3) || !t(e3) || !t(u3))
    return null;
  var i3 = g({ h: Number(n3), s: Number(e3), l: Number(u3), a: Number(o3) });
  return f2(i3);
}, "hsl"], [function(r3) {
  var n3 = r3.h, a3 = r3.s, o3 = r3.v, i3 = r3.a, s3 = void 0 === i3 ? 1 : i3;
  if (!t(n3) || !t(a3) || !t(o3))
    return null;
  var h2 = function(r4) {
    return { h: u(r4.h), s: e(r4.s, 0, 100), v: e(r4.v, 0, 100), a: e(r4.a) };
  }({ h: Number(n3), s: Number(a3), v: Number(o3), a: Number(s3) });
  return b(h2);
}, "hsv"]] };
var N = function(r3, t3) {
  for (var n3 = 0; n3 < t3.length; n3++) {
    var e3 = t3[n3][0](r3);
    if (e3)
      return [e3, t3[n3][1]];
  }
  return [null, void 0];
};
var x = function(r3) {
  return "string" == typeof r3 ? N(r3.trim(), y.string) : "object" == typeof r3 && null !== r3 ? N(r3, y.object) : [null, void 0];
};
var M = function(r3, t3) {
  var n3 = c(r3);
  return { h: n3.h, s: e(n3.s + 100 * t3, 0, 100), l: n3.l, a: n3.a };
};
var H = function(r3) {
  return (299 * r3.r + 587 * r3.g + 114 * r3.b) / 1e3 / 255;
};
var $ = function(r3, t3) {
  var n3 = c(r3);
  return { h: n3.h, s: n3.s, l: e(n3.l + 100 * t3, 0, 100), a: n3.a };
};
var j2 = function() {
  function r3(r4) {
    this.parsed = x(r4)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r3.prototype.isValid = function() {
    return null !== this.parsed;
  }, r3.prototype.brightness = function() {
    return n(H(this.rgba), 2);
  }, r3.prototype.isDark = function() {
    return H(this.rgba) < 0.5;
  }, r3.prototype.isLight = function() {
    return H(this.rgba) >= 0.5;
  }, r3.prototype.toHex = function() {
    return r4 = o(this.rgba), t3 = r4.r, e3 = r4.g, u3 = r4.b, i3 = (a3 = r4.a) < 1 ? s(n(255 * a3)) : "", "#" + s(t3) + s(e3) + s(u3) + i3;
    var r4, t3, e3, u3, a3, i3;
  }, r3.prototype.toRgb = function() {
    return o(this.rgba);
  }, r3.prototype.toRgbString = function() {
    return r4 = o(this.rgba), t3 = r4.r, n3 = r4.g, e3 = r4.b, (u3 = r4.a) < 1 ? "rgba(" + t3 + ", " + n3 + ", " + e3 + ", " + u3 + ")" : "rgb(" + t3 + ", " + n3 + ", " + e3 + ")";
    var r4, t3, n3, e3, u3;
  }, r3.prototype.toHsl = function() {
    return d(c(this.rgba));
  }, r3.prototype.toHslString = function() {
    return r4 = d(c(this.rgba)), t3 = r4.h, n3 = r4.s, e3 = r4.l, (u3 = r4.a) < 1 ? "hsla(" + t3 + ", " + n3 + "%, " + e3 + "%, " + u3 + ")" : "hsl(" + t3 + ", " + n3 + "%, " + e3 + "%)";
    var r4, t3, n3, e3, u3;
  }, r3.prototype.toHsv = function() {
    return r4 = h(this.rgba), { h: n(r4.h), s: n(r4.s), v: n(r4.v), a: n(r4.a, 3) };
    var r4;
  }, r3.prototype.invert = function() {
    return w({ r: 255 - (r4 = this.rgba).r, g: 255 - r4.g, b: 255 - r4.b, a: r4.a });
    var r4;
  }, r3.prototype.saturate = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w(M(this.rgba, r4));
  }, r3.prototype.desaturate = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w(M(this.rgba, -r4));
  }, r3.prototype.grayscale = function() {
    return w(M(this.rgba, -1));
  }, r3.prototype.lighten = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w($(this.rgba, r4));
  }, r3.prototype.darken = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w($(this.rgba, -r4));
  }, r3.prototype.rotate = function(r4) {
    return void 0 === r4 && (r4 = 15), this.hue(this.hue() + r4);
  }, r3.prototype.alpha = function(r4) {
    return "number" == typeof r4 ? w({ r: (t3 = this.rgba).r, g: t3.g, b: t3.b, a: r4 }) : n(this.rgba.a, 3);
    var t3;
  }, r3.prototype.hue = function(r4) {
    var t3 = c(this.rgba);
    return "number" == typeof r4 ? w({ h: r4, s: t3.s, l: t3.l, a: t3.a }) : n(t3.h);
  }, r3.prototype.isEqual = function(r4) {
    return this.toHex() === w(r4).toHex();
  }, r3;
}();
var w = function(r3) {
  return r3 instanceof j2 ? r3 : new j2(r3);
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/colors.js
var WOBBLE = 30;
function colors(seeder2) {
  const amount = seeder2() * WOBBLE - WOBBLE / 2;
  const all = COLORS.map((hex3) => w(hex3).rotate(amount));
  return (alpha = 1) => {
    const index = Math.floor(all.length * seeder2());
    return all.splice(index, 1)[0].alpha(alpha).toHslString();
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/container.js
init_shim();
function container(diameter, background = "white", className = "", _style = {}) {
  const element2 = document.createElement("div");
  const style = Object.assign({
    background,
    borderRadius: `${diameter / 2}px`,
    display: "inline-block",
    height: `${diameter}px`,
    margin: "0px",
    overflow: "hidden",
    padding: "0px",
    width: `${diameter}px`
  }, _style);
  element2.className = className;
  element2.style.background = background;
  Object.keys(style).forEach((key) => {
    element2.style[key] = style[key];
  });
  return element2;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/seeder.js
init_shim();
var DIVISOR = 256 * 256;
function seeder(_seed = new Uint8Array(32)) {
  const seed = isU8a(_seed) ? _seed : stringToU8a(_seed);
  let index = seed[Math.floor(seed.length / 2)] % seed.length - 1;
  const next = () => {
    index += 1;
    if (index === seed.length) {
      index = 0;
    }
    return seed[index];
  };
  return () => {
    return (next() * 256 + next()) / DIVISOR;
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/beachball/index.js
function beachballIcon(seed, { size = 256 }, className = "", style) {
  const seeder2 = seeder(seed);
  const colorGen = colors(seeder2);
  const outer = container(size, "white", className, style);
  const container2 = container(size, colorGen());
  const svg2 = element(size);
  outer.appendChild(container2);
  container2.appendChild(svg2);
  for (let count = 0; count < SHAPE_COUNT; count++) {
    const fill = colorGen();
    const shape = circle2(seeder2, fill, size, count);
    svg2.appendChild(shape);
  }
  return outer;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/polkadot.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/detectPackage.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/detectOther.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/networks/packageInfo.js
init_shim();
var packageInfo9 = { name: "@polkadot/networks", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-randomvalues/browser.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-randomvalues/node_modules/@polkadot/x-global/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-randomvalues/node_modules/@polkadot/x-global/packageInfo.js
init_shim();
var packageInfo10 = { name: "@polkadot/x-global", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-randomvalues/node_modules/@polkadot/x-global/index.js
function evaluateThis2(fn) {
  return fn("return this");
}
var xglobal2 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : evaluateThis2(Function);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-randomvalues/packageInfo.js
init_shim();
var packageInfo11 = { name: "@polkadot/x-randomvalues", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-randomvalues/browser.js
var crypto = xglobal2.crypto;
function getRandomValues(arr) {
  return crypto.getRandomValues(arr);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/detectOther.js
var detectOther_default4 = [packageInfo9, packageInfo4, packageInfo11];

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/packageInfo.js
init_shim();
var packageInfo12 = { name: "@polkadot/util-crypto", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/detectPackage.js
detectPackage(packageInfo12, null, detectOther_default4);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/bundle.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/bundleInit.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-bigint/shim.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-bigint/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-bigint/node_modules/@polkadot/x-global/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-bigint/node_modules/@polkadot/x-global/packageInfo.js
init_shim();
var packageInfo13 = { name: "@polkadot/x-global", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-bigint/node_modules/@polkadot/x-global/index.js
function evaluateThis3(fn) {
  return fn("return this");
}
var xglobal3 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : evaluateThis3(Function);
function extractGlobal2(name, fallback) {
  return typeof xglobal3[name] === "undefined" ? fallback : xglobal3[name];
}
function exposeGlobal(name, fallback) {
  if (typeof xglobal3[name] === "undefined") {
    xglobal3[name] = fallback;
  }
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-bigint/packageInfo.js
init_shim();
var packageInfo14 = { name: "@polkadot/x-bigint", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-bigint/index.js
function invalidFallback2() {
  return Number.NaN;
}
var BigInt3 = extractGlobal2("BigInt", invalidFallback2);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/x-bigint/shim.js
exposeGlobal("BigInt", BigInt3);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/crypto.js
init_shim();
function cryptoWaitReady() {
  return waitReady().then(() => {
    if (!isReady()) {
      throw new Error("Unable to initialize @polkadot/util-crypto");
    }
    return true;
  }).catch(() => false);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/bundleInit.js
cryptoWaitReady().catch(() => {
});

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/addressToEvm.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/decode.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/base58/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/base58/bs58.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@scure/base/lib/esm/index.js
init_shim();
function assertNumber(n3) {
  if (!Number.isSafeInteger(n3))
    throw new Error(`Wrong integer: ${n3}`);
}
function chain(...args) {
  const wrap = (a3, b3) => (c3) => a3(b3(c3));
  const encode = Array.from(args).reverse().reduce((acc, i3) => acc ? wrap(acc, i3.encode) : i3.encode, void 0);
  const decode = args.reduce((acc, i3) => acc ? wrap(acc, i3.decode) : i3.decode, void 0);
  return { encode, decode };
}
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i3) => {
        assertNumber(i3);
        if (i3 < 0 || i3 >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i3} (alphabet: ${alphabet2.length})`);
        return alphabet2[i3];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from) => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i3 of from)
        if (typeof i3 !== "string")
          throw new Error(`join.encode: non-string input=${i3}`);
      return from.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  assertNumber(bits);
  if (typeof chr !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i3 of data)
        if (typeof i3 !== "string")
          throw new Error(`padding.encode: non-string input=${i3}`);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i3 of input)
        if (typeof i3 !== "string")
          throw new Error(`padding.decode: non-string input=${i3}`);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  if (typeof fn !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d3) => {
    assertNumber(d3);
    if (d3 < 0 || d3 >= from)
      throw new Error(`Wrong integer: ${d3}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i3 = pos; i3 < digits.length; i3++) {
      const digit = digits[i3];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      const rounded = Math.floor(digitBase / to);
      digits[i3] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i3;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i3 = 0; i3 < data.length - 1 && data[i3] === 0; i3++)
    res.push(0);
  return res.reverse();
}
var gcd = (
  /* @__NO_SIDE_EFFECTS__ */
  (a3, b3) => !b3 ? a3 : gcd(b3, a3 % b3)
);
var radix2carry = (
  /*@__NO_SIDE_EFFECTS__ */
  (from, to) => from + (to - gcd(from, to))
);
function convertRadix2(data, from, to, padding2) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to - 1;
  const res = [];
  for (const n3 of data) {
    assertNumber(n3);
    if (n3 >= 2 ** from)
      throw new Error(`convertRadix2: invalid data word=${n3} from=${from}`);
    carry = carry << from | n3;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  assertNumber(num);
  return {
    encode: (bytes2) => {
      if (!(bytes2 instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes2), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
function radix2(bits, revPadding = false) {
  assertNumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!(bytes2 instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  if (typeof fn !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e3) {
    }
  };
}
function checksum(len, fn) {
  assertNumber(len);
  if (typeof fn !== "function")
    throw new Error("checksum fn should be function");
  return {
    encode(data) {
      if (!(data instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const checksum2 = fn(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(checksum2, data.length);
      return res;
    },
    decode(data) {
      if (!(data instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const newChecksum = fn(payload).slice(0, len);
      const oldChecksum = data.slice(-len);
      for (let i3 = 0; i3 < len; i3++)
        if (newChecksum[i3] !== oldChecksum[i3])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var utils = { alphabet, chain, checksum, radix, radix2, join, padding };
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s3) => s3.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b3 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i3 = 0; i3 < POLYMOD_GENERATORS.length; i3++) {
    if ((b3 >> i3 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i3];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i3 = 0; i3 < len; i3++) {
    const c3 = prefix.charCodeAt(i3);
    if (c3 < 33 || c3 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c3 >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i3 = 0; i3 < len; i3++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i3) & 31;
  for (let v3 of words)
    chk = bech32Polymod(chk) ^ v3;
  for (let i3 = 0; i3 < 6; i3++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    if (typeof prefix !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str2, limit = 90) {
    if (typeof str2 !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str2}`);
    if (str2.length < 8 || limit !== false && str2.length > limit)
      throw new TypeError(`Wrong string length: ${str2.length} (${str2}). Expected (8..${limit})`);
    const lowered = str2.toLowerCase();
    if (str2 !== lowered && str2 !== str2.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    str2 = lowered;
    const sepIndex = str2.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = str2.slice(0, sepIndex);
    const _words2 = str2.slice(sepIndex + 1);
    if (_words2.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!_words2.endsWith(sum))
      throw new Error(`Invalid checksum in ${str2}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str2) {
    const { prefix, words } = decode(str2, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hex2 = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s3) => {
  if (typeof s3 !== "string" || s3.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s3} with length ${s3.length}`);
  return s3.toLowerCase();
}));

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/base32/helpers.js
init_shim();
function createDecode({ coder, ipfs }, validate) {
  return (value, ipfsCompat) => {
    validate(value, ipfsCompat);
    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);
  };
}
function createEncode({ coder, ipfs }) {
  return (value, ipfsCompat) => {
    const out = coder.encode(u8aToU8a(value));
    return ipfs && ipfsCompat ? `${ipfs}${out}` : out;
  };
}
function createIs(validate) {
  return (value, ipfsCompat) => {
    try {
      return validate(value, ipfsCompat);
    } catch {
      return false;
    }
  };
}
function createValidate({ chars: chars2, ipfs, type, withPadding }) {
  return (value, ipfsCompat) => {
    if (typeof value !== "string") {
      throw new Error(`Expected ${type} string input`);
    } else if (ipfs && ipfsCompat && !value.startsWith(ipfs)) {
      throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);
    }
    for (let i3 = ipfsCompat ? 1 : 0, count = value.length; i3 < count; i3++) {
      if (chars2.includes(value[i3])) {
      } else if (withPadding && value[i3] === "=") {
        if (i3 === count - 1) {
        } else if (value[i3 + 1] === "=") {
        } else {
          throw new Error(`Invalid ${type} padding sequence "${value[i3]}${value[i3 + 1]}" at index ${i3}`);
        }
      } else {
        throw new Error(`Invalid ${type} character "${value[i3]}" (0x${value.charCodeAt(i3).toString(16)}) at index ${i3}`);
      }
    }
    return true;
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/base58/bs58.js
var config = {
  chars: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  coder: base58,
  ipfs: "z",
  type: "base58"
};
var base58Validate = createValidate(config);
var base58Decode = createDecode(config, base58Validate);
var base58Encode = createEncode(config);
var isBase58 = createIs(base58Validate);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/checksum.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/sshash.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/blake2/asU8a.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/blake2b.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/_blake2.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/_assert.js
init_shim();
function number(n3) {
  if (!Number.isSafeInteger(n3) || n3 < 0)
    throw new Error(`Wrong positive integer: ${n3}`);
}
function bytes(b3, ...lengths) {
  if (!(b3 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b3.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b3.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/utils.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/crypto.js
init_shim();
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/utils.js
var u8a = (a3) => a3 instanceof Uint8Array;
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (_2, i3) => i3.toString(16).padStart(2, "0"));
function utf8ToBytes(str2) {
  if (typeof str2 !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str2}`);
  return new Uint8Array(new TextEncoder().encode(str2));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!u8a(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  const r3 = new Uint8Array(arrays.reduce((sum, a3) => sum + a3.length, 0));
  let pad = 0;
  arrays.forEach((a3) => {
    if (!u8a(a3))
      throw new Error("Uint8Array expected");
    r3.set(a3, pad);
    pad += a3.length;
  });
  return r3;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/_blake2.js
var SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
]);
var BLAKE2 = class extends Hash {
  constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.length = 0;
    this.pos = 0;
    this.finished = false;
    this.destroyed = false;
    number(blockLen);
    number(outputLen);
    number(keyLen);
    if (outputLen < 0 || outputLen > keyLen)
      throw new Error("outputLen bigger than keyLen");
    if (opts.key !== void 0 && (opts.key.length < 1 || opts.key.length > keyLen))
      throw new Error(`key must be up 1..${keyLen} byte long or undefined`);
    if (opts.salt !== void 0 && opts.salt.length !== saltLen)
      throw new Error(`salt must be ${saltLen} byte long or undefined`);
    if (opts.personalization !== void 0 && opts.personalization.length !== persLen)
      throw new Error(`personalization must be ${persLen} byte long or undefined`);
    this.buffer32 = u32(this.buffer = new Uint8Array(blockLen));
  }
  update(data) {
    exists(this);
    const { blockLen, buffer, buffer32 } = this;
    data = toBytes(data);
    const len = data.length;
    const offset = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        this.compress(buffer32, 0, false);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    this.buffer.subarray(pos).fill(0);
    this.compress(buffer32, 0, true);
    const out32 = u32(out);
    this.get().forEach((v3, i3) => out32[i3] = v3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to || (to = new this.constructor({ dkLen: outputLen }));
    to.set(...this.get());
    to.length = length;
    to.finished = finished;
    to.destroyed = destroyed;
    to.outputLen = outputLen;
    to.buffer.set(buffer);
    to.pos = pos;
    return to;
  }
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/_u64.js
init_shim();
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n3, le2 = false) {
  if (le2)
    return { h: Number(n3 & U32_MASK64), l: Number(n3 >> _32n & U32_MASK64) };
  return { h: Number(n3 >> _32n & U32_MASK64) | 0, l: Number(n3 & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i3 = 0; i3 < lst.length; i3++) {
    const { h: h2, l: l4 } = fromBig(lst[i3], le2);
    [Ah[i3], Al[i3]] = [h2, l4];
  }
  return [Ah, Al];
}
var toBig = (h2, l4) => BigInt(h2 >>> 0) << _32n | BigInt(l4 >>> 0);
var shrSH = (h2, _l, s3) => h2 >>> s3;
var shrSL = (h2, l4, s3) => h2 << 32 - s3 | l4 >>> s3;
var rotrSH = (h2, l4, s3) => h2 >>> s3 | l4 << 32 - s3;
var rotrSL = (h2, l4, s3) => h2 << 32 - s3 | l4 >>> s3;
var rotrBH = (h2, l4, s3) => h2 << 64 - s3 | l4 >>> s3 - 32;
var rotrBL = (h2, l4, s3) => h2 >>> s3 - 32 | l4 << 64 - s3;
var rotr32H = (_h, l4) => l4;
var rotr32L = (h2, _l) => h2;
var rotlSH = (h2, l4, s3) => h2 << s3 | l4 >>> 32 - s3;
var rotlSL = (h2, l4, s3) => l4 << s3 | h2 >>> 32 - s3;
var rotlBH = (h2, l4, s3) => l4 << s3 - 32 | h2 >>> 64 - s3;
var rotlBL = (h2, l4, s3) => h2 << s3 - 32 | l4 >>> 64 - s3;
function add(Ah, Al, Bh, Bl) {
  const l4 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l4 / 2 ** 32 | 0) | 0, l: l4 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/blake2b.js
var IV = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BUF = new Uint32Array(32);
function G1(a3, b3, c3, d3, msg, x3) {
  const Xl = msg[x3], Xh = msg[x3 + 1];
  let Al = BUF[2 * a3], Ah = BUF[2 * a3 + 1];
  let Bl = BUF[2 * b3], Bh = BUF[2 * b3 + 1];
  let Cl = BUF[2 * c3], Ch = BUF[2 * c3 + 1];
  let Dl = BUF[2 * d3], Dh = BUF[2 * d3 + 1];
  let ll = u64_default.add3L(Al, Bl, Xl);
  Ah = u64_default.add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: u64_default.rotr32H(Dh, Dl), Dl: u64_default.rotr32L(Dh, Dl) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrSH(Bh, Bl, 24), Bl: u64_default.rotrSL(Bh, Bl, 24) });
  BUF[2 * a3] = Al, BUF[2 * a3 + 1] = Ah;
  BUF[2 * b3] = Bl, BUF[2 * b3 + 1] = Bh;
  BUF[2 * c3] = Cl, BUF[2 * c3 + 1] = Ch;
  BUF[2 * d3] = Dl, BUF[2 * d3 + 1] = Dh;
}
function G2(a3, b3, c3, d3, msg, x3) {
  const Xl = msg[x3], Xh = msg[x3 + 1];
  let Al = BUF[2 * a3], Ah = BUF[2 * a3 + 1];
  let Bl = BUF[2 * b3], Bh = BUF[2 * b3 + 1];
  let Cl = BUF[2 * c3], Ch = BUF[2 * c3 + 1];
  let Dl = BUF[2 * d3], Dh = BUF[2 * d3 + 1];
  let ll = u64_default.add3L(Al, Bl, Xl);
  Ah = u64_default.add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: u64_default.rotrSH(Dh, Dl, 16), Dl: u64_default.rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrBH(Bh, Bl, 63), Bl: u64_default.rotrBL(Bh, Bl, 63) });
  BUF[2 * a3] = Al, BUF[2 * a3 + 1] = Ah;
  BUF[2 * b3] = Bl, BUF[2 * b3 + 1] = Bh;
  BUF[2 * c3] = Cl, BUF[2 * c3 + 1] = Ch;
  BUF[2 * d3] = Dl, BUF[2 * d3 + 1] = Dh;
}
var BLAKE2b = class extends BLAKE2 {
  constructor(opts = {}) {
    super(128, opts.dkLen === void 0 ? 64 : opts.dkLen, opts, 64, 16, 16);
    this.v0l = IV[0] | 0;
    this.v0h = IV[1] | 0;
    this.v1l = IV[2] | 0;
    this.v1h = IV[3] | 0;
    this.v2l = IV[4] | 0;
    this.v2h = IV[5] | 0;
    this.v3l = IV[6] | 0;
    this.v3h = IV[7] | 0;
    this.v4l = IV[8] | 0;
    this.v4h = IV[9] | 0;
    this.v5l = IV[10] | 0;
    this.v5h = IV[11] | 0;
    this.v6l = IV[12] | 0;
    this.v6h = IV[13] | 0;
    this.v7l = IV[14] | 0;
    this.v7h = IV[15] | 0;
    const keyLength = opts.key ? opts.key.length : 0;
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (opts.salt) {
      const salt = u32(toBytes(opts.salt));
      this.v4l ^= salt[0];
      this.v4h ^= salt[1];
      this.v5l ^= salt[2];
      this.v5h ^= salt[3];
    }
    if (opts.personalization) {
      const pers = u32(toBytes(opts.personalization));
      this.v6l ^= pers[0];
      this.v6h ^= pers[1];
      this.v7l ^= pers[2];
      this.v7h ^= pers[3];
    }
    if (opts.key) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(toBytes(opts.key));
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v3, i3) => BUF[i3] = v3);
    BUF.set(IV, 16);
    let { h: h2, l: l4 } = u64_default.fromBig(BigInt(this.length));
    BUF[24] = IV[8] ^ l4;
    BUF[25] = IV[9] ^ h2;
    if (isLast) {
      BUF[28] = ~BUF[28];
      BUF[29] = ~BUF[29];
    }
    let j4 = 0;
    const s3 = SIGMA;
    for (let i3 = 0; i3 < 12; i3++) {
      G1(0, 4, 8, 12, msg, offset + 2 * s3[j4++]);
      G2(0, 4, 8, 12, msg, offset + 2 * s3[j4++]);
      G1(1, 5, 9, 13, msg, offset + 2 * s3[j4++]);
      G2(1, 5, 9, 13, msg, offset + 2 * s3[j4++]);
      G1(2, 6, 10, 14, msg, offset + 2 * s3[j4++]);
      G2(2, 6, 10, 14, msg, offset + 2 * s3[j4++]);
      G1(3, 7, 11, 15, msg, offset + 2 * s3[j4++]);
      G2(3, 7, 11, 15, msg, offset + 2 * s3[j4++]);
      G1(0, 5, 10, 15, msg, offset + 2 * s3[j4++]);
      G2(0, 5, 10, 15, msg, offset + 2 * s3[j4++]);
      G1(1, 6, 11, 12, msg, offset + 2 * s3[j4++]);
      G2(1, 6, 11, 12, msg, offset + 2 * s3[j4++]);
      G1(2, 7, 8, 13, msg, offset + 2 * s3[j4++]);
      G2(2, 7, 8, 13, msg, offset + 2 * s3[j4++]);
      G1(3, 4, 9, 14, msg, offset + 2 * s3[j4++]);
      G2(3, 4, 9, 14, msg, offset + 2 * s3[j4++]);
    }
    this.v0l ^= BUF[0] ^ BUF[16];
    this.v0h ^= BUF[1] ^ BUF[17];
    this.v1l ^= BUF[2] ^ BUF[18];
    this.v1h ^= BUF[3] ^ BUF[19];
    this.v2l ^= BUF[4] ^ BUF[20];
    this.v2h ^= BUF[5] ^ BUF[21];
    this.v3l ^= BUF[6] ^ BUF[22];
    this.v3h ^= BUF[7] ^ BUF[23];
    this.v4l ^= BUF[8] ^ BUF[24];
    this.v4h ^= BUF[9] ^ BUF[25];
    this.v5l ^= BUF[10] ^ BUF[26];
    this.v5h ^= BUF[11] ^ BUF[27];
    this.v6l ^= BUF[12] ^ BUF[28];
    this.v6h ^= BUF[13] ^ BUF[29];
    this.v7l ^= BUF[14] ^ BUF[30];
    this.v7h ^= BUF[15] ^ BUF[31];
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer32.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b2 = wrapConstructorWithOpts((opts) => new BLAKE2b(opts));

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/helpers.js
init_shim();
function createAsHex(fn) {
  return (...args) => u8aToHex(fn(...args));
}
function createBitHasher(bitLength, fn) {
  return (data, onlyJs) => fn(data, bitLength, onlyJs);
}
function createDualHasher(wa, js) {
  return (value, bitLength = 256, onlyJs) => {
    const u8a3 = u8aToU8a(value);
    return !hasBigInt || !onlyJs && isReady() ? wa[bitLength](u8a3) : js[bitLength](u8a3);
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/blake2/asU8a.js
function blake2AsU8a(data, bitLength = 256, key, onlyJs) {
  const byteLength = Math.ceil(bitLength / 8);
  const u8a3 = u8aToU8a(data);
  return !hasBigInt || !onlyJs && isReady() ? blake2b(u8a3, u8aToU8a(key), byteLength) : key ? blake2b2(u8a3, { dkLen: byteLength, key }) : blake2b2(u8a3, { dkLen: byteLength });
}
var blake2AsHex = createAsHex(blake2AsU8a);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/sshash.js
var SS58_PREFIX = stringToU8a("SS58PRE");
function sshash(key) {
  return blake2AsU8a(u8aConcat(SS58_PREFIX, key), 512);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/checksum.js
function checkAddressChecksum(decoded) {
  const ss58Length = decoded[0] & 64 ? 2 : 1;
  const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 63) << 2 | decoded[1] >> 6 | (decoded[1] & 63) << 8;
  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);
  const length = decoded.length - (isPublicKey ? 2 : 1);
  const hash2 = sshash(decoded.subarray(0, length));
  const isValid = (decoded[0] & 128) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash2[0] && decoded[decoded.length - 1] === hash2[1] : decoded[decoded.length - 1] === hash2[0]);
  return [isValid, length, ss58Length, ss58Decoded];
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/defaults.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/networks.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/networks/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/networks/interfaces.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/networks/defaults/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/networks/defaults/genesis.js
init_shim();
var knownGenesis = {
  acala: [
    "0xfc41b9bd8ef8fe53d58c7ea67c794c7ec9a73daf05e6d54b14ff6342c99ba64c"
  ],
  ajuna: [
    "0xe358eb1d11b31255a286c12e44fe6780b7edb171d657905a97e39f71d9c6c3ee"
  ],
  "aleph-node": [
    "0x70255b4d28de0fc4e1a193d7e175ad1ccef431598211c55538f1018651a0344e"
  ],
  astar: [
    "0x9eb76c5184c4ab8679d2d5d819fdf90b9c001403e9e17da2e14b6d8aec4029c6"
  ],
  basilisk: [
    "0xa85cfb9b9fd4d622a5b28289a02347af987d8f73fa3108450e2b4a11c1ce5755"
  ],
  bifrost: [
    "0x262e1b2ad728475fd6fe88e62d34c200abe6fd693931ddad144059b1eb884e5b"
  ],
  "bifrost-kusama": [
    "0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed"
  ],
  bittensor: [
    "0x2f0555cc76fc2840a25a6ea3b9637146806f1f44b090c175ffde2a7e5ab36c03"
  ],
  centrifuge: [
    "0xb3db41421702df9a7fcac62b53ffeac85f7853cc4e689e0b93aeb3db18c09d82",
    "0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5"
  ],
  cere: [
    "0x81443836a9a24caaa23f1241897d1235717535711d1d3fe24eae4fdc942c092c"
  ],
  composable: [
    "0xdaab8df776eb52ec604a5df5d388bb62a050a0aaec4556a64265b9d42755552d"
  ],
  darwinia: [
    "0xe71578b37a7c799b0ab4ee87ffa6f059a6b98f71f06fb8c84a8d88013a548ad6"
  ],
  "dock-mainnet": [
    "0x6bfe24dca2a3be10f22212678ac13a6446ec764103c0f3471c71609eac384aae",
    "0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9"
  ],
  edgeware: [
    "0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b"
  ],
  enjin: [
    "0xd8761d3c88f26dc12875c00d3165f7d67243d56fc85b4cf19937601a7916e5a9"
  ],
  equilibrium: [
    "0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925"
  ],
  genshiro: [
    "0x9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243"
  ],
  hydradx: [
    "0xafdc188f45c71dacbaa0b62e16a91f726c7b8699a9748cdf715459de6b7f366d",
    "0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc",
    "0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9",
    "0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047",
    "0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2"
    // Snakenet Gen1
  ],
  "interlay-parachain": [
    "0xbf88efe70e9e0e916416e8bed61f2b45717f517d7f3523e33c7b001e5ffcbc72"
  ],
  karura: [
    "0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b"
  ],
  khala: [
    "0xd43540ba6d3eb4897c28a77d48cb5b729fea37603cbbfc7a86a73b72adb3be8d"
  ],
  kulupu: [
    "0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba"
  ],
  kusama: [
    "0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe",
    "0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636",
    "0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf"
    // Kusama CC1
  ],
  matrixchain: [
    "0x3af4ff48ec76d2efc8476730f423ac07e25ad48f5f4c9dc39c778b164d808615"
  ],
  nodle: [
    "0x97da7ede98d7bad4e36b4d734b6055425a3be036da2a332ea5a7037656427a21"
  ],
  origintrail: [
    "0xe7e0962324a3b86c83404dbea483f25fb5dab4c224791c81b756cfc948006174"
  ],
  p3d: [
    "0x6c5894837ad89b6d92b114a2fb3eafa8fe3d26a54848e3447015442cd6ef4e66"
  ],
  parallel: [
    "0xe61a41c53f5dcd0beb09df93b34402aada44cb05117b71059cce40a2723a4e97"
  ],
  pendulum: [
    "0x5d3c298622d5634ed019bf61ea4b71655030015bde9beb0d6a24743714462c86"
  ],
  phala: [
    "0x1bb969d85965e4bb5a651abbedf21a54b6b31a21f66b5401cc3f1e286268d736"
  ],
  picasso: [
    "0x6811a339673c9daa897944dcdac99c6e2939cc88245ed21951a0a3c9a2be75bc",
    "0xe8e7f0f4c4f5a00720b4821dbfddefea7490bcf0b19009961cc46957984e2c1c"
  ],
  polkadex: [
    "0x3920bcb4960a1eef5580cd5367ff3f430eef052774f78468852f7b9cb39f8a3c"
  ],
  polkadot: [
    "0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3"
  ],
  polymesh: [
    "0x6fbd74e5e1d0a61d52ccfe9d4adaed16dd3a7caa37c6bc4d0c2fa12e8b2f4063"
  ],
  quartz: [
    "0xcd4d732201ebe5d6b014edda071c4203e16867305332301dc8d092044b28e554"
  ],
  rococo: [
    "0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e",
    "0xaaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897",
    "0x037f5f3c8e67b314062025fc886fcd6238ea25a4a9b45dce8d246815c9ebe770",
    "0xc196f81260cf1686172b47a79cf002120735d7cb0eb1474e8adce56618456fff",
    "0xf6e9983c37baf68846fedafe21e56718790e39fb1c582abc408b81bc7b208f9a",
    "0x5fce687da39305dfe682b117f0820b319348e8bb37eb16cf34acbf6a202de9d9",
    "0xe7c3d5edde7db964317cd9b51a3a059d7cd99f81bdbce14990047354334c9779",
    "0x1611e1dbf0405379b861e2e27daa90f480b2e6d3682414a80835a52e8cb8a215",
    "0x343442f12fa715489a8714e79a7b264ea88c0d5b8c66b684a7788a516032f6b9",
    "0x78bcd530c6b3a068bc17473cf5d2aff9c287102bed9af3ae3c41c33b9d6c6147",
    "0x47381ee0697153d64404fc578392c8fd5cba9073391908f46c888498415647bd",
    "0x19c0e4fa8ab75f5ac7865e0b8f74ff91eb9a100d336f423cd013a8befba40299"
  ],
  sora: [
    "0x7e4e32d0feafd4f9c9414b0be86373f9a1efa904809b683453a9af6856d38ad5"
  ],
  stafi: [
    "0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80"
  ],
  statemine: [
    "0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a"
  ],
  statemint: [
    "0x68d56f15f85d3136970ec16946040bc1752654e906147f7e43e9d539d7c3de2f"
  ],
  subsocial: [
    "0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8"
  ],
  ternoa: [
    "0x6859c81ca95ef624c9dfe4dc6e3381c33e5d6509e35e147092bfbc780f777c4e"
  ],
  unique: [
    "0x84322d9cddbf35088f1e54e9a85c967a41a56a4f43445768125e61af166c7d31"
  ],
  vtb: [
    "0x286bc8414c7000ce1d6ee6a834e29a54c1784814b76243eb77ed0b2c5573c60f",
    "0x7483b89572fb2bd687c7b9a93b242d0b237f9aba463aba07ec24503931038aaa"
  ],
  westend: [
    "0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"
  ],
  xxnetwork: [
    "0x50dd5d206917bf10502c68fb4d18a59fc8aa31586f4e8856b493e43544aa82aa"
  ],
  zeitgeist: [
    "0x1bf2a2ecb4a868de66ea8610f2ce7c8c43706561b6476031315f6640fe38e060"
  ]
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/networks/defaults/icons.js
init_shim();
var knownIcon = {
  centrifuge: "polkadot",
  kusama: "polkadot",
  polkadot: "polkadot",
  sora: "polkadot",
  statemine: "polkadot",
  statemint: "polkadot",
  westmint: "polkadot"
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/networks/defaults/ledger.js
init_shim();
var knownLedger = {
  acala: 787,
  ajuna: 354,
  "aleph-node": 643,
  astar: 810,
  bifrost: 788,
  "bifrost-kusama": 788,
  centrifuge: 747,
  composable: 354,
  darwinia: 354,
  "dock-mainnet": 594,
  edgeware: 523,
  enjin: 1155,
  equilibrium: 99999997,
  genshiro: 99999996,
  hydradx: 354,
  "interlay-parachain": 354,
  karura: 686,
  khala: 434,
  kusama: 434,
  matrixchain: 1155,
  nodle: 1003,
  origintrail: 354,
  parallel: 354,
  pendulum: 354,
  phala: 354,
  picasso: 434,
  polkadex: 799,
  polkadot: 354,
  polymesh: 595,
  quartz: 631,
  sora: 617,
  stafi: 907,
  statemine: 434,
  statemint: 354,
  ternoa: 995,
  unique: 661,
  vtb: 694,
  xxnetwork: 1955,
  zeitgeist: 354
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/networks/defaults/testnets.js
init_shim();
var knownTestnet = {
  "": true,
  "cess-testnet": true,
  "dock-testnet": true,
  jupiter: true,
  "mathchain-testnet": true,
  p3dt: true,
  subspace_testnet: true,
  "zero-alphaville": true
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@polkadot/networks/interfaces.js
var UNSORTED = [0, 2, 42];
var TESTNETS = ["testnet"];
function toExpanded(o3) {
  var _a, _b;
  const network = o3.network || "";
  const nameParts = network.replace(/_/g, "-").split("-");
  const n3 = o3;
  n3.slip44 = knownLedger[network];
  n3.hasLedgerSupport = !!n3.slip44;
  n3.genesisHash = knownGenesis[network] || [];
  n3.icon = knownIcon[network] || "substrate";
  n3.isTestnet = !!knownTestnet[network] || TESTNETS.includes(nameParts[nameParts.length - 1]);
  n3.isIgnored = n3.isTestnet || !(o3.standardAccount && ((_a = o3.decimals) == null ? void 0 : _a.length) && ((_b = o3.symbols) == null ? void 0 : _b.length)) && o3.prefix !== 42;
  return n3;
}
function filterSelectable({ genesisHash, prefix }) {
  return !!genesisHash.length || prefix === 42;
}
function filterAvailable(n3) {
  return !n3.isIgnored && !!n3.network;
}
function sortNetworks(a3, b3) {
  const isUnSortedA = UNSORTED.includes(a3.prefix);
  const isUnSortedB = UNSORTED.includes(b3.prefix);
  return isUnSortedA === isUnSortedB ? isUnSortedA ? 0 : a3.displayName.localeCompare(b3.displayName) : isUnSortedA ? -1 : 1;
}
var allNetworks = esm_default.map(toExpanded);
var availableNetworks = allNetworks.filter(filterAvailable).sort(sortNetworks);
var selectableNetworks = availableNetworks.filter(filterSelectable);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/defaults.js
var defaults = {
  allowedDecodedLengths: [1, 2, 4, 8, 32, 33],
  // publicKey has prefix + 2 checksum bytes, short only prefix + 1 checksum byte
  allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],
  allowedPrefix: availableNetworks.map(({ prefix }) => prefix),
  prefix: 42
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/decode.js
function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
  if (!encoded) {
    throw new Error("Invalid empty address passed");
  }
  if (isU8a(encoded) || isHex(encoded)) {
    return u8aToU8a(encoded);
  }
  try {
    const decoded = base58Decode(encoded);
    if (!defaults.allowedEncodedLengths.includes(decoded.length)) {
      throw new Error("Invalid decoded address length");
    }
    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);
    if (!isValid && !ignoreChecksum) {
      throw new Error("Invalid decoded address checksum");
    } else if (ss58Format !== -1 && ss58Format !== ss58Decoded) {
      throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
    }
    return decoded.slice(ss58Length, endPos);
  } catch (error) {
    throw new Error(`Decoding ${encoded}: ${error.message}`);
  }
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/check.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/derive.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/key/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/key/extractPath.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/key/DeriveJunction.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/bn.js
init_shim();
var BN_BE_256_OPTS = { bitLength: 256, isLe: false };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/key/extractSuri.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/key/fromPath.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/key/hdkdEcdsa.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/deriveHard.js
init_shim();
var HDKD = compactAddLength(stringToU8a("Secp256k1HDKD"));
function secp256k1DeriveHard(seed, chainCode) {
  if (!isU8a(chainCode) || chainCode.length !== 32) {
    throw new Error("Invalid chainCode passed to derive");
  }
  return blake2AsU8a(u8aConcat(HDKD, seed, chainCode), 256);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/pair/fromSeed.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/secp256k1.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/sha256.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/_sha2.js
init_shim();
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l4 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE2);
  view.setUint32(byteOffset + l4, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i3 = pos; i3 < blockLen; i3++)
      buffer[i3] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i3 = 0; i3 < outLen; i3++)
      oview.setUint32(4 * i3, state[i3], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/sha256.js
var Chi = (a3, b3, c3) => a3 & b3 ^ ~a3 & c3;
var Maj = (a3, b3, c3) => a3 & b3 ^ a3 & c3 ^ b3 & c3;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV2[0] | 0;
    this.B = IV2[1] | 0;
    this.C = IV2[2] | 0;
    this.D = IV2[3] | 0;
    this.E = IV2[4] | 0;
    this.F = IV2[5] | 0;
    this.G = IV2[6] | 0;
    this.H = IV2[7] | 0;
  }
  get() {
    const { A, B: B2, C: C3, D: D2, E: E2, F: F2, G: G3, H: H3 } = this;
    return [A, B2, C3, D2, E2, F2, G3, H3];
  }
  // prettier-ignore
  set(A, B2, C3, D2, E2, F2, G3, H3) {
    this.A = A | 0;
    this.B = B2 | 0;
    this.C = C3 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G3 | 0;
    this.H = H3 | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4)
      SHA256_W[i3] = view.getUint32(offset, false);
    for (let i3 = 16; i3 < 64; i3++) {
      const W15 = SHA256_W[i3 - 15];
      const W2 = SHA256_W[i3 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i3] = s1 + SHA256_W[i3 - 7] + s0 + SHA256_W[i3 - 16] | 0;
    }
    let { A, B: B2, C: C3, D: D2, E: E2, F: F2, G: G3, H: H3 } = this;
    for (let i3 = 0; i3 < 64; i3++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H3 + sigma1 + Chi(E2, F2, G3) + SHA256_K[i3] + SHA256_W[i3] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B2, C3) | 0;
      H3 = G3;
      G3 = F2;
      F2 = E2;
      E2 = D2 + T1 | 0;
      D2 = C3;
      C3 = B2;
      B2 = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B2 = B2 + this.B | 0;
    C3 = C3 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G3 = G3 + this.G | 0;
    H3 = H3 + this.H | 0;
    this.set(A, B2, C3, D2, E2, F2, G3, H3);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha2562 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/abstract/modular.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber2,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
init_shim();
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var u8a2 = (a3) => a3 instanceof Uint8Array;
var hexes2 = Array.from({ length: 256 }, (_2, i3) => i3.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  if (!u8a2(bytes2))
    throw new Error("Uint8Array expected");
  let hex3 = "";
  for (let i3 = 0; i3 < bytes2.length; i3++) {
    hex3 += hexes2[bytes2[i3]];
  }
  return hex3;
}
function numberToHexUnpadded(num) {
  const hex3 = num.toString(16);
  return hex3.length & 1 ? `0${hex3}` : hex3;
}
function hexToNumber2(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  return BigInt(hex3 === "" ? "0" : `0x${hex3}`);
}
function hexToBytes(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  const len = hex3.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i3 = 0; i3 < array.length; i3++) {
    const j4 = i3 * 2;
    const hexByte = hex3.slice(j4, j4 + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i3] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber2(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a2(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber2(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n3, len) {
  return hexToBytes(n3.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n3, len) {
  return numberToBytesBE(n3, len).reverse();
}
function numberToVarBytesBE(n3) {
  return hexToBytes(numberToHexUnpadded(n3));
}
function ensureBytes(title, hex3, expectedLength) {
  let res;
  if (typeof hex3 === "string") {
    try {
      res = hexToBytes(hex3);
    } catch (e3) {
      throw new Error(`${title} must be valid hex string, got "${hex3}". Cause: ${e3}`);
    }
  } else if (u8a2(hex3)) {
    res = Uint8Array.from(hex3);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  const r3 = new Uint8Array(arrays.reduce((sum, a3) => sum + a3.length, 0));
  let pad = 0;
  arrays.forEach((a3) => {
    if (!u8a2(a3))
      throw new Error("Uint8Array expected");
    r3.set(a3, pad);
    pad += a3.length;
  });
  return r3;
}
function equalBytes(b1, b22) {
  if (b1.length !== b22.length)
    return false;
  for (let i3 = 0; i3 < b1.length; i3++)
    if (b1[i3] !== b22[i3])
      return false;
  return true;
}
function utf8ToBytes2(str2) {
  if (typeof str2 !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str2}`);
  return new Uint8Array(new TextEncoder().encode(str2));
}
function bitLen(n3) {
  let len;
  for (len = 0; n3 > _0n2; n3 >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n3, pos) {
  return n3 >> BigInt(pos) & _1n2;
}
var bitSet = (n3, pos, value) => {
  return n3 | (value ? _1n2 : _0n2) << BigInt(pos);
};
var bitMask = (n3) => (_2n2 << BigInt(n3 - 1)) - _1n2;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v3 = u8n(hashLen);
  let k2 = u8n(hashLen);
  let i3 = 0;
  const reset = () => {
    v3.fill(1);
    k2.fill(0);
    i3 = 0;
  };
  const h2 = (...b3) => hmacFn(k2, v3, ...b3);
  const reseed = (seed = u8n()) => {
    k2 = h2(u8fr([0]), seed);
    v3 = h2();
    if (seed.length === 0)
      return;
    k2 = h2(u8fr([1]), seed);
    v3 = h2();
  };
  const gen2 = () => {
    if (i3++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v3 = h2();
      const sl = v3.slice();
      out.push(sl);
      len += v3.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/abstract/modular.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
var _5n2 = BigInt(5);
var _8n2 = BigInt(8);
var _9n2 = BigInt(9);
var _16n = BigInt(16);
function mod(a3, b3) {
  const result = a3 % b3;
  return result >= _0n3 ? result : b3 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x3, power, modulo) {
  let res = x3;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a3 = mod(number2, modulo);
  let b3 = modulo;
  let x3 = _0n3, y3 = _1n3, u3 = _1n3, v3 = _0n3;
  while (a3 !== _0n3) {
    const q2 = b3 / a3;
    const r3 = b3 % a3;
    const m3 = x3 - u3 * q2;
    const n3 = y3 - v3 * q2;
    b3 = a3, a3 = r3, x3 = u3, y3 = v3, u3 = m3, v3 = n3;
  }
  const gcd2 = b3;
  if (gcd2 !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x3, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q2, S3, Z3;
  for (Q2 = P - _1n3, S3 = 0; Q2 % _2n3 === _0n3; Q2 /= _2n3, S3++)
    ;
  for (Z3 = _2n3; Z3 < P && pow(Z3, legendreC, P) !== P - _1n3; Z3++)
    ;
  if (S3 === 1) {
    const p1div4 = (P + _1n3) / _4n2;
    return function tonelliFast(Fp3, n3) {
      const root = Fp3.pow(n3, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q2 + _1n3) / _2n3;
  return function tonelliSlow(Fp3, n3) {
    if (Fp3.pow(n3, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r3 = S3;
    let g3 = Fp3.pow(Fp3.mul(Fp3.ONE, Z3), Q2);
    let x3 = Fp3.pow(n3, Q1div2);
    let b3 = Fp3.pow(n3, Q2);
    while (!Fp3.eql(b3, Fp3.ONE)) {
      if (Fp3.eql(b3, Fp3.ZERO))
        return Fp3.ZERO;
      let m3 = 1;
      for (let t22 = Fp3.sqr(b3); m3 < r3; m3++) {
        if (Fp3.eql(t22, Fp3.ONE))
          break;
        t22 = Fp3.sqr(t22);
      }
      const ge3 = Fp3.pow(g3, _1n3 << BigInt(r3 - m3 - 1));
      g3 = Fp3.sqr(ge3);
      x3 = Fp3.mul(x3, ge3);
      b3 = Fp3.mul(b3, g3);
      r3 = m3;
    }
    return x3;
  };
}
function FpSqrt(P) {
  if (P % _4n2 === _3n2) {
    const p1div4 = (P + _1n3) / _4n2;
    return function sqrt3mod4(Fp3, n3) {
      const root = Fp3.pow(n3, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n2 === _5n2) {
    const c1 = (P - _5n2) / _8n2;
    return function sqrt5mod8(Fp3, n3) {
      const n22 = Fp3.mul(n3, _2n3);
      const v3 = Fp3.pow(n22, c1);
      const nv = Fp3.mul(n3, v3);
      const i3 = Fp3.mul(Fp3.mul(nv, _2n3), v3);
      const root = Fp3.mul(nv, Fp3.sub(i3, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n2) {
  }
  return tonelliShanks(P);
}
var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n3) === _1n3;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f3, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f3.ONE;
  if (power === _1n3)
    return num;
  let p2 = f3.ONE;
  let d3 = num;
  while (power > _0n3) {
    if (power & _1n3)
      p2 = f3.mul(p2, d3);
    d3 = f3.sqr(d3);
    power >>= _1n3;
  }
  return p2;
}
function FpInvertBatch(f3, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i3) => {
    if (f3.is0(num))
      return acc;
    tmp[i3] = acc;
    return f3.mul(acc, num);
  }, f3.ONE);
  const inverted = f3.inv(lastMultiplied);
  nums.reduceRight((acc, num, i3) => {
    if (f3.is0(num))
      return acc;
    tmp[i3] = f3.mul(acc, tmp[i3]);
    return f3.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n3, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n3.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f3 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f3, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n3) => sqrtP(f3, n3)),
    invertBatch: (lst) => FpInvertBatch(f3, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a3, b3, c3) => c3 ? b3 : a3,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f3);
}
function FpSqrtEven(Fp3, elm) {
  if (!Fp3.isOdd)
    throw new Error(`Field doesn't have isOdd`);
  const root = Fp3.sqrt(elm);
  return Fp3.isOdd(root) ? Fp3.neg(root) : root;
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/abstract/weierstrass.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/abstract/curve.js
init_shim();
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
function wNAF(c3, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W2) => {
    const windows = Math.ceil(bits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n3) {
      let p2 = c3.ZERO;
      let d3 = elm;
      while (n3 > _0n4) {
        if (n3 & _1n4)
          p2 = p2.add(d3);
        d3 = d3.double();
        n3 >>= _1n4;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = opts(W2);
      const points = [];
      let p2 = elm;
      let base = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p2;
        points.push(base);
        for (let i3 = 1; i3 < windowSize; i3++) {
          base = base.add(p2);
          points.push(base);
        }
        p2 = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n3) {
      const { windows, windowSize } = opts(W2);
      let p2 = c3.ZERO;
      let f3 = c3.BASE;
      const mask = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n3 & mask);
        n3 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n3 += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f3 = f3.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p2, f: f3 };
    },
    wNAFCached(P, precomputesMap, n3, transform) {
      const W2 = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W2);
        if (W2 !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W2, comp, n3);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a: a3 } = opts;
  if (endo) {
    if (!Fp3.eql(a3, Fp3.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m3 = "") {
      super(m3);
    }
  },
  _parseInt(data) {
    const { Err: E2 } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex3) {
    const { Err: E2 } = DER;
    const data = typeof hex3 === "string" ? h2b(hex3) : hex3;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l4 = data.length;
    if (l4 < 2 || data[0] != 48)
      throw new E2("Invalid signature tag");
    if (data[1] !== l4 - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r3, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s3, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r: r3, s: s3 };
  },
  hexFromSig(sig) {
    const slice = (s4) => Number.parseInt(s4[0], 16) & 8 ? "00" + s4 : s4;
    const h2 = (num) => {
      const hex3 = num.toString(16);
      return hex3.length & 1 ? `0${hex3}` : hex3;
    };
    const s3 = slice(h2(sig.s));
    const r3 = slice(h2(sig.r));
    const shl = s3.length / 2;
    const rhl = r3.length / 2;
    const sl = h2(shl);
    const rl = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl}${r3}02${sl}${s3}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n3 = BigInt(3);
var _4n3 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp3 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a3 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp3.toBytes(a3.x), Fp3.toBytes(a3.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x3 = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y3 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x: x3, y: y3 };
  });
  function weierstrassEquation(x3) {
    const { a: a3, b: b3 } = CURVE;
    const x22 = Fp3.sqr(x3);
    const x32 = Fp3.mul(x22, x3);
    return Fp3.add(Fp3.add(x32, Fp3.mul(x3, a3)), b3);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n3 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n3);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  class Point3 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp3.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x3, y: y3 } = p2 || {};
      if (!p2 || !Fp3.isValid(x3) || !Fp3.isValid(y3))
        throw new Error("invalid affine point");
      if (p2 instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i3) => Fp3.eql(i3, Fp3.ZERO);
      if (is0(x3) && is0(y3))
        return Point3.ZERO;
      return new Point3(x3, y3, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i3) => p2.toAffine(toInv[i3])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex3) {
      const P = Point3.fromAffine(fromBytes(ensureBytes("pointHex", hex3)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp3.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x3, y: y3 } = this.toAffine();
      if (!Fp3.isValid(x3) || !Fp3.isValid(y3))
        throw new Error("bad point: x or y not FE");
      const left = Fp3.sqr(y3);
      const right = weierstrassEquation(x3);
      if (!Fp3.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y3 } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y3);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z22 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z22), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z22), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a3, b: b3 } = CURVE;
      const b32 = Fp3.mul(b3, _3n3);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t22 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a3, Z3);
      Y3 = Fp3.mul(b32, t22);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b32, Z3);
      t22 = Fp3.mul(a3, t22);
      t3 = Fp3.sub(t0, t22);
      t3 = Fp3.mul(a3, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t22);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t22 = Fp3.mul(Y1, Z1);
      t22 = Fp3.add(t22, t22);
      t0 = Fp3.mul(t22, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t22, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point3(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z22 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a3 = CURVE.a;
      const b3 = Fp3.mul(CURVE.b, _3n3);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t22 = Fp3.mul(Z1, Z22);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z22);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t22);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z22);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t22);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a3, t4);
      X3 = Fp3.mul(b3, t22);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t22 = Fp3.mul(a3, t22);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t22);
      t22 = Fp3.sub(t0, t22);
      t22 = Fp3.mul(a3, t22);
      t4 = Fp3.add(t4, t22);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point3(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n3) {
      return wnaf.wNAFCached(this, pointPrecomputes, n3, (comp) => {
        const toInv = Fp3.invertBatch(comp.map((p2) => p2.pz));
        return comp.map((p2, i3) => p2.toAffine(toInv[i3])).map(Point3.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n3) {
      const I2 = Point3.ZERO;
      if (n3 === _0n5)
        return I2;
      assertGE(n3);
      if (n3 === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n3);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n3);
      let k1p = I2;
      let k2p = I2;
      let d3 = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d3);
        if (k2 & _1n5)
          k2p = k2p.add(d3);
        d3 = d3.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n3 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n3);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f3 } = this.wNAF(n3);
        point = p2;
        fake = f3;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a3, b3) {
      const G3 = Point3.BASE;
      const mul = (P, a4) => a4 === _0n5 || a4 === _1n5 || !P.equals(G3) ? P.multiplyUnsafe(a4) : P.multiply(a4);
      const sum = mul(this, a3).add(mul(Q2, b3));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x3, py: y3, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp3.ONE : Fp3.inv(z2);
      const ax = Fp3.mul(x3, iz);
      const ay = Fp3.mul(y3, iz);
      const zz = Fp3.mul(z2, iz);
      if (is0)
        return { x: Fp3.ZERO, y: Fp3.ZERO };
      if (!Fp3.eql(zz, Fp3.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point3.ZERO = new Point3(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp3.ORDER;
  }
  function modN2(a3) {
    return mod(a3, CURVE_ORDER);
  }
  function invN(a3) {
    return invert(a3, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a3 = point.toAffine();
      const x3 = Fp3.toBytes(a3.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x3);
      } else {
        return cat(Uint8Array.from([4]), x3, Fp3.toBytes(a3.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x3 = bytesToNumberBE(tail);
        if (!isValidFieldElement(x3))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x3);
        let y3 = Fp3.sqrt(y22);
        const isYOdd = (y3 & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp3.neg(y3);
        return { x: x3, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x3 = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y3 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x: x3, y: y3 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n5;
    return number2 > HALF;
  }
  function normalizeS(s3) {
    return isBiggerThanHalfOrder(s3) ? modN2(-s3) : s3;
  }
  const slcNum = (b3, from, to) => bytesToNumberBE(b3.slice(from, to));
  class Signature {
    constructor(r3, s3, recovery) {
      this.r = r3;
      this.s = s3;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex3) {
      const l4 = CURVE.nByteLength;
      hex3 = ensureBytes("compactSignature", hex3, l4 * 2);
      return new Signature(slcNum(hex3, 0, l4), slcNum(hex3, l4, 2 * l4));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex3) {
      const { r: r3, s: s3 } = DER.toSig(ensureBytes("DER", hex3));
      return new Signature(r3, s3);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r3, s: s3, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r3 + CURVE.n : r3;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point3.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h2 * ir);
      const u22 = modN2(s3 * ir);
      const Q2 = Point3.BASE.multiplyAndAddUnsafe(R2, u1, u22);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str2 = typeof item === "string";
    const len = (arr || str2) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str2)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b3 = Point3.fromHex(publicB);
    return b3.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN2(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d3 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d3), int2octets(h1int)];
    if (ent != null) {
      const e3 = ent === true ? randomBytes2(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e3));
    }
    const seed = concatBytes2(...seedArgs);
    const m3 = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik = invN(k2);
      const q2 = Point3.BASE.multiply(k2).toAffine();
      const r3 = modN2(q2.x);
      if (r3 === _0n5)
        return;
      const s3 = modN2(ik * modN2(m3 + r3 * d3));
      if (s3 === _0n5)
        return;
      let recovery = (q2.x === r3 ? 0 : 2) | Number(q2.y & _1n5);
      let normS = s3;
      if (lowS && isBiggerThanHalfOrder(s3)) {
        normS = normalizeS(s3);
        recovery ^= 1;
      }
      return new Signature(r3, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C3 = CURVE;
    const drbg = createHmacDrbg(C3.hash.outputLen, C3.nByteLength, C3.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r4, s: s4 } = sg;
        _sig = new Signature(r4, s4);
      } else {
        throw new Error("PARSE");
      }
      P = Point3.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r3, s: s3 } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is = invN(s3);
    const u1 = modN2(h2 * is);
    const u22 = modN2(r3 * is);
    const R2 = (_a = Point3.BASE.multiplyAndAddUnsafe(P, u1, u22)) == null ? void 0 : _a.toAffine();
    if (!R2)
      return false;
    const v3 = modN2(R2.x);
    return v3 === r3;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point3,
    Signature,
    utils: utils2
  };
}
function SWUFpSqrtRatio(Fp3, Z3) {
  const q2 = Fp3.ORDER;
  let l4 = _0n5;
  for (let o3 = q2 - _1n5; o3 % _2n4 === _0n5; o3 /= _2n4)
    l4 += _1n5;
  const c1 = l4;
  const _2n_pow_c1_1 = _2n4 << c1 - _1n5 - _1n5;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n4;
  const c22 = (q2 - _1n5) / _2n_pow_c1;
  const c3 = (c22 - _1n5) / _2n4;
  const c4 = _2n_pow_c1 - _1n5;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp3.pow(Z3, c22);
  const c7 = Fp3.pow(Z3, (c22 + _1n5) / _2n4);
  let sqrtRatio = (u3, v3) => {
    let tv1 = c6;
    let tv2 = Fp3.pow(v3, c4);
    let tv3 = Fp3.sqr(tv2);
    tv3 = Fp3.mul(tv3, v3);
    let tv5 = Fp3.mul(u3, tv3);
    tv5 = Fp3.pow(tv5, c3);
    tv5 = Fp3.mul(tv5, tv2);
    tv2 = Fp3.mul(tv5, v3);
    tv3 = Fp3.mul(tv5, u3);
    let tv4 = Fp3.mul(tv3, tv2);
    tv5 = Fp3.pow(tv4, c5);
    let isQR = Fp3.eql(tv5, Fp3.ONE);
    tv2 = Fp3.mul(tv3, c7);
    tv5 = Fp3.mul(tv4, tv1);
    tv3 = Fp3.cmov(tv2, tv3, isQR);
    tv4 = Fp3.cmov(tv5, tv4, isQR);
    for (let i3 = c1; i3 > _1n5; i3--) {
      let tv52 = i3 - _2n4;
      tv52 = _2n4 << tv52 - _1n5;
      let tvv5 = Fp3.pow(tv4, tv52);
      const e1 = Fp3.eql(tvv5, Fp3.ONE);
      tv2 = Fp3.mul(tv3, tv1);
      tv1 = Fp3.mul(tv1, tv1);
      tvv5 = Fp3.mul(tv4, tv1);
      tv3 = Fp3.cmov(tv2, tv3, e1);
      tv4 = Fp3.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp3.ORDER % _4n3 === _3n3) {
    const c12 = (Fp3.ORDER - _3n3) / _4n3;
    const c23 = Fp3.sqrt(Fp3.neg(Z3));
    sqrtRatio = (u3, v3) => {
      let tv1 = Fp3.sqr(v3);
      const tv2 = Fp3.mul(u3, v3);
      tv1 = Fp3.mul(tv1, tv2);
      let y1 = Fp3.pow(tv1, c12);
      y1 = Fp3.mul(y1, tv2);
      const y22 = Fp3.mul(y1, c23);
      const tv3 = Fp3.mul(Fp3.sqr(y1), v3);
      const isQR = Fp3.eql(tv3, u3);
      let y3 = Fp3.cmov(y22, y1, isQR);
      return { isValid: isQR, value: y3 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp3, opts) {
  validateField(Fp3);
  if (!Fp3.isValid(opts.A) || !Fp3.isValid(opts.B) || !Fp3.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp3, opts.Z);
  if (!Fp3.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u3) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x3, y3;
    tv1 = Fp3.sqr(u3);
    tv1 = Fp3.mul(tv1, opts.Z);
    tv2 = Fp3.sqr(tv1);
    tv2 = Fp3.add(tv2, tv1);
    tv3 = Fp3.add(tv2, Fp3.ONE);
    tv3 = Fp3.mul(tv3, opts.B);
    tv4 = Fp3.cmov(opts.Z, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
    tv4 = Fp3.mul(tv4, opts.A);
    tv2 = Fp3.sqr(tv3);
    tv6 = Fp3.sqr(tv4);
    tv5 = Fp3.mul(tv6, opts.A);
    tv2 = Fp3.add(tv2, tv5);
    tv2 = Fp3.mul(tv2, tv3);
    tv6 = Fp3.mul(tv6, tv4);
    tv5 = Fp3.mul(tv6, opts.B);
    tv2 = Fp3.add(tv2, tv5);
    x3 = Fp3.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y3 = Fp3.mul(tv1, u3);
    y3 = Fp3.mul(y3, value);
    x3 = Fp3.cmov(x3, tv3, isValid);
    y3 = Fp3.cmov(y3, value, isValid);
    const e1 = Fp3.isOdd(u3) === Fp3.isOdd(y3);
    y3 = Fp3.cmov(Fp3.neg(y3), y3, e1);
    x3 = Fp3.div(x3, tv4);
    return { x: x3, y: y3 };
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
init_shim();
function validateDST(dst) {
  if (dst instanceof Uint8Array)
    return dst;
  if (typeof dst === "string")
    return utf8ToBytes2(dst);
  throw new Error("DST must be Uint8Array or string");
}
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i3 = length - 1; i3 >= 0; i3--) {
    res[i3] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a3, b3) {
  const arr = new Uint8Array(a3.length);
  for (let i3 = 0; i3 < a3.length; i3++) {
    arr[i3] = a3[i3] ^ b3[i3];
  }
  return arr;
}
function isBytes(item) {
  if (!(item instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function isNum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H3) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255)
    DST = H3(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H3;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b3 = new Array(ell);
  const b_0 = H3(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b3[0] = H3(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i3 = 1; i3 <= ell; i3++) {
    const args = [strxor(b_0, b3[i3 - 1]), i2osp(i3 + 1, 1), DST_prime];
    b3[i3] = H3(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b3);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k2, H3) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k2 / 8);
    DST = H3.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H3.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: p2, k: k2, m: m3, hash: hash2, expand, DST: _DST } = options;
  isBytes(msg);
  isNum(count);
  const DST = validateDST(_DST);
  const log2p = p2.toString(2).length;
  const L2 = Math.ceil((log2p + k2) / 8);
  const len_in_bytes = count * m3 * L2;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k2, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u3 = new Array(count);
  for (let i3 = 0; i3 < count; i3++) {
    const e3 = new Array(m3);
    for (let j4 = 0; j4 < m3; j4++) {
      const elm_offset = L2 * (j4 + i3 * m3);
      const tv = prb.subarray(elm_offset, elm_offset + L2);
      e3[j4] = mod(os2ip(tv), p2);
    }
    u3[i3] = e3;
  }
  return u3;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i3) => Array.from(i3).reverse());
  return (x3, y3) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i3) => field.add(field.mul(acc, x3), i3)));
    x3 = field.div(xNum, xDen);
    y3 = field.mul(y3, field.div(yNum, yDen));
    return { x: x3, y: y3 };
  };
}
function createHasher(Point3, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u3 = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point3.fromAffine(mapToCurve(u3[0]));
      const u1 = Point3.fromAffine(mapToCurve(u3[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u3 = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point3.fromAffine(mapToCurve(u3[0])).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/_shortw_utils.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/hmac.js
init_shim();
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i3 = 0; i3 < pad.length; i3++)
      pad[i3] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i3 = 0; i3 < pad.length; i3++)
      pad[i3] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a3, b3) => (a3 + b3 / _2n5) / b3;
function sqrtMod(y3) {
  const P = secp256k1P;
  const _3n4 = BigInt(3), _6n2 = BigInt(6), _11n2 = BigInt(11), _22n = BigInt(22);
  const _23n2 = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y3 * y3 * y3 % P;
  const b3 = b22 * b22 * y3 % P;
  const b6 = pow2(b3, _3n4, P) * b3 % P;
  const b9 = pow2(b6, _3n4, P) * b3 % P;
  const b11 = pow2(b9, _2n5, P) * b22 % P;
  const b222 = pow2(b11, _11n2, P) * b11 % P;
  const b44 = pow2(b222, _22n, P) * b222 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n4, P) * b3 % P;
  const t1 = pow2(b223, _23n2, P) * b222 % P;
  const t22 = pow2(t1, _6n2, P) * b22 % P;
  const root = pow2(t22, _2n5, P);
  if (!Fp.eql(Fp.sqr(root), y3))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n3 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b22 * k2, n3);
      const c22 = divNearest(-b1 * k2, n3);
      let k1 = mod(k2 - c1 * a1 - c22 * a22, n3);
      let k22 = mod(-c1 * b1 - c22 * b22, n3);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n3 - k1;
      if (k2neg)
        k22 = n3 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha2562);
var _0n6 = BigInt(0);
var fe = (x3) => typeof x3 === "bigint" && _0n6 < x3 && x3 < secp256k1P;
var ge = (x3) => typeof x3 === "bigint" && _0n6 < x3 && x3 < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha2562(Uint8Array.from(tag, (c3) => c3.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha2562(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n3) => numberToBytesBE(n3, 32);
var modP = (x3) => mod(x3, secp256k1P);
var modN = (x3) => mod(x3, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q2, a3, b3) => Point.BASE.multiplyAndAddUnsafe(Q2, a3, b3);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p2 = Point.fromPrivateKey(d_);
  const scalar = p2.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p2) };
}
function lift_x(x3) {
  if (!fe(x3))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x3 * x3);
  const c3 = modP(xx * x3 + BigInt(7));
  let y3 = sqrtMod(c3);
  if (y3 % _2n5 !== _0n6)
    y3 = modP(-y3);
  const p2 = new Point(x3, y3, _1n6);
  p2.assertValidity();
  return p2;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m3 = ensureBytes("message", message);
  const { bytes: px, scalar: d3 } = schnorrGetExtPubKey(privateKey);
  const a3 = ensureBytes("auxRand", auxRand, 32);
  const t3 = numTo32b(d3 ^ bytesToNumberBE(taggedHash("BIP0340/aux", a3)));
  const rand = taggedHash("BIP0340/nonce", t3, px, m3);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n6)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k2 } = schnorrGetExtPubKey(k_);
  const e3 = challenge(rx, px, m3);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k2 + e3 * d3)), 32);
  if (!schnorrVerify(sig, m3, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m3 = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE(pub));
    const r3 = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r3))
      return false;
    const s3 = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s3))
      return false;
    const e3 = challenge(numTo32b(r3), pointToBytes(P), m3);
    const R2 = GmulAdd(P, s3, modN(-e3));
    if (!R2 || !R2.hasEvenY() || R2.toAffine().x !== r3)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fp, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i3) => i3.map((j4) => BigInt(j4)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
}))();
var htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x: x3, y: y3 } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x3, y3);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha2562
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/pair/fromSeed.js
function secp256k1PairFromSeed(seed, onlyJs) {
  if (seed.length !== 32) {
    throw new Error("Expected valid 32-byte private key as a seed");
  }
  if (!hasBigInt || !onlyJs && isReady()) {
    const full = secp256k1FromSeed(seed);
    const publicKey = full.slice(32);
    if (u8aEmpty(publicKey)) {
      throw new Error("Invalid publicKey generated from WASM interface");
    }
    return {
      publicKey,
      secretKey: full.slice(0, 32)
    };
  }
  return {
    publicKey: secp256k1.getPublicKey(seed, true),
    secretKey: seed
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/key/hdkdDerive.js
init_shim();
function createSeedDeriveFn(fromSeed, derive) {
  return (keypair, { chainCode, isHard }) => {
    if (!isHard) {
      throw new Error("A soft key was found in the path and is not supported");
    }
    return fromSeed(derive(keypair.secretKey.subarray(0, 32), chainCode));
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/key/hdkdEcdsa.js
var keyHdkdEcdsa = createSeedDeriveFn(secp256k1PairFromSeed, secp256k1DeriveHard);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/key/hdkdEd25519.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ed25519/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ed25519/deriveHard.js
init_shim();
var HDKD2 = compactAddLength(stringToU8a("Ed25519HDKD"));
function ed25519DeriveHard(seed, chainCode) {
  if (!isU8a(chainCode) || chainCode.length !== 32) {
    throw new Error("Invalid chainCode passed to derive");
  }
  return blake2AsU8a(u8aConcat(HDKD2, seed, chainCode));
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ed25519/pair/fromRandom.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/random/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/random/asNumber.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/random/asU8a.js
init_shim();
function randomAsU8a(length = 32) {
  return getRandomValues(new Uint8Array(length));
}
var randomAsHex = createAsHex(randomAsU8a);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/random/asNumber.js
var BN_53 = new import_bn.default(9007199254740991);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ed25519/pair/fromSeed.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/ed25519.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/sha512.js
init_shim();
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n3) => BigInt(n3))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4) {
      SHA512_W_H[i3] = view.getUint32(offset);
      SHA512_W_L[i3] = view.getUint32(offset += 4);
    }
    for (let i3 = 16; i3 < 80; i3++) {
      const W15h = SHA512_W_H[i3 - 15] | 0;
      const W15l = SHA512_W_L[i3 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i3 - 2] | 0;
      const W2l = SHA512_W_L[i3 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i3 - 7], SHA512_W_L[i3 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i3 - 7], SHA512_W_H[i3 - 16]);
      SHA512_W_H[i3] = SUMh | 0;
      SHA512_W_L[i3] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i3 = 0; i3 < 80; i3++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i3], SHA512_W_L[i3]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i3], SHA512_W_H[i3]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha5122 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/abstract/edwards.js
init_shim();
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n6 = BigInt(2);
var _8n3 = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function validateOpts2(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n6 << BigInt(nByteLength * 8) - _1n7;
  const modP2 = Fp3.create;
  const uvRatio2 = CURVE.uvRatio || ((u3, v3) => {
    try {
      return { isValid: true, value: Fp3.sqrt(u3 * Fp3.inv(v3)) };
    } catch (e3) {
      return { isValid: false, value: _0n7 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  const inBig = (n3) => typeof n3 === "bigint" && _0n7 < n3;
  const inRange = (n3, max) => inBig(n3) && inBig(max) && n3 < max;
  const in0MaskRange = (n3) => n3 === _0n7 || inRange(n3, MASK);
  function assertInRange(n3, max) {
    if (inRange(n3, max))
      return n3;
    throw new Error(`Expected valid scalar < ${max}, got ${typeof n3} ${n3}`);
  }
  function assertGE0(n3) {
    return n3 === _0n7 ? n3 : assertInRange(n3, CURVE_ORDER);
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function isPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ExtendedPoint expected");
  }
  class Point3 {
    constructor(ex, ey, ez, et) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      if (!in0MaskRange(ex))
        throw new Error("x required");
      if (!in0MaskRange(ey))
        throw new Error("y required");
      if (!in0MaskRange(ez))
        throw new Error("z required");
      if (!in0MaskRange(et))
        throw new Error("t required");
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p2) {
      if (p2 instanceof Point3)
        throw new Error("extended point not allowed");
      const { x: x3, y: y3 } = p2 || {};
      if (!in0MaskRange(x3) || !in0MaskRange(y3))
        throw new Error("invalid affine point");
      return new Point3(x3, y3, _1n7, modP2(x3 * y3));
    }
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p2) => p2.ez));
      return points.map((p2, i3) => p2.toAffine(toInv[i3])).map(Point3.fromAffine);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      const { a: a3, d: d3 } = CURVE;
      if (this.is0())
        throw new Error("bad point: ZERO");
      const { ex: X2, ey: Y2, ez: Z3, et: T2 } = this;
      const X22 = modP2(X2 * X2);
      const Y22 = modP2(Y2 * Y2);
      const Z22 = modP2(Z3 * Z3);
      const Z4 = modP2(Z22 * Z22);
      const aX2 = modP2(X22 * a3);
      const left = modP2(Z22 * modP2(aX2 + Y22));
      const right = modP2(Z4 + modP2(d3 * modP2(X22 * Y22)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP2(X2 * Y2);
      const ZT = modP2(Z3 * T2);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
    }
    // Compare one point to another.
    equals(other) {
      isPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z22 } = other;
      const X1Z2 = modP2(X1 * Z22);
      const X2Z1 = modP2(X2 * Z1);
      const Y1Z2 = modP2(Y1 * Z22);
      const Y2Z1 = modP2(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    negate() {
      return new Point3(modP2(-this.ex), this.ey, this.ez, modP2(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a3 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP2(X1 * X1);
      const B2 = modP2(Y1 * Y1);
      const C3 = modP2(_2n6 * modP2(Z1 * Z1));
      const D2 = modP2(a3 * A);
      const x1y1 = X1 + Y1;
      const E2 = modP2(modP2(x1y1 * x1y1) - A - B2);
      const G4 = D2 + B2;
      const F2 = G4 - C3;
      const H3 = D2 - B2;
      const X3 = modP2(E2 * F2);
      const Y3 = modP2(G4 * H3);
      const T3 = modP2(E2 * H3);
      const Z3 = modP2(F2 * G4);
      return new Point3(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      isPoint(other);
      const { a: a3, d: d3 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z22, et: T2 } = other;
      if (a3 === BigInt(-1)) {
        const A2 = modP2((Y1 - X1) * (Y2 + X2));
        const B3 = modP2((Y1 + X1) * (Y2 - X2));
        const F3 = modP2(B3 - A2);
        if (F3 === _0n7)
          return this.double();
        const C4 = modP2(Z1 * _2n6 * T2);
        const D3 = modP2(T1 * _2n6 * Z22);
        const E3 = D3 + C4;
        const G5 = B3 + A2;
        const H4 = D3 - C4;
        const X32 = modP2(E3 * F3);
        const Y32 = modP2(G5 * H4);
        const T32 = modP2(E3 * H4);
        const Z32 = modP2(F3 * G5);
        return new Point3(X32, Y32, Z32, T32);
      }
      const A = modP2(X1 * X2);
      const B2 = modP2(Y1 * Y2);
      const C3 = modP2(T1 * d3 * T2);
      const D2 = modP2(Z1 * Z22);
      const E2 = modP2((X1 + Y1) * (X2 + Y2) - A - B2);
      const F2 = D2 - C3;
      const G4 = D2 + C3;
      const H3 = modP2(B2 - a3 * A);
      const X3 = modP2(E2 * F2);
      const Y3 = modP2(G4 * H3);
      const T3 = modP2(E2 * H3);
      const Z3 = modP2(F2 * G4);
      return new Point3(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n3) {
      return wnaf.wNAFCached(this, pointPrecomputes, n3, Point3.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const { p: p2, f: f3 } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
      return Point3.normalizeZ([p2, f3])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(scalar) {
      let n3 = assertGE0(scalar);
      if (n3 === _0n7)
        return I2;
      if (this.equals(I2) || n3 === _1n7)
        return this;
      if (this.equals(G3))
        return this.wNAF(n3).p;
      return wnaf.unsafeLadder(this, n3);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      const { ex: x3, ey: y3, ez: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? _8n3 : Fp3.inv(z2);
      const ax = modP2(x3 * iz);
      const ay = modP2(y3 * iz);
      const zz = modP2(z2 * iz);
      if (is0)
        return { x: _0n7, y: _1n7 };
      if (zz !== _1n7)
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n7)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex3, zip215 = false) {
      const { d: d3, a: a3 } = CURVE;
      const len = Fp3.BYTES;
      hex3 = ensureBytes("pointHex", hex3, len);
      const normed = hex3.slice();
      const lastByte = hex3[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y3 = bytesToNumberLE(normed);
      if (y3 === _0n7) {
      } else {
        if (zip215)
          assertInRange(y3, MASK);
        else
          assertInRange(y3, Fp3.ORDER);
      }
      const y22 = modP2(y3 * y3);
      const u3 = modP2(y22 - _1n7);
      const v3 = modP2(d3 * y22 - a3);
      let { isValid, value: x3 } = uvRatio2(u3, v3);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x3 & _1n7) === _1n7;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x3 === _0n7 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x3 = modP2(-x3);
      return Point3.fromAffine({ x: x3, y: y3 });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x: x3, y: y3 } = this.toAffine();
      const bytes2 = numberToBytesLE(y3, Fp3.BYTES);
      bytes2[bytes2.length - 1] |= x3 & _1n7 ? 128 : 0;
      return bytes2;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, _1n7, modP2(CURVE.Gx * CURVE.Gy));
  Point3.ZERO = new Point3(_0n7, _1n7, _1n7, _0n7);
  const { BASE: G3, ZERO: I2 } = Point3;
  const wnaf = wNAF(Point3, nByteLength * 8);
  function modN2(a3) {
    return mod(a3, CURVE_ORDER);
  }
  function modN_LE(hash2) {
    return modN2(bytesToNumberLE(hash2));
  }
  function getExtendedPublicKey(key) {
    const len = nByteLength;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G3.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r3 = hashDomainToScalar(options.context, prefix, msg);
    const R2 = G3.multiply(r3).toRawBytes();
    const k2 = hashDomainToScalar(options.context, R2, pointBytes, msg);
    const s3 = modN2(r3 + k2 * scalar);
    assertGE0(s3);
    const res = concatBytes2(R2, numberToBytesLE(s3, Fp3.BYTES));
    return ensureBytes("result", res, nByteLength * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp3.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const s3 = bytesToNumberLE(sig.slice(len, 2 * len));
    let A, R2, SB;
    try {
      A = Point3.fromHex(publicKey, zip215);
      R2 = Point3.fromHex(sig.slice(0, len), zip215);
      SB = G3.multiplyUnsafe(s3);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k2 = hashDomainToScalar(context, R2.toRawBytes(), A.toRawBytes(), msg);
    const RkA = R2.add(A.multiplyUnsafe(k2));
    return RkA.subtract(SB).clearCofactor().equals(Point3.ZERO);
  }
  G3._setWindowSize(8);
  const utils2 = {
    getExtendedPublicKey,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes2(Fp3.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign,
    verify,
    ExtendedPoint: Point3,
    utils: utils2
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/abstract/montgomery.js
init_shim();
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
function validateOpts3(curve) {
  validateObject(curve, {
    a: "bigint"
  }, {
    montgomeryBits: "isSafeInteger",
    nByteLength: "isSafeInteger",
    adjustScalarBytes: "function",
    domain: "function",
    powPminus2: "function",
    Gu: "bigint"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts3(curveDef);
  const { P } = CURVE;
  const modP2 = (n3) => mod(n3, P);
  const montgomeryBits = CURVE.montgomeryBits;
  const montgomeryBytes = Math.ceil(montgomeryBits / 8);
  const fieldLen = CURVE.nByteLength;
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const powPminus2 = CURVE.powPminus2 || ((x3) => pow(x3, P - BigInt(2), P));
  function cswap(swap, x_2, x_3) {
    const dummy = modP2(swap * (x_2 - x_3));
    x_2 = modP2(x_2 - dummy);
    x_3 = modP2(x_3 + dummy);
    return [x_2, x_3];
  }
  function assertFieldElement(n3) {
    if (typeof n3 === "bigint" && _0n8 <= n3 && n3 < P)
      return n3;
    throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
  }
  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
  function montgomeryLadder(pointU, scalar) {
    const u3 = assertFieldElement(pointU);
    const k2 = assertFieldElement(scalar);
    const x_1 = u3;
    let x_2 = _1n8;
    let z_2 = _0n8;
    let x_3 = u3;
    let z_3 = _1n8;
    let swap = _0n8;
    let sw;
    for (let t3 = BigInt(montgomeryBits - 1); t3 >= _0n8; t3--) {
      const k_t = k2 >> t3 & _1n8;
      swap ^= k_t;
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP2(A * A);
      const B2 = x_2 - z_2;
      const BB = modP2(B2 * B2);
      const E2 = AA - BB;
      const C3 = x_3 + z_3;
      const D2 = x_3 - z_3;
      const DA = modP2(D2 * A);
      const CB = modP2(C3 * B2);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP2(dacb * dacb);
      z_3 = modP2(x_1 * modP2(da_cb * da_cb));
      x_2 = modP2(AA * BB);
      z_2 = modP2(E2 * (AA + modP2(a24 * E2)));
    }
    sw = cswap(swap, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const z2 = powPminus2(z_2);
    return modP2(x_2 * z2);
  }
  function encodeUCoordinate(u3) {
    return numberToBytesLE(modP2(u3), montgomeryBytes);
  }
  function decodeUCoordinate(uEnc) {
    const u3 = ensureBytes("u coordinate", uEnc, montgomeryBytes);
    if (fieldLen === montgomeryBytes)
      u3[fieldLen - 1] &= 127;
    return bytesToNumberLE(u3);
  }
  function decodeScalar(n3) {
    const bytes2 = ensureBytes("scalar", n3);
    if (bytes2.length !== montgomeryBytes && bytes2.length !== fieldLen)
      throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes2.length}`);
    return bytesToNumberLE(adjustScalarBytes2(bytes2));
  }
  function scalarMult(scalar, u3) {
    const pointU = decodeUCoordinate(u3);
    const _scalar = decodeScalar(scalar);
    const pu = montgomeryLadder(pointU, _scalar);
    if (pu === _0n8)
      throw new Error("Invalid private or public key received");
    return encodeUCoordinate(pu);
  }
  const GuBytes = encodeUCoordinate(CURVE.Gu);
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
    GuBytes
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/curves/esm/ed25519.js
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n9 = BigInt(0);
var _1n9 = BigInt(1);
var _2n7 = BigInt(2);
var _5n3 = BigInt(5);
var _10n2 = BigInt(10);
var _20n = BigInt(20);
var _40n = BigInt(40);
var _80n = BigInt(80);
function ed25519_pow_2_252_3(x3) {
  const P = ED25519_P;
  const x22 = x3 * x3 % P;
  const b22 = x22 * x3 % P;
  const b4 = pow2(b22, _2n7, P) * b22 % P;
  const b5 = pow2(b4, _1n9, P) * x3 % P;
  const b10 = pow2(b5, _5n3, P) * b5 % P;
  const b20 = pow2(b10, _10n2, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n2, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n7, P) * x3 % P;
  return { pow_p_5_8, b2: b22 };
}
function adjustScalarBytes(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function uvRatio(u3, v3) {
  const P = ED25519_P;
  const v32 = mod(v3 * v3 * v3, P);
  const v7 = mod(v32 * v32 * v3, P);
  const pow3 = ed25519_pow_2_252_3(u3 * v7).pow_p_5_8;
  let x3 = mod(u3 * v32 * pow3, P);
  const vx2 = mod(v3 * x3 * x3, P);
  const root1 = x3;
  const root2 = mod(x3 * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u3;
  const useRoot2 = vx2 === mod(-u3, P);
  const noRoot = vx2 === mod(-u3 * ED25519_SQRT_M1, P);
  if (useRoot1)
    x3 = root1;
  if (useRoot2 || noRoot)
    x3 = root2;
  if (isNegativeLE(x3, P))
    x3 = mod(-x3, P);
  return { isValid: useRoot1 || useRoot2, value: x3 };
}
var Fp2 = Field(ED25519_P, void 0, true);
var ed25519Defaults = {
  // Param: a
  a: BigInt(-1),
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
  Fp: Fp2,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: BigInt(8),
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha5122,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio
};
var ed25519 = twistedEdwards(ed25519Defaults);
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx = twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
});
var ed25519ph = twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain,
  prehash: sha5122
});
var x25519 = (() => montgomery({
  P: ED25519_P,
  a: BigInt(486662),
  montgomeryBits: 255,
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: (x3) => {
    const P = ED25519_P;
    const { pow_p_5_8, b2: b22 } = ed25519_pow_2_252_3(x3);
    return mod(pow2(pow_p_5_8, BigInt(3), P) * b22, P);
  },
  adjustScalarBytes,
  randomBytes
}))();
var ELL2_C1 = (Fp2.ORDER + BigInt(3)) / BigInt(8);
var ELL2_C2 = Fp2.pow(_2n7, ELL2_C1);
var ELL2_C3 = Fp2.sqrt(Fp2.neg(Fp2.ONE));
var ELL2_C4 = (Fp2.ORDER - BigInt(5)) / BigInt(8);
var ELL2_J = BigInt(486662);
function map_to_curve_elligator2_curve25519(u3) {
  let tv1 = Fp2.sqr(u3);
  tv1 = Fp2.mul(tv1, _2n7);
  let xd = Fp2.add(tv1, Fp2.ONE);
  let x1n = Fp2.neg(ELL2_J);
  let tv2 = Fp2.sqr(xd);
  let gxd = Fp2.mul(tv2, xd);
  let gx1 = Fp2.mul(tv1, ELL2_J);
  gx1 = Fp2.mul(gx1, x1n);
  gx1 = Fp2.add(gx1, tv2);
  gx1 = Fp2.mul(gx1, x1n);
  let tv3 = Fp2.sqr(gxd);
  tv2 = Fp2.sqr(tv3);
  tv3 = Fp2.mul(tv3, gxd);
  tv3 = Fp2.mul(tv3, gx1);
  tv2 = Fp2.mul(tv2, tv3);
  let y11 = Fp2.pow(tv2, ELL2_C4);
  y11 = Fp2.mul(y11, tv3);
  let y12 = Fp2.mul(y11, ELL2_C3);
  tv2 = Fp2.sqr(y11);
  tv2 = Fp2.mul(tv2, gxd);
  let e1 = Fp2.eql(tv2, gx1);
  let y1 = Fp2.cmov(y12, y11, e1);
  let x2n = Fp2.mul(x1n, tv1);
  let y21 = Fp2.mul(y11, u3);
  y21 = Fp2.mul(y21, ELL2_C2);
  let y22 = Fp2.mul(y21, ELL2_C3);
  let gx2 = Fp2.mul(gx1, tv1);
  tv2 = Fp2.sqr(y21);
  tv2 = Fp2.mul(tv2, gxd);
  let e22 = Fp2.eql(tv2, gx2);
  let y23 = Fp2.cmov(y22, y21, e22);
  tv2 = Fp2.sqr(y1);
  tv2 = Fp2.mul(tv2, gxd);
  let e3 = Fp2.eql(tv2, gx1);
  let xn = Fp2.cmov(x2n, x1n, e3);
  let y3 = Fp2.cmov(y23, y1, e3);
  let e4 = Fp2.isOdd(y3);
  y3 = Fp2.cmov(y3, Fp2.neg(y3), e3 !== e4);
  return { xMn: xn, xMd: xd, yMn: y3, yMd: _1n9 };
}
var ELL2_C1_EDWARDS = FpSqrtEven(Fp2, Fp2.neg(BigInt(486664)));
function map_to_curve_elligator2_edwards25519(u3) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u3);
  let xn = Fp2.mul(xMn, yMd);
  xn = Fp2.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp2.mul(xMd, yMn);
  let yn = Fp2.sub(xMn, xMd);
  let yd = Fp2.add(xMn, xMd);
  let tv1 = Fp2.mul(xd, yd);
  let e3 = Fp2.eql(tv1, Fp2.ZERO);
  xn = Fp2.cmov(xn, Fp2.ZERO, e3);
  xd = Fp2.cmov(xd, Fp2.ONE, e3);
  yn = Fp2.cmov(yn, Fp2.ONE, e3);
  yd = Fp2.cmov(yd, Fp2.ONE, e3);
  const inv = Fp2.invertBatch([xd, yd]);
  return { x: Fp2.mul(xn, inv[0]), y: Fp2.mul(yn, inv[1]) };
}
var htf2 = (() => createHasher(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: Fp2.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha5122
}))();
var hashToCurve2 = (() => htf2.hashToCurve)();
var encodeToCurve2 = (() => htf2.encodeToCurve)();
function assertRstPoint(other) {
  if (!(other instanceof RistPoint))
    throw new Error("RistrettoPoint expected");
}
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number2) => uvRatio(_1n9, number2);
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes2) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes2) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d: d3 } = ed25519.CURVE;
  const P = ed25519.CURVE.Fp.ORDER;
  const mod2 = ed25519.CURVE.Fp.create;
  const r3 = mod2(SQRT_M1 * r0 * r0);
  const Ns = mod2((r3 + _1n9) * ONE_MINUS_D_SQ);
  let c3 = BigInt(-1);
  const D2 = mod2((c3 - d3 * r3) * mod2(r3 + d3));
  let { isValid: Ns_D_is_sq, value: s3 } = uvRatio(Ns, D2);
  let s_ = mod2(s3 * r0);
  if (!isNegativeLE(s_, P))
    s_ = mod2(-s_);
  if (!Ns_D_is_sq)
    s3 = s_;
  if (!Ns_D_is_sq)
    c3 = r3;
  const Nt = mod2(c3 * (r3 - _1n9) * D_MINUS_ONE_SQ - D2);
  const s22 = s3 * s3;
  const W0 = mod2((s3 + s3) * D2);
  const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod2(_1n9 - s22);
  const W3 = mod2(_1n9 + s22);
  return new ed25519.ExtendedPoint(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
}
var RistPoint = class {
  // Private property to discourage combining ExtendedPoint + RistrettoPoint
  // Always use Ristretto encoding/decoding instead.
  constructor(ep) {
    this.ep = ep;
  }
  static fromAffine(ap) {
    return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));
  }
  /**
   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
   * The hash-to-group operation applies Elligator twice and adds the results.
   * **Note:** this is one-way map, there is no conversion from point to hash.
   * https://ristretto.group/formulas/elligator.html
   * @param hex 64-byte output of a hash function
   */
  static hashToCurve(hex3) {
    hex3 = ensureBytes("ristrettoHash", hex3, 64);
    const r1 = bytes255ToNumberLE(hex3.slice(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r22 = bytes255ToNumberLE(hex3.slice(32, 64));
    const R2 = calcElligatorRistrettoMap(r22);
    return new RistPoint(R1.add(R2));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * https://ristretto.group/formulas/decoding.html
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex3) {
    hex3 = ensureBytes("ristrettoHex", hex3, 32);
    const { a: a3, d: d3 } = ed25519.CURVE;
    const P = ed25519.CURVE.Fp.ORDER;
    const mod2 = ed25519.CURVE.Fp.create;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s3 = bytes255ToNumberLE(hex3);
    if (!equalBytes(numberToBytesLE(s3, 32), hex3) || isNegativeLE(s3, P))
      throw new Error(emsg);
    const s22 = mod2(s3 * s3);
    const u1 = mod2(_1n9 + a3 * s22);
    const u22 = mod2(_1n9 - a3 * s22);
    const u1_2 = mod2(u1 * u1);
    const u2_2 = mod2(u22 * u22);
    const v3 = mod2(a3 * d3 * u1_2 - u2_2);
    const { isValid, value: I2 } = invertSqrt(mod2(v3 * u2_2));
    const Dx = mod2(I2 * u22);
    const Dy = mod2(I2 * Dx * v3);
    let x3 = mod2((s3 + s3) * Dx);
    if (isNegativeLE(x3, P))
      x3 = mod2(-x3);
    const y3 = mod2(u1 * Dy);
    const t3 = mod2(x3 * y3);
    if (!isValid || isNegativeLE(t3, P) || y3 === _0n9)
      throw new Error(emsg);
    return new RistPoint(new ed25519.ExtendedPoint(x3, y3, _1n9, t3));
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * https://ristretto.group/formulas/encoding.html
   */
  toRawBytes() {
    let { ex: x3, ey: y3, ez: z2, et: t3 } = this.ep;
    const P = ed25519.CURVE.Fp.ORDER;
    const mod2 = ed25519.CURVE.Fp.create;
    const u1 = mod2(mod2(z2 + y3) * mod2(z2 - y3));
    const u22 = mod2(x3 * y3);
    const u2sq = mod2(u22 * u22);
    const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));
    const D1 = mod2(invsqrt * u1);
    const D2 = mod2(invsqrt * u22);
    const zInv = mod2(D1 * D2 * t3);
    let D3;
    if (isNegativeLE(t3 * zInv, P)) {
      let _x = mod2(y3 * SQRT_M1);
      let _y = mod2(x3 * SQRT_M1);
      x3 = _x;
      y3 = _y;
      D3 = mod2(D1 * INVSQRT_A_MINUS_D);
    } else {
      D3 = D2;
    }
    if (isNegativeLE(x3 * zInv, P))
      y3 = mod2(-y3);
    let s3 = mod2((z2 - y3) * D3);
    if (isNegativeLE(s3, P))
      s3 = mod2(-s3);
    return numberToBytesLE(s3, 32);
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  // Compare one point to another.
  equals(other) {
    assertRstPoint(other);
    const { ex: X1, ey: Y1 } = this.ep;
    const { ex: X2, ey: Y2 } = other.ep;
    const mod2 = ed25519.CURVE.Fp.create;
    const one = mod2(X1 * Y2) === mod2(Y1 * X2);
    const two = mod2(Y1 * Y2) === mod2(X1 * X2);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new RistPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new RistPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new RistPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new RistPoint(this.ep.multiplyUnsafe(scalar));
  }
};
var RistrettoPoint = (() => {
  if (!RistPoint.BASE)
    RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);
  if (!RistPoint.ZERO)
    RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);
  return RistPoint;
})();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ed25519/pair/fromSeed.js
function ed25519PairFromSeed(seed, onlyJs) {
  if (!hasBigInt || !onlyJs && isReady()) {
    const full = ed25519KeypairFromSeed(seed);
    return {
      publicKey: full.slice(32),
      secretKey: full.slice(0, 64)
    };
  }
  const publicKey = ed25519.getPublicKey(seed);
  return {
    publicKey,
    secretKey: u8aConcatStrict([seed, publicKey])
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ed25519/pair/fromSecret.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ed25519/pair/fromString.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ed25519/sign.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ed25519/verify.js
init_shim();
function ed25519Verify2(message, signature, publicKey, onlyJs) {
  const messageU8a = u8aToU8a(message);
  const publicKeyU8a = u8aToU8a(publicKey);
  const signatureU8a = u8aToU8a(signature);
  if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length}, expected 32`);
  } else if (signatureU8a.length !== 64) {
    throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
  }
  try {
    return !hasBigInt || !onlyJs && isReady() ? ed25519Verify(signatureU8a, messageU8a, publicKeyU8a) : ed25519.verify(signatureU8a, messageU8a, publicKeyU8a);
  } catch {
    return false;
  }
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/key/hdkdEd25519.js
var keyHdkdEd25519 = createSeedDeriveFn(ed25519PairFromSeed, ed25519DeriveHard);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/key/hdkdSr25519.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/deriveHard.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/derive.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/pair/fromU8a.js
init_shim();
var SEC_LEN = 64;
var PUB_LEN = 32;
var TOT_LEN = SEC_LEN + PUB_LEN;
function sr25519PairFromU8a(full) {
  const fullU8a = u8aToU8a(full);
  if (fullU8a.length !== TOT_LEN) {
    throw new Error(`Expected keypair with ${TOT_LEN} bytes, found ${fullU8a.length}`);
  }
  return {
    publicKey: fullU8a.slice(SEC_LEN, TOT_LEN),
    secretKey: fullU8a.slice(0, SEC_LEN)
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/pair/toU8a.js
init_shim();
function sr25519KeypairToU8a({ publicKey, secretKey }) {
  return u8aConcat(secretKey, publicKey).slice();
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/derive.js
function createDeriveFn(derive) {
  return (keypair, chainCode) => {
    if (!isU8a(chainCode) || chainCode.length !== 32) {
      throw new Error("Invalid chainCode passed to derive");
    }
    return sr25519PairFromU8a(derive(sr25519KeypairToU8a(keypair), chainCode));
  };
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/deriveHard.js
var sr25519DeriveHard = createDeriveFn(sr25519DeriveKeypairHard);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/deriveSoft.js
init_shim();
var sr25519DeriveSoft = createDeriveFn(sr25519DeriveKeypairSoft);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/agreement.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/derivePublic.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/pair/fromSeed.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/sign.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/verify.js
init_shim();
function sr25519Verify2(message, signature, publicKey) {
  const publicKeyU8a = u8aToU8a(publicKey);
  const signatureU8a = u8aToU8a(signature);
  if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
  } else if (signatureU8a.length !== 64) {
    throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
  }
  return sr25519Verify(signatureU8a, u8aToU8a(message), publicKeyU8a);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/vrfSign.js
init_shim();
var EMPTY_U8A = new Uint8Array();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sr25519/vrfVerify.js
init_shim();
var EMPTY_U8A2 = new Uint8Array();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/encode.js
init_shim();
function encodeAddress(key, ss58Format = defaults.prefix) {
  const u8a3 = decodeAddress(key);
  if (ss58Format < 0 || ss58Format > 16383 || [46, 47].includes(ss58Format)) {
    throw new Error("Out of range ss58Format specified");
  } else if (!defaults.allowedDecodedLengths.includes(u8a3.length)) {
    throw new Error(`Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(", ")}`);
  }
  const input = u8aConcat(ss58Format < 64 ? [ss58Format] : [
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  ], u8a3);
  return base58Encode(u8aConcat(input, sshash(input).subarray(0, [32, 33].includes(u8a3.length) ? 2 : 1)));
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/encodeDerived.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/keyDerived.js
init_shim();
var PREFIX = stringToU8a("modlpy/utilisuba");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/encodeMulti.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/keyMulti.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/util.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/keyMulti.js
var PREFIX2 = stringToU8a("modlpy/utilisuba");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/eq.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/evmToAddress.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/hasher.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/blake2/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/keccak/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/keccak/asU8a.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/sha3.js
init_shim();
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n10 = BigInt(0);
var _1n10 = BigInt(1);
var _2n8 = BigInt(2);
var _7n2 = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R2 = _1n10, x3 = 1, y3 = 0; round < 24; round++) {
  [x3, y3] = [y3, (2 * x3 + 3 * y3) % 5];
  SHA3_PI.push(2 * (5 * y3 + x3));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t3 = _0n10;
  for (let j4 = 0; j4 < 7; j4++) {
    R2 = (R2 << _1n10 ^ (R2 >> _7n2) * _0x71n) % _256n;
    if (R2 & _2n8)
      t3 ^= _1n10 << (_1n10 << BigInt(j4)) - _1n10;
  }
  _SHA3_IOTA.push(t3);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h2, l4, s3) => s3 > 32 ? rotlBH(h2, l4, s3) : rotlSH(h2, l4, s3);
var rotlL = (h2, l4, s3) => s3 > 32 ? rotlBL(h2, l4, s3) : rotlSL(h2, l4, s3);
function keccakP(s3, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x3 = 0; x3 < 10; x3++)
      B2[x3] = s3[x3] ^ s3[x3 + 10] ^ s3[x3 + 20] ^ s3[x3 + 30] ^ s3[x3 + 40];
    for (let x3 = 0; x3 < 10; x3 += 2) {
      const idx1 = (x3 + 8) % 10;
      const idx0 = (x3 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y3 = 0; y3 < 50; y3 += 10) {
        s3[x3 + y3] ^= Th;
        s3[x3 + y3 + 1] ^= Tl;
      }
    }
    let curH = s3[2];
    let curL = s3[3];
    for (let t3 = 0; t3 < 24; t3++) {
      const shift = SHA3_ROTL[t3];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t3];
      curH = s3[PI];
      curL = s3[PI + 1];
      s3[PI] = Th;
      s3[PI + 1] = Tl;
    }
    for (let y3 = 0; y3 < 50; y3 += 10) {
      for (let x3 = 0; x3 < 10; x3++)
        B2[x3] = s3[y3 + x3];
      for (let x3 = 0; x3 < 10; x3++)
        s3[y3 + x3] ^= ~B2[(x3 + 2) % 10] & B2[(x3 + 4) % 10];
    }
    s3[0] ^= SHA3_IOTA_H[round];
    s3[1] ^= SHA3_IOTA_L[round];
  }
  B2.fill(0);
}
var Keccak = class extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i3 = 0; i3 < take; i3++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/keccak/asU8a.js
var keccakAsU8a = createDualHasher({ 256: keccak256, 512: keccak512 }, { 256: keccak_256, 512: keccak_512 });
var keccak256AsU8a = createBitHasher(256, keccakAsU8a);
var keccak512AsU8a = createBitHasher(512, keccakAsU8a);
var keccakAsHex = createAsHex(keccakAsU8a);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/hasher.js
function hasher(hashType, data, onlyJs) {
  return hashType === "keccak" ? keccakAsU8a(data, void 0, onlyJs) : blake2AsU8a(data, void 0, void 0, onlyJs);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/is.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/validate.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/sort.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/address/setSS58Format.js
init_shim();
var l2 = logger("setSS58Format");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/base32/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/base32/bs32.js
init_shim();
var chars = "abcdefghijklmnopqrstuvwxyz234567";
var config2 = {
  chars,
  coder: utils.chain(
    // We define our own chain, the default base32 has padding
    utils.radix2(5),
    utils.alphabet(chars),
    {
      decode: (input) => input.split(""),
      encode: (input) => input.join("")
    }
  ),
  ipfs: "b",
  type: "base32"
};
var base32Validate = createValidate(config2);
var isBase32 = createIs(base32Validate);
var base32Decode = createDecode(config2, base32Validate);
var base32Encode = createEncode(config2);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/base64/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/base64/bs64.js
init_shim();
var config3 = {
  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  coder: base64,
  type: "base64",
  withPadding: true
};
var base64Validate = createValidate(config3);
var isBase64 = createIs(base64Validate);
var base64Decode = createDecode(config3, base64Validate);
var base64Encode = createEncode(config3);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/base64/pad.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/base64/trim.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ethereum/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ethereum/encode.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/compress.js
init_shim();
function secp256k1Compress2(publicKey, onlyJs) {
  if (![33, 65].includes(publicKey.length)) {
    throw new Error(`Invalid publicKey provided, received ${publicKey.length} bytes input`);
  }
  if (publicKey.length === 33) {
    return publicKey;
  }
  return !hasBigInt || !onlyJs && isReady() ? secp256k1Compress(publicKey) : secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(true);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/expand.js
init_shim();
function secp256k1Expand2(publicKey, onlyJs) {
  if (![33, 65].includes(publicKey.length)) {
    throw new Error(`Invalid publicKey provided, received ${publicKey.length} bytes input`);
  }
  if (publicKey.length === 65) {
    return publicKey.subarray(1);
  }
  if (!hasBigInt || !onlyJs && isReady()) {
    return secp256k1Expand(publicKey).subarray(1);
  }
  const { px, py } = secp256k1.ProjectivePoint.fromHex(publicKey);
  return u8aConcat(bnToU8a(px, BN_BE_256_OPTS), bnToU8a(py, BN_BE_256_OPTS));
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/recover.js
init_shim();
function secp256k1Recover2(msgHash, signature, recovery, hashType = "blake2", onlyJs) {
  const sig = u8aToU8a(signature).subarray(0, 64);
  const msg = u8aToU8a(msgHash);
  const publicKey = !hasBigInt || !onlyJs && isReady() ? secp256k1Recover(msg, sig, recovery) : secp256k1.Signature.fromCompact(sig).addRecoveryBit(recovery).recoverPublicKey(msg).toRawBytes();
  if (!publicKey) {
    throw new Error("Unable to recover publicKey from signature");
  }
  return hashType === "keccak" ? secp256k1Expand2(publicKey, onlyJs) : secp256k1Compress2(publicKey, onlyJs);
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/sign.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/tweakAdd.js
init_shim();
var N2 = "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141".replace(/ /g, "");
var N_BI = BigInt3(`0x${N2}`);
var N_BN = new import_bn.default(N2, "hex");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/secp256k1/verify.js
init_shim();
function secp256k1Verify(msgHash, signature, address, hashType = "blake2", onlyJs) {
  const sig = u8aToU8a(signature);
  if (sig.length !== 65) {
    throw new Error(`Expected signature with 65 bytes, ${sig.length} found instead`);
  }
  const publicKey = secp256k1Recover2(hasher(hashType, msgHash), sig, sig[64], hashType, onlyJs);
  const signerAddr = hasher(hashType, publicKey, onlyJs);
  const inputAddr = u8aToU8a(address);
  return u8aEq(publicKey, inputAddr) || (hashType === "keccak" ? u8aEq(signerAddr.slice(-20), inputAddr.slice(-20)) : u8aEq(signerAddr, inputAddr));
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ethereum/encode.js
function getH160(u8a3) {
  if ([33, 65].includes(u8a3.length)) {
    u8a3 = keccakAsU8a(secp256k1Expand2(u8a3));
  }
  return u8a3.slice(-20);
}
function ethereumEncode(addressOrPublic) {
  if (!addressOrPublic) {
    return "0x";
  }
  const u8aAddress = u8aToU8a(addressOrPublic);
  if (![20, 32, 33, 65].includes(u8aAddress.length)) {
    throw new Error(`Invalid address or publicKey provided, received ${u8aAddress.length} bytes input`);
  }
  const address = u8aToHex(getH160(u8aAddress), -1, false);
  const hash2 = u8aToHex(keccakAsU8a(address), -1, false);
  let result = "";
  for (let i3 = 0; i3 < 40; i3++) {
    result = `${result}${parseInt(hash2[i3], 16) > 7 ? address[i3].toUpperCase() : address[i3]}`;
  }
  return `0x${result}`;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ethereum/isAddress.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/ethereum/isChecksum.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/hd/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/hd/ethereum/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/hmac/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/hmac/shaAsU8a.js
init_shim();
var JS_HASH = {
  256: sha2562,
  512: sha5122
};
var WA_MHAC = {
  256: hmacSha256,
  512: hmacSha512
};
function createSha(bitLength) {
  return (key, data, onlyJs) => hmacShaAsU8a(key, data, bitLength, onlyJs);
}
function hmacShaAsU8a(key, data, bitLength = 256, onlyJs) {
  const u8aKey = u8aToU8a(key);
  return !hasBigInt || !onlyJs && isReady() ? WA_MHAC[bitLength](u8aKey, data) : hmac(JS_HASH[bitLength], u8aKey, data);
}
var hmacSha256AsU8a = createSha(256);
var hmacSha512AsU8a = createSha(512);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/hd/validatePath.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/hd/ethereum/index.js
var MASTER_SECRET = stringToU8a("Bitcoin seed");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/hd/ledger/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/mnemonic/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/mnemonic/generate.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/mnemonic/bip39.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/pbkdf2/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/pbkdf2/encode.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/pbkdf2.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sha/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/sha/asU8a.js
init_shim();
var shaAsU8a = createDualHasher({ 256: sha256, 512: sha512 }, { 256: sha2562, 512: sha5122 });
var sha256AsU8a = createBitHasher(256, shaAsU8a);
var sha512AsU8a = createBitHasher(512, shaAsU8a);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/mnemonic/wordlists/en.js
init_shim();
var en_default = "abandon|ability|able|about|above|absent|absorb|abstract|absurd|abuse|access|accident|account|accuse|achieve|acid|acoustic|acquire|across|act|action|actor|actress|actual|adapt|add|addict|address|adjust|admit|adult|advance|advice|aerobic|affair|afford|afraid|again|age|agent|agree|ahead|aim|air|airport|aisle|alarm|album|alcohol|alert|alien|all|alley|allow|almost|alone|alpha|already|also|alter|always|amateur|amazing|among|amount|amused|analyst|anchor|ancient|anger|angle|angry|animal|ankle|announce|annual|another|answer|antenna|antique|anxiety|any|apart|apology|appear|apple|approve|april|arch|arctic|area|arena|argue|arm|armed|armor|army|around|arrange|arrest|arrive|arrow|art|artefact|artist|artwork|ask|aspect|assault|asset|assist|assume|asthma|athlete|atom|attack|attend|attitude|attract|auction|audit|august|aunt|author|auto|autumn|average|avocado|avoid|awake|aware|away|awesome|awful|awkward|axis|baby|bachelor|bacon|badge|bag|balance|balcony|ball|bamboo|banana|banner|bar|barely|bargain|barrel|base|basic|basket|battle|beach|bean|beauty|because|become|beef|before|begin|behave|behind|believe|below|belt|bench|benefit|best|betray|better|between|beyond|bicycle|bid|bike|bind|biology|bird|birth|bitter|black|blade|blame|blanket|blast|bleak|bless|blind|blood|blossom|blouse|blue|blur|blush|board|boat|body|boil|bomb|bone|bonus|book|boost|border|boring|borrow|boss|bottom|bounce|box|boy|bracket|brain|brand|brass|brave|bread|breeze|brick|bridge|brief|bright|bring|brisk|broccoli|broken|bronze|broom|brother|brown|brush|bubble|buddy|budget|buffalo|build|bulb|bulk|bullet|bundle|bunker|burden|burger|burst|bus|business|busy|butter|buyer|buzz|cabbage|cabin|cable|cactus|cage|cake|call|calm|camera|camp|can|canal|cancel|candy|cannon|canoe|canvas|canyon|capable|capital|captain|car|carbon|card|cargo|carpet|carry|cart|case|cash|casino|castle|casual|cat|catalog|catch|category|cattle|caught|cause|caution|cave|ceiling|celery|cement|census|century|cereal|certain|chair|chalk|champion|change|chaos|chapter|charge|chase|chat|cheap|check|cheese|chef|cherry|chest|chicken|chief|child|chimney|choice|choose|chronic|chuckle|chunk|churn|cigar|cinnamon|circle|citizen|city|civil|claim|clap|clarify|claw|clay|clean|clerk|clever|click|client|cliff|climb|clinic|clip|clock|clog|close|cloth|cloud|clown|club|clump|cluster|clutch|coach|coast|coconut|code|coffee|coil|coin|collect|color|column|combine|come|comfort|comic|common|company|concert|conduct|confirm|congress|connect|consider|control|convince|cook|cool|copper|copy|coral|core|corn|correct|cost|cotton|couch|country|couple|course|cousin|cover|coyote|crack|cradle|craft|cram|crane|crash|crater|crawl|crazy|cream|credit|creek|crew|cricket|crime|crisp|critic|crop|cross|crouch|crowd|crucial|cruel|cruise|crumble|crunch|crush|cry|crystal|cube|culture|cup|cupboard|curious|current|curtain|curve|cushion|custom|cute|cycle|dad|damage|damp|dance|danger|daring|dash|daughter|dawn|day|deal|debate|debris|decade|december|decide|decline|decorate|decrease|deer|defense|define|defy|degree|delay|deliver|demand|demise|denial|dentist|deny|depart|depend|deposit|depth|deputy|derive|describe|desert|design|desk|despair|destroy|detail|detect|develop|device|devote|diagram|dial|diamond|diary|dice|diesel|diet|differ|digital|dignity|dilemma|dinner|dinosaur|direct|dirt|disagree|discover|disease|dish|dismiss|disorder|display|distance|divert|divide|divorce|dizzy|doctor|document|dog|doll|dolphin|domain|donate|donkey|donor|door|dose|double|dove|draft|dragon|drama|drastic|draw|dream|dress|drift|drill|drink|drip|drive|drop|drum|dry|duck|dumb|dune|during|dust|dutch|duty|dwarf|dynamic|eager|eagle|early|earn|earth|easily|east|easy|echo|ecology|economy|edge|edit|educate|effort|egg|eight|either|elbow|elder|electric|elegant|element|elephant|elevator|elite|else|embark|embody|embrace|emerge|emotion|employ|empower|empty|enable|enact|end|endless|endorse|enemy|energy|enforce|engage|engine|enhance|enjoy|enlist|enough|enrich|enroll|ensure|enter|entire|entry|envelope|episode|equal|equip|era|erase|erode|erosion|error|erupt|escape|essay|essence|estate|eternal|ethics|evidence|evil|evoke|evolve|exact|example|excess|exchange|excite|exclude|excuse|execute|exercise|exhaust|exhibit|exile|exist|exit|exotic|expand|expect|expire|explain|expose|express|extend|extra|eye|eyebrow|fabric|face|faculty|fade|faint|faith|fall|false|fame|family|famous|fan|fancy|fantasy|farm|fashion|fat|fatal|father|fatigue|fault|favorite|feature|february|federal|fee|feed|feel|female|fence|festival|fetch|fever|few|fiber|fiction|field|figure|file|film|filter|final|find|fine|finger|finish|fire|firm|first|fiscal|fish|fit|fitness|fix|flag|flame|flash|flat|flavor|flee|flight|flip|float|flock|floor|flower|fluid|flush|fly|foam|focus|fog|foil|fold|follow|food|foot|force|forest|forget|fork|fortune|forum|forward|fossil|foster|found|fox|fragile|frame|frequent|fresh|friend|fringe|frog|front|frost|frown|frozen|fruit|fuel|fun|funny|furnace|fury|future|gadget|gain|galaxy|gallery|game|gap|garage|garbage|garden|garlic|garment|gas|gasp|gate|gather|gauge|gaze|general|genius|genre|gentle|genuine|gesture|ghost|giant|gift|giggle|ginger|giraffe|girl|give|glad|glance|glare|glass|glide|glimpse|globe|gloom|glory|glove|glow|glue|goat|goddess|gold|good|goose|gorilla|gospel|gossip|govern|gown|grab|grace|grain|grant|grape|grass|gravity|great|green|grid|grief|grit|grocery|group|grow|grunt|guard|guess|guide|guilt|guitar|gun|gym|habit|hair|half|hammer|hamster|hand|happy|harbor|hard|harsh|harvest|hat|have|hawk|hazard|head|health|heart|heavy|hedgehog|height|hello|helmet|help|hen|hero|hidden|high|hill|hint|hip|hire|history|hobby|hockey|hold|hole|holiday|hollow|home|honey|hood|hope|horn|horror|horse|hospital|host|hotel|hour|hover|hub|huge|human|humble|humor|hundred|hungry|hunt|hurdle|hurry|hurt|husband|hybrid|ice|icon|idea|identify|idle|ignore|ill|illegal|illness|image|imitate|immense|immune|impact|impose|improve|impulse|inch|include|income|increase|index|indicate|indoor|industry|infant|inflict|inform|inhale|inherit|initial|inject|injury|inmate|inner|innocent|input|inquiry|insane|insect|inside|inspire|install|intact|interest|into|invest|invite|involve|iron|island|isolate|issue|item|ivory|jacket|jaguar|jar|jazz|jealous|jeans|jelly|jewel|job|join|joke|journey|joy|judge|juice|jump|jungle|junior|junk|just|kangaroo|keen|keep|ketchup|key|kick|kid|kidney|kind|kingdom|kiss|kit|kitchen|kite|kitten|kiwi|knee|knife|knock|know|lab|label|labor|ladder|lady|lake|lamp|language|laptop|large|later|latin|laugh|laundry|lava|law|lawn|lawsuit|layer|lazy|leader|leaf|learn|leave|lecture|left|leg|legal|legend|leisure|lemon|lend|length|lens|leopard|lesson|letter|level|liar|liberty|library|license|life|lift|light|like|limb|limit|link|lion|liquid|list|little|live|lizard|load|loan|lobster|local|lock|logic|lonely|long|loop|lottery|loud|lounge|love|loyal|lucky|luggage|lumber|lunar|lunch|luxury|lyrics|machine|mad|magic|magnet|maid|mail|main|major|make|mammal|man|manage|mandate|mango|mansion|manual|maple|marble|march|margin|marine|market|marriage|mask|mass|master|match|material|math|matrix|matter|maximum|maze|meadow|mean|measure|meat|mechanic|medal|media|melody|melt|member|memory|mention|menu|mercy|merge|merit|merry|mesh|message|metal|method|middle|midnight|milk|million|mimic|mind|minimum|minor|minute|miracle|mirror|misery|miss|mistake|mix|mixed|mixture|mobile|model|modify|mom|moment|monitor|monkey|monster|month|moon|moral|more|morning|mosquito|mother|motion|motor|mountain|mouse|move|movie|much|muffin|mule|multiply|muscle|museum|mushroom|music|must|mutual|myself|mystery|myth|naive|name|napkin|narrow|nasty|nation|nature|near|neck|need|negative|neglect|neither|nephew|nerve|nest|net|network|neutral|never|news|next|nice|night|noble|noise|nominee|noodle|normal|north|nose|notable|note|nothing|notice|novel|now|nuclear|number|nurse|nut|oak|obey|object|oblige|obscure|observe|obtain|obvious|occur|ocean|october|odor|off|offer|office|often|oil|okay|old|olive|olympic|omit|once|one|onion|online|only|open|opera|opinion|oppose|option|orange|orbit|orchard|order|ordinary|organ|orient|original|orphan|ostrich|other|outdoor|outer|output|outside|oval|oven|over|own|owner|oxygen|oyster|ozone|pact|paddle|page|pair|palace|palm|panda|panel|panic|panther|paper|parade|parent|park|parrot|party|pass|patch|path|patient|patrol|pattern|pause|pave|payment|peace|peanut|pear|peasant|pelican|pen|penalty|pencil|people|pepper|perfect|permit|person|pet|phone|photo|phrase|physical|piano|picnic|picture|piece|pig|pigeon|pill|pilot|pink|pioneer|pipe|pistol|pitch|pizza|place|planet|plastic|plate|play|please|pledge|pluck|plug|plunge|poem|poet|point|polar|pole|police|pond|pony|pool|popular|portion|position|possible|post|potato|pottery|poverty|powder|power|practice|praise|predict|prefer|prepare|present|pretty|prevent|price|pride|primary|print|priority|prison|private|prize|problem|process|produce|profit|program|project|promote|proof|property|prosper|protect|proud|provide|public|pudding|pull|pulp|pulse|pumpkin|punch|pupil|puppy|purchase|purity|purpose|purse|push|put|puzzle|pyramid|quality|quantum|quarter|question|quick|quit|quiz|quote|rabbit|raccoon|race|rack|radar|radio|rail|rain|raise|rally|ramp|ranch|random|range|rapid|rare|rate|rather|raven|raw|razor|ready|real|reason|rebel|rebuild|recall|receive|recipe|record|recycle|reduce|reflect|reform|refuse|region|regret|regular|reject|relax|release|relief|rely|remain|remember|remind|remove|render|renew|rent|reopen|repair|repeat|replace|report|require|rescue|resemble|resist|resource|response|result|retire|retreat|return|reunion|reveal|review|reward|rhythm|rib|ribbon|rice|rich|ride|ridge|rifle|right|rigid|ring|riot|ripple|risk|ritual|rival|river|road|roast|robot|robust|rocket|romance|roof|rookie|room|rose|rotate|rough|round|route|royal|rubber|rude|rug|rule|run|runway|rural|sad|saddle|sadness|safe|sail|salad|salmon|salon|salt|salute|same|sample|sand|satisfy|satoshi|sauce|sausage|save|say|scale|scan|scare|scatter|scene|scheme|school|science|scissors|scorpion|scout|scrap|screen|script|scrub|sea|search|season|seat|second|secret|section|security|seed|seek|segment|select|sell|seminar|senior|sense|sentence|series|service|session|settle|setup|seven|shadow|shaft|shallow|share|shed|shell|sheriff|shield|shift|shine|ship|shiver|shock|shoe|shoot|shop|short|shoulder|shove|shrimp|shrug|shuffle|shy|sibling|sick|side|siege|sight|sign|silent|silk|silly|silver|similar|simple|since|sing|siren|sister|situate|six|size|skate|sketch|ski|skill|skin|skirt|skull|slab|slam|sleep|slender|slice|slide|slight|slim|slogan|slot|slow|slush|small|smart|smile|smoke|smooth|snack|snake|snap|sniff|snow|soap|soccer|social|sock|soda|soft|solar|soldier|solid|solution|solve|someone|song|soon|sorry|sort|soul|sound|soup|source|south|space|spare|spatial|spawn|speak|special|speed|spell|spend|sphere|spice|spider|spike|spin|spirit|split|spoil|sponsor|spoon|sport|spot|spray|spread|spring|spy|square|squeeze|squirrel|stable|stadium|staff|stage|stairs|stamp|stand|start|state|stay|steak|steel|stem|step|stereo|stick|still|sting|stock|stomach|stone|stool|story|stove|strategy|street|strike|strong|struggle|student|stuff|stumble|style|subject|submit|subway|success|such|sudden|suffer|sugar|suggest|suit|summer|sun|sunny|sunset|super|supply|supreme|sure|surface|surge|surprise|surround|survey|suspect|sustain|swallow|swamp|swap|swarm|swear|sweet|swift|swim|swing|switch|sword|symbol|symptom|syrup|system|table|tackle|tag|tail|talent|talk|tank|tape|target|task|taste|tattoo|taxi|teach|team|tell|ten|tenant|tennis|tent|term|test|text|thank|that|theme|then|theory|there|they|thing|this|thought|three|thrive|throw|thumb|thunder|ticket|tide|tiger|tilt|timber|time|tiny|tip|tired|tissue|title|toast|tobacco|today|toddler|toe|together|toilet|token|tomato|tomorrow|tone|tongue|tonight|tool|tooth|top|topic|topple|torch|tornado|tortoise|toss|total|tourist|toward|tower|town|toy|track|trade|traffic|tragic|train|transfer|trap|trash|travel|tray|treat|tree|trend|trial|tribe|trick|trigger|trim|trip|trophy|trouble|truck|true|truly|trumpet|trust|truth|try|tube|tuition|tumble|tuna|tunnel|turkey|turn|turtle|twelve|twenty|twice|twin|twist|two|type|typical|ugly|umbrella|unable|unaware|uncle|uncover|under|undo|unfair|unfold|unhappy|uniform|unique|unit|universe|unknown|unlock|until|unusual|unveil|update|upgrade|uphold|upon|upper|upset|urban|urge|usage|use|used|useful|useless|usual|utility|vacant|vacuum|vague|valid|valley|valve|van|vanish|vapor|various|vast|vault|vehicle|velvet|vendor|venture|venue|verb|verify|version|very|vessel|veteran|viable|vibrant|vicious|victory|video|view|village|vintage|violin|virtual|virus|visa|visit|visual|vital|vivid|vocal|voice|void|volcano|volume|vote|voyage|wage|wagon|wait|walk|wall|walnut|want|warfare|warm|warrior|wash|wasp|waste|water|wave|way|wealth|weapon|wear|weasel|weather|web|wedding|weekend|weird|welcome|west|wet|whale|what|wheat|wheel|when|where|whip|whisper|wide|width|wife|wild|will|win|window|wine|wing|wink|winner|winter|wire|wisdom|wise|wish|witness|wolf|woman|wonder|wood|wool|word|work|world|worry|worth|wrap|wreck|wrestle|wrist|write|wrong|yard|year|yellow|you|young|youth|zebra|zero|zone|zoo".split("|");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/mnemonic/toEntropy.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/mnemonic/toLegacySeed.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/mnemonic/validate.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/mnemonic/toMiniSecret.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/hd/ledger/derivePrivate.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/hd/ledger/master.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/json/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/json/decrypt.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/json/decryptData.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/nacl/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/nacl/decrypt.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/nacl/tweetnacl.js
init_shim();
var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
var minusp = new Uint32Array([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252]);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/nacl/encrypt.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/scrypt/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/scrypt/encode.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/node_modules/@noble/hashes/esm/scrypt.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/scrypt/defaults.js
init_shim();
var DEFAULT_PARAMS = {
  N: 1 << 15,
  p: 1,
  r: 8
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/scrypt/fromU8a.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/scrypt/toU8a.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/json/constants.js
init_shim();
var SCRYPT_LENGTH = 32 + 3 * 4;

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/json/encrypt.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/json/encryptFormat.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/signature/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/signature/verify.js
init_shim();
var secp256k1VerifyHasher = (hashType) => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType);
var VERIFIERS_ECDSA = [
  ["ecdsa", secp256k1VerifyHasher("blake2")],
  ["ethereum", secp256k1VerifyHasher("keccak")]
];
var VERIFIERS = [
  ["ed25519", ed25519Verify2],
  ["sr25519", sr25519Verify2],
  ...VERIFIERS_ECDSA
];

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/xxhash/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/xxhash/asU8a.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/xxhash/xxhash64.js
init_shim();
var P64_1 = BigInt3("11400714785074694791");
var P64_2 = BigInt3("14029467366897019727");
var P64_3 = BigInt3("1609587929392839161");
var P64_4 = BigInt3("9650029242287828579");
var P64_5 = BigInt3("2870177450012600261");
var U64 = BigInt3("0xffffffffffffffff");
var _7n3 = BigInt3(7);
var _11n = BigInt3(11);
var _12n = BigInt3(12);
var _16n2 = BigInt3(16);
var _18n = BigInt3(18);
var _23n = BigInt3(23);
var _27n = BigInt3(27);
var _29n = BigInt3(29);
var _31n = BigInt3(31);
var _32n2 = BigInt3(32);
var _33n = BigInt3(33);
var _64n = BigInt3(64);
var _256n2 = BigInt3(256);
function rotl(a3, b3) {
  const c3 = a3 & U64;
  return (c3 << b3 | c3 >> _64n - b3) & U64;
}
function fromU8a(u8a3, p2, count) {
  const bigints = new Array(count);
  let offset = 0;
  for (let i3 = 0; i3 < count; i3++, offset += 2) {
    bigints[i3] = BigInt3(u8a3[p2 + offset] | u8a3[p2 + 1 + offset] << 8);
  }
  let result = _0n;
  for (let i3 = count - 1; i3 >= 0; i3--) {
    result = (result << _16n2) + bigints[i3];
  }
  return result;
}
function init(seed, input) {
  const state = {
    seed,
    u8a: new Uint8Array(32),
    u8asize: 0,
    v1: seed + P64_1 + P64_2,
    v2: seed + P64_2,
    v3: seed,
    v4: seed - P64_1
  };
  if (input.length < 32) {
    state.u8a.set(input);
    state.u8asize = input.length;
    return state;
  }
  const limit = input.length - 32;
  let p2 = 0;
  if (limit >= 0) {
    const adjustV = (v3) => P64_1 * rotl(v3 + P64_2 * fromU8a(input, p2, 4), _31n);
    do {
      state.v1 = adjustV(state.v1);
      p2 += 8;
      state.v2 = adjustV(state.v2);
      p2 += 8;
      state.v3 = adjustV(state.v3);
      p2 += 8;
      state.v4 = adjustV(state.v4);
      p2 += 8;
    } while (p2 <= limit);
  }
  if (p2 < input.length) {
    state.u8a.set(input.subarray(p2, input.length));
    state.u8asize = input.length - p2;
  }
  return state;
}
function xxhash64(input, initSeed) {
  const { seed, u8a: u8a3, u8asize, v1, v2: v22, v3, v4: v42 } = init(BigInt3(initSeed), input);
  let p2 = 0;
  let h64 = U64 & BigInt3(input.length) + (input.length >= 32 ? ((((rotl(v1, _1n) + rotl(v22, _7n3) + rotl(v3, _12n) + rotl(v42, _18n) ^ P64_1 * rotl(v1 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v22 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v3 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v42 * P64_2, _31n)) * P64_1 + P64_4 : seed + P64_5);
  while (p2 <= u8asize - 8) {
    h64 = U64 & P64_4 + P64_1 * rotl(h64 ^ P64_1 * rotl(P64_2 * fromU8a(u8a3, p2, 4), _31n), _27n);
    p2 += 8;
  }
  if (p2 + 4 <= u8asize) {
    h64 = U64 & P64_3 + P64_2 * rotl(h64 ^ P64_1 * fromU8a(u8a3, p2, 2), _23n);
    p2 += 4;
  }
  while (p2 < u8asize) {
    h64 = U64 & P64_1 * rotl(h64 ^ P64_5 * BigInt3(u8a3[p2++]), _11n);
  }
  h64 = U64 & P64_2 * (h64 ^ h64 >> _33n);
  h64 = U64 & P64_3 * (h64 ^ h64 >> _29n);
  h64 = U64 & (h64 ^ h64 >> _32n2);
  const result = new Uint8Array(8);
  for (let i3 = 7; i3 >= 0; i3--) {
    result[i3] = Number(h64 % _256n2);
    h64 = h64 / _256n2;
  }
  return result;
}

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/util-crypto/xxhash/asU8a.js
function xxhashAsU8a(data, bitLength = 64, onlyJs) {
  const rounds = Math.ceil(bitLength / 64);
  const u8a3 = u8aToU8a(data);
  if (!hasBigInt || !onlyJs && isReady()) {
    return twox(u8a3, rounds);
  }
  const result = new Uint8Array(rounds * 8);
  for (let seed = 0; seed < rounds; seed++) {
    result.set(xxhash64(u8a3, seed).reverse(), seed * 8);
  }
  return result;
}
var xxhashAsHex = createAsHex(xxhashAsU8a);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-shared/icons/polkadot.js
var S = 64;
var C = S / 2;
var Z = S / 64 * 5;
var SCHEMES = [
  /* target  */
  { colors: [0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 1], freq: 1 },
  /* cube    */
  { colors: [0, 1, 3, 2, 4, 3, 0, 1, 3, 2, 4, 3, 0, 1, 3, 2, 4, 3, 5], freq: 20 },
  /* quazar  */
  { colors: [1, 2, 3, 1, 2, 4, 5, 5, 4, 1, 2, 3, 1, 2, 4, 5, 5, 4, 0], freq: 16 },
  /* flower  */
  { colors: [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 3], freq: 32 },
  /* cyclic  */
  { colors: [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6], freq: 32 },
  /* vmirror */
  { colors: [0, 1, 2, 3, 4, 5, 3, 4, 2, 0, 1, 6, 7, 8, 9, 7, 8, 6, 10], freq: 128 },
  /* hmirror */
  { colors: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 8, 6, 7, 5, 3, 4, 2, 11], freq: 128 }
];
var SCHEMES_TOTAL = SCHEMES.map((s3) => s3.freq).reduce((a3, b3) => a3 + b3);
var OUTER_CIRCLE = {
  cx: C,
  cy: C,
  fill: "#eee",
  r: C
};
var zeroHash = new Uint8Array();
function getRotation(isSixPoint) {
  const r3 = isSixPoint ? C / 8 * 5 : C / 4 * 3;
  const rroot3o2 = r3 * Math.sqrt(3) / 2;
  const ro2 = r3 / 2;
  const rroot3o4 = r3 * Math.sqrt(3) / 4;
  const ro4 = r3 / 4;
  const r3o4 = r3 * 3 / 4;
  return { r: r3, r3o4, ro2, ro4, rroot3o2, rroot3o4 };
}
function getCircleXY(isSixPoint = false) {
  const { r: r3, r3o4, ro2, ro4, rroot3o2, rroot3o4 } = getRotation(isSixPoint);
  return [
    [C, C - r3],
    [C, C - ro2],
    [C - rroot3o4, C - r3o4],
    [C - rroot3o2, C - ro2],
    [C - rroot3o4, C - ro4],
    [C - rroot3o2, C],
    [C - rroot3o2, C + ro2],
    [C - rroot3o4, C + ro4],
    [C - rroot3o4, C + r3o4],
    [C, C + r3],
    [C, C + ro2],
    [C + rroot3o4, C + r3o4],
    [C + rroot3o2, C + ro2],
    [C + rroot3o4, C + ro4],
    [C + rroot3o2, C],
    [C + rroot3o2, C - ro2],
    [C + rroot3o4, C - ro4],
    [C + rroot3o4, C - r3o4],
    [C, C]
  ];
}
function findScheme(d3) {
  let cum = 0;
  const schema = SCHEMES.find((schema2) => {
    cum += schema2.freq;
    return d3 < cum;
  });
  if (!schema) {
    throw new Error("Unable to find schema");
  }
  return schema;
}
function addressToId(address) {
  if (!zeroHash.length) {
    zeroHash = blake2AsU8a(new Uint8Array(32), 512);
  }
  return blake2AsU8a(decodeAddress(address), 512).map((x3, i3) => (x3 + 256 - zeroHash[i3]) % 256);
}
function getColors(address) {
  const id = addressToId(address);
  const d3 = Math.floor((id[30] + id[31] * 256) % SCHEMES_TOTAL);
  const rot = id[28] % 6 * 3;
  const sat = Math.floor(id[29] * 70 / 256 + 26) % 80 + 30;
  const scheme = findScheme(d3);
  const palette = Array.from(id).map((x3, i3) => {
    const b3 = (x3 + i3 % 28 * 58) % 256;
    if (b3 === 0) {
      return "#444";
    } else if (b3 === 255) {
      return "transparent";
    }
    const h2 = Math.floor(b3 % 64 * 360 / 64);
    const l4 = [53, 15, 35, 75][Math.floor(b3 / 64)];
    return `hsl(${h2}, ${sat}%, ${l4}%)`;
  });
  return scheme.colors.map((_2, i3) => palette[scheme.colors[i3 < 18 ? (i3 + rot) % 18 : 18]]);
}
function polkadotIcon(address, { isAlternative }) {
  const xy = getCircleXY(isAlternative);
  let colors2;
  try {
    colors2 = getColors(address);
  } catch {
    colors2 = new Array(xy.length).fill("#ddd");
  }
  return [OUTER_CIRCLE].concat(xy.map(([cx, cy], index) => ({
    cx,
    cy,
    fill: colors2[index],
    r: Z
  })));
}

// node_modules/@polkadot/react-identicon/icons/Beachball.js
function Identicon({ address, className = "", size, style = {} }) {
  const updateElem = (0, import_react.useCallback)((node) => {
    node && node.appendChild(beachballIcon(address, { isAlternative: false, size }));
  }, [address, size]);
  return (0, import_jsx_runtime.jsx)("div", { className, ref: updateElem, style });
}
var Beachball = import_react.default.memo(Identicon);

// node_modules/@polkadot/react-identicon/icons/Empty.js
init_shim();
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
function Identicon2({ className = "", size, style = {} }) {
  return (0, import_jsx_runtime2.jsx)("svg", { className, height: size, style, viewBox: "0 0 64 64", width: size });
}
var Empty = import_react2.default.memo(Identicon2);

// node_modules/@polkadot/react-identicon/icons/Ethereum.js
init_shim();
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_ethereum_blockies_base64 = __toESM(require_main(), 1);
var import_react4 = __toESM(require_react(), 1);

// node_modules/@polkadot/react-identicon/styled.js
init_shim();

// node_modules/styled-components/dist/styled-components.browser.esm.js
init_shim();
var import_react_is = __toESM(require_react_is());
var import_react3 = __toESM(require_react());
var import_shallowequal = __toESM(require_shallowequal());

// node_modules/@emotion/stylis/dist/stylis.browser.esm.js
init_shim();
function stylis_min(W2) {
  function M3(d3, c3, e3, h2, a3) {
    for (var m3 = 0, b3 = 0, v3 = 0, n3 = 0, q2, g3, x3 = 0, K2 = 0, k2, u3 = k2 = q2 = 0, l4 = 0, r3 = 0, I2 = 0, t3 = 0, B3 = e3.length, J2 = B3 - 1, y3, f3 = "", p2 = "", F3 = "", G4 = "", C3; l4 < B3; ) {
      g3 = e3.charCodeAt(l4);
      l4 === J2 && 0 !== b3 + n3 + v3 + m3 && (0 !== b3 && (g3 = 47 === b3 ? 10 : 47), n3 = v3 = m3 = 0, B3++, J2++);
      if (0 === b3 + n3 + v3 + m3) {
        if (l4 === J2 && (0 < r3 && (f3 = f3.replace(N4, "")), 0 < f3.trim().length)) {
          switch (g3) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              f3 += e3.charAt(l4);
          }
          g3 = 59;
        }
        switch (g3) {
          case 123:
            f3 = f3.trim();
            q2 = f3.charCodeAt(0);
            k2 = 1;
            for (t3 = ++l4; l4 < B3; ) {
              switch (g3 = e3.charCodeAt(l4)) {
                case 123:
                  k2++;
                  break;
                case 125:
                  k2--;
                  break;
                case 47:
                  switch (g3 = e3.charCodeAt(l4 + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u3 = l4 + 1; u3 < J2; ++u3) {
                          switch (e3.charCodeAt(u3)) {
                            case 47:
                              if (42 === g3 && 42 === e3.charCodeAt(u3 - 1) && l4 + 2 !== u3) {
                                l4 = u3 + 1;
                                break a;
                              }
                              break;
                            case 10:
                              if (47 === g3) {
                                l4 = u3 + 1;
                                break a;
                              }
                          }
                        }
                        l4 = u3;
                      }
                  }
                  break;
                case 91:
                  g3++;
                case 40:
                  g3++;
                case 34:
                case 39:
                  for (; l4++ < J2 && e3.charCodeAt(l4) !== g3; ) {
                  }
              }
              if (0 === k2)
                break;
              l4++;
            }
            k2 = e3.substring(t3, l4);
            0 === q2 && (q2 = (f3 = f3.replace(ca, "").trim()).charCodeAt(0));
            switch (q2) {
              case 64:
                0 < r3 && (f3 = f3.replace(N4, ""));
                g3 = f3.charCodeAt(1);
                switch (g3) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r3 = c3;
                    break;
                  default:
                    r3 = O2;
                }
                k2 = M3(c3, r3, k2, g3, a3 + 1);
                t3 = k2.length;
                0 < A && (r3 = X2(O2, f3, I2), C3 = H3(3, k2, r3, c3, D2, z2, t3, g3, a3, h2), f3 = r3.join(""), void 0 !== C3 && 0 === (t3 = (k2 = C3.trim()).length) && (g3 = 0, k2 = ""));
                if (0 < t3)
                  switch (g3) {
                    case 115:
                      f3 = f3.replace(da, ea);
                    case 100:
                    case 109:
                    case 45:
                      k2 = f3 + "{" + k2 + "}";
                      break;
                    case 107:
                      f3 = f3.replace(fa, "$1 $2");
                      k2 = f3 + "{" + k2 + "}";
                      k2 = 1 === w3 || 2 === w3 && L2("@" + k2, 3) ? "@-webkit-" + k2 + "@" + k2 : "@" + k2;
                      break;
                    default:
                      k2 = f3 + k2, 112 === h2 && (k2 = (p2 += k2, ""));
                  }
                else
                  k2 = "";
                break;
              default:
                k2 = M3(c3, X2(c3, f3, I2), k2, h2, a3 + 1);
            }
            F3 += k2;
            k2 = I2 = r3 = u3 = q2 = 0;
            f3 = "";
            g3 = e3.charCodeAt(++l4);
            break;
          case 125:
          case 59:
            f3 = (0 < r3 ? f3.replace(N4, "") : f3).trim();
            if (1 < (t3 = f3.length))
              switch (0 === u3 && (q2 = f3.charCodeAt(0), 45 === q2 || 96 < q2 && 123 > q2) && (t3 = (f3 = f3.replace(" ", ":")).length), 0 < A && void 0 !== (C3 = H3(1, f3, c3, d3, D2, z2, p2.length, h2, a3, h2)) && 0 === (t3 = (f3 = C3.trim()).length) && (f3 = "\0\0"), q2 = f3.charCodeAt(0), g3 = f3.charCodeAt(1), q2) {
                case 0:
                  break;
                case 64:
                  if (105 === g3 || 99 === g3) {
                    G4 += f3 + e3.charAt(l4);
                    break;
                  }
                default:
                  58 !== f3.charCodeAt(t3 - 1) && (p2 += P(f3, q2, g3, f3.charCodeAt(2)));
              }
            I2 = r3 = u3 = q2 = 0;
            f3 = "";
            g3 = e3.charCodeAt(++l4);
        }
      }
      switch (g3) {
        case 13:
        case 10:
          47 === b3 ? b3 = 0 : 0 === 1 + q2 && 107 !== h2 && 0 < f3.length && (r3 = 1, f3 += "\0");
          0 < A * Y2 && H3(0, f3, c3, d3, D2, z2, p2.length, h2, a3, h2);
          z2 = 1;
          D2++;
          break;
        case 59:
        case 125:
          if (0 === b3 + n3 + v3 + m3) {
            z2++;
            break;
          }
        default:
          z2++;
          y3 = e3.charAt(l4);
          switch (g3) {
            case 9:
            case 32:
              if (0 === n3 + m3 + b3)
                switch (x3) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    y3 = "";
                    break;
                  default:
                    32 !== g3 && (y3 = " ");
                }
              break;
            case 0:
              y3 = "\\0";
              break;
            case 12:
              y3 = "\\f";
              break;
            case 11:
              y3 = "\\v";
              break;
            case 38:
              0 === n3 + b3 + m3 && (r3 = I2 = 1, y3 = "\f" + y3);
              break;
            case 108:
              if (0 === n3 + b3 + m3 + E2 && 0 < u3)
                switch (l4 - u3) {
                  case 2:
                    112 === x3 && 58 === e3.charCodeAt(l4 - 3) && (E2 = x3);
                  case 8:
                    111 === K2 && (E2 = K2);
                }
              break;
            case 58:
              0 === n3 + b3 + m3 && (u3 = l4);
              break;
            case 44:
              0 === b3 + v3 + n3 + m3 && (r3 = 1, y3 += "\r");
              break;
            case 34:
            case 39:
              0 === b3 && (n3 = n3 === g3 ? 0 : 0 === n3 ? g3 : n3);
              break;
            case 91:
              0 === n3 + b3 + v3 && m3++;
              break;
            case 93:
              0 === n3 + b3 + v3 && m3--;
              break;
            case 41:
              0 === n3 + b3 + m3 && v3--;
              break;
            case 40:
              if (0 === n3 + b3 + m3) {
                if (0 === q2)
                  switch (2 * x3 + 3 * K2) {
                    case 533:
                      break;
                    default:
                      q2 = 1;
                  }
                v3++;
              }
              break;
            case 64:
              0 === b3 + v3 + n3 + m3 + u3 + k2 && (k2 = 1);
              break;
            case 42:
            case 47:
              if (!(0 < n3 + m3 + v3))
                switch (b3) {
                  case 0:
                    switch (2 * g3 + 3 * e3.charCodeAt(l4 + 1)) {
                      case 235:
                        b3 = 47;
                        break;
                      case 220:
                        t3 = l4, b3 = 42;
                    }
                    break;
                  case 42:
                    47 === g3 && 42 === x3 && t3 + 2 !== l4 && (33 === e3.charCodeAt(t3 + 2) && (p2 += e3.substring(t3, l4 + 1)), y3 = "", b3 = 0);
                }
          }
          0 === b3 && (f3 += y3);
      }
      K2 = x3;
      x3 = g3;
      l4++;
    }
    t3 = p2.length;
    if (0 < t3) {
      r3 = c3;
      if (0 < A && (C3 = H3(2, p2, r3, d3, D2, z2, t3, h2, a3, h2), void 0 !== C3 && 0 === (p2 = C3).length))
        return G4 + p2 + F3;
      p2 = r3.join(",") + "{" + p2 + "}";
      if (0 !== w3 * E2) {
        2 !== w3 || L2(p2, 2) || (E2 = 0);
        switch (E2) {
          case 111:
            p2 = p2.replace(ha, ":-moz-$1") + p2;
            break;
          case 112:
            p2 = p2.replace(Q2, "::-webkit-input-$1") + p2.replace(Q2, "::-moz-$1") + p2.replace(Q2, ":-ms-input-$1") + p2;
        }
        E2 = 0;
      }
    }
    return G4 + p2 + F3;
  }
  function X2(d3, c3, e3) {
    var h2 = c3.trim().split(ia);
    c3 = h2;
    var a3 = h2.length, m3 = d3.length;
    switch (m3) {
      case 0:
      case 1:
        var b3 = 0;
        for (d3 = 0 === m3 ? "" : d3[0] + " "; b3 < a3; ++b3) {
          c3[b3] = Z3(d3, c3[b3], e3).trim();
        }
        break;
      default:
        var v3 = b3 = 0;
        for (c3 = []; b3 < a3; ++b3) {
          for (var n3 = 0; n3 < m3; ++n3) {
            c3[v3++] = Z3(d3[n3] + " ", h2[b3], e3).trim();
          }
        }
    }
    return c3;
  }
  function Z3(d3, c3, e3) {
    var h2 = c3.charCodeAt(0);
    33 > h2 && (h2 = (c3 = c3.trim()).charCodeAt(0));
    switch (h2) {
      case 38:
        return c3.replace(F2, "$1" + d3.trim());
      case 58:
        return d3.trim() + c3.replace(F2, "$1" + d3.trim());
      default:
        if (0 < 1 * e3 && 0 < c3.indexOf("\f"))
          return c3.replace(F2, (58 === d3.charCodeAt(0) ? "" : "$1") + d3.trim());
    }
    return d3 + c3;
  }
  function P(d3, c3, e3, h2) {
    var a3 = d3 + ";", m3 = 2 * c3 + 3 * e3 + 4 * h2;
    if (944 === m3) {
      d3 = a3.indexOf(":", 9) + 1;
      var b3 = a3.substring(d3, a3.length - 1).trim();
      b3 = a3.substring(0, d3).trim() + b3 + ";";
      return 1 === w3 || 2 === w3 && L2(b3, 1) ? "-webkit-" + b3 + b3 : b3;
    }
    if (0 === w3 || 2 === w3 && !L2(a3, 1))
      return a3;
    switch (m3) {
      case 1015:
        return 97 === a3.charCodeAt(10) ? "-webkit-" + a3 + a3 : a3;
      case 951:
        return 116 === a3.charCodeAt(3) ? "-webkit-" + a3 + a3 : a3;
      case 963:
        return 110 === a3.charCodeAt(5) ? "-webkit-" + a3 + a3 : a3;
      case 1009:
        if (100 !== a3.charCodeAt(4))
          break;
      case 969:
      case 942:
        return "-webkit-" + a3 + a3;
      case 978:
        return "-webkit-" + a3 + "-moz-" + a3 + a3;
      case 1019:
      case 983:
        return "-webkit-" + a3 + "-moz-" + a3 + "-ms-" + a3 + a3;
      case 883:
        if (45 === a3.charCodeAt(8))
          return "-webkit-" + a3 + a3;
        if (0 < a3.indexOf("image-set(", 11))
          return a3.replace(ja, "$1-webkit-$2") + a3;
        break;
      case 932:
        if (45 === a3.charCodeAt(4))
          switch (a3.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + a3.replace("-grow", "") + "-webkit-" + a3 + "-ms-" + a3.replace("grow", "positive") + a3;
            case 115:
              return "-webkit-" + a3 + "-ms-" + a3.replace("shrink", "negative") + a3;
            case 98:
              return "-webkit-" + a3 + "-ms-" + a3.replace("basis", "preferred-size") + a3;
          }
        return "-webkit-" + a3 + "-ms-" + a3 + a3;
      case 964:
        return "-webkit-" + a3 + "-ms-flex-" + a3 + a3;
      case 1023:
        if (99 !== a3.charCodeAt(8))
          break;
        b3 = a3.substring(a3.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify");
        return "-webkit-box-pack" + b3 + "-webkit-" + a3 + "-ms-flex-pack" + b3 + a3;
      case 1005:
        return ka.test(a3) ? a3.replace(aa, ":-webkit-") + a3.replace(aa, ":-moz-") + a3 : a3;
      case 1e3:
        b3 = a3.substring(13).trim();
        c3 = b3.indexOf("-") + 1;
        switch (b3.charCodeAt(0) + b3.charCodeAt(c3)) {
          case 226:
            b3 = a3.replace(G3, "tb");
            break;
          case 232:
            b3 = a3.replace(G3, "tb-rl");
            break;
          case 220:
            b3 = a3.replace(G3, "lr");
            break;
          default:
            return a3;
        }
        return "-webkit-" + a3 + "-ms-" + b3 + a3;
      case 1017:
        if (-1 === a3.indexOf("sticky", 9))
          break;
      case 975:
        c3 = (a3 = d3).length - 10;
        b3 = (33 === a3.charCodeAt(c3) ? a3.substring(0, c3) : a3).substring(d3.indexOf(":", 7) + 1).trim();
        switch (m3 = b3.charCodeAt(0) + (b3.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b3.charCodeAt(8))
              break;
          case 115:
            a3 = a3.replace(b3, "-webkit-" + b3) + ";" + a3;
            break;
          case 207:
          case 102:
            a3 = a3.replace(b3, "-webkit-" + (102 < m3 ? "inline-" : "") + "box") + ";" + a3.replace(b3, "-webkit-" + b3) + ";" + a3.replace(b3, "-ms-" + b3 + "box") + ";" + a3;
        }
        return a3 + ";";
      case 938:
        if (45 === a3.charCodeAt(5))
          switch (a3.charCodeAt(6)) {
            case 105:
              return b3 = a3.replace("-items", ""), "-webkit-" + a3 + "-webkit-box-" + b3 + "-ms-flex-" + b3 + a3;
            case 115:
              return "-webkit-" + a3 + "-ms-flex-item-" + a3.replace(ba, "") + a3;
            default:
              return "-webkit-" + a3 + "-ms-flex-line-pack" + a3.replace("align-content", "").replace(ba, "") + a3;
          }
        break;
      case 973:
      case 989:
        if (45 !== a3.charCodeAt(3) || 122 === a3.charCodeAt(4))
          break;
      case 931:
      case 953:
        if (true === la.test(d3))
          return 115 === (b3 = d3.substring(d3.indexOf(":") + 1)).charCodeAt(0) ? P(d3.replace("stretch", "fill-available"), c3, e3, h2).replace(":fill-available", ":stretch") : a3.replace(b3, "-webkit-" + b3) + a3.replace(b3, "-moz-" + b3.replace("fill-", "")) + a3;
        break;
      case 962:
        if (a3 = "-webkit-" + a3 + (102 === a3.charCodeAt(5) ? "-ms-" + a3 : "") + a3, 211 === e3 + h2 && 105 === a3.charCodeAt(13) && 0 < a3.indexOf("transform", 10))
          return a3.substring(0, a3.indexOf(";", 27) + 1).replace(ma, "$1-webkit-$2") + a3;
    }
    return a3;
  }
  function L2(d3, c3) {
    var e3 = d3.indexOf(1 === c3 ? ":" : "{"), h2 = d3.substring(0, 3 !== c3 ? e3 : 10);
    e3 = d3.substring(e3 + 1, d3.length - 1);
    return R2(2 !== c3 ? h2 : h2.replace(na, "$1"), e3, c3);
  }
  function ea(d3, c3) {
    var e3 = P(c3, c3.charCodeAt(0), c3.charCodeAt(1), c3.charCodeAt(2));
    return e3 !== c3 + ";" ? e3.replace(oa, " or ($1)").substring(4) : "(" + c3 + ")";
  }
  function H3(d3, c3, e3, h2, a3, m3, b3, v3, n3, q2) {
    for (var g3 = 0, x3 = c3, w4; g3 < A; ++g3) {
      switch (w4 = S3[g3].call(B2, d3, x3, e3, h2, a3, m3, b3, v3, n3, q2)) {
        case void 0:
        case false:
        case true:
        case null:
          break;
        default:
          x3 = w4;
      }
    }
    if (x3 !== c3)
      return x3;
  }
  function T2(d3) {
    switch (d3) {
      case void 0:
      case null:
        A = S3.length = 0;
        break;
      default:
        if ("function" === typeof d3)
          S3[A++] = d3;
        else if ("object" === typeof d3)
          for (var c3 = 0, e3 = d3.length; c3 < e3; ++c3) {
            T2(d3[c3]);
          }
        else
          Y2 = !!d3 | 0;
    }
    return T2;
  }
  function U2(d3) {
    d3 = d3.prefix;
    void 0 !== d3 && (R2 = null, d3 ? "function" !== typeof d3 ? w3 = 1 : (w3 = 2, R2 = d3) : w3 = 0);
    return U2;
  }
  function B2(d3, c3) {
    var e3 = d3;
    33 > e3.charCodeAt(0) && (e3 = e3.trim());
    V2 = e3;
    e3 = [V2];
    if (0 < A) {
      var h2 = H3(-1, c3, e3, e3, D2, z2, 0, 0, 0, 0);
      void 0 !== h2 && "string" === typeof h2 && (c3 = h2);
    }
    var a3 = M3(O2, e3, c3, 0, 0);
    0 < A && (h2 = H3(-2, a3, e3, e3, D2, z2, a3.length, 0, 0, 0), void 0 !== h2 && (a3 = h2));
    V2 = "";
    E2 = 0;
    z2 = D2 = 1;
    return a3;
  }
  var ca = /^\0+/g, N4 = /[\0\r\f]/g, aa = /: */g, ka = /zoo|gra/, ma = /([,: ])(transform)/g, ia = /,\r+?/g, F2 = /([\t\r\n ])*\f?&/g, fa = /@(k\w+)\s*(\S*)\s*/, Q2 = /::(place)/g, ha = /:(read-only)/g, G3 = /[svh]\w+-[tblr]{2}/, da = /\(\s*(.*)\s*\)/g, oa = /([\s\S]*?);/g, ba = /-self|flex-/g, na = /[^]*?(:[rp][el]a[\w-]+)[^]*/, la = /stretch|:\s*\w+\-(?:conte|avail)/, ja = /([^-])(image-set\()/, z2 = 1, D2 = 1, E2 = 0, w3 = 1, O2 = [], S3 = [], A = 0, R2 = null, Y2 = 0, V2 = "";
  B2.use = T2;
  B2.set = U2;
  void 0 !== W2 && U2(W2);
  return B2;
}
var stylis_browser_esm_default = stylis_min;

// node_modules/@emotion/unitless/dist/unitless.browser.esm.js
init_shim();
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var unitless_browser_esm_default = unitlessKeys;

// node_modules/styled-components/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
init_shim();
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);

// node_modules/styled-components/dist/styled-components.browser.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
function y2() {
  return (y2 = Object.assign || function(e3) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var n3 = arguments[t3];
      for (var r3 in n3)
        Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
    }
    return e3;
  }).apply(this, arguments);
}
var v2 = function(e3, t3) {
  for (var n3 = [e3[0]], r3 = 0, o3 = t3.length; r3 < o3; r3 += 1)
    n3.push(t3[r3], e3[r3 + 1]);
  return n3;
};
var g2 = function(t3) {
  return null !== t3 && "object" == typeof t3 && "[object Object]" === (t3.toString ? t3.toString() : Object.prototype.toString.call(t3)) && !(0, import_react_is.typeOf)(t3);
};
var S2 = Object.freeze([]);
var w2 = Object.freeze({});
function E(e3) {
  return "function" == typeof e3;
}
function b2(e3) {
  return "production" !== import_process.default.env.NODE_ENV && "string" == typeof e3 && e3 || e3.displayName || e3.name || "Component";
}
function _(e3) {
  return e3 && "string" == typeof e3.styledComponentId;
}
var N3 = "undefined" != typeof import_process.default && void 0 !== import_process.default.env && (import_process.default.env.REACT_APP_SC_ATTR || import_process.default.env.SC_ATTR) || "data-styled";
var C2 = "undefined" != typeof window && "HTMLElement" in window;
var I = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof import_process.default && void 0 !== import_process.default.env && (void 0 !== import_process.default.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== import_process.default.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== import_process.default.env.REACT_APP_SC_DISABLE_SPEEDY && import_process.default.env.REACT_APP_SC_DISABLE_SPEEDY : void 0 !== import_process.default.env.SC_DISABLE_SPEEDY && "" !== import_process.default.env.SC_DISABLE_SPEEDY ? "false" !== import_process.default.env.SC_DISABLE_SPEEDY && import_process.default.env.SC_DISABLE_SPEEDY : "production" !== import_process.default.env.NODE_ENV));
var O = "production" !== import_process.default.env.NODE_ENV ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n" } : {};
function R() {
  for (var e3 = arguments.length <= 0 ? void 0 : arguments[0], t3 = [], n3 = 1, r3 = arguments.length; n3 < r3; n3 += 1)
    t3.push(n3 < 0 || arguments.length <= n3 ? void 0 : arguments[n3]);
  return t3.forEach(function(t4) {
    e3 = e3.replace(/%[a-z]/, t4);
  }), e3;
}
function D(e3) {
  for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n3[r3 - 1] = arguments[r3];
  throw "production" === import_process.default.env.NODE_ENV ? new Error("An error occurred. See https://git.io/JUIaE#" + e3 + " for more information." + (n3.length > 0 ? " Args: " + n3.join(", ") : "")) : new Error(R.apply(void 0, [O[e3]].concat(n3)).trim());
}
var j3 = function() {
  function e3(e4) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e4;
  }
  var t3 = e3.prototype;
  return t3.indexOfGroup = function(e4) {
    for (var t4 = 0, n3 = 0; n3 < e4; n3++)
      t4 += this.groupSizes[n3];
    return t4;
  }, t3.insertRules = function(e4, t4) {
    if (e4 >= this.groupSizes.length) {
      for (var n3 = this.groupSizes, r3 = n3.length, o3 = r3; e4 >= o3; )
        (o3 <<= 1) < 0 && D(16, "" + e4);
      this.groupSizes = new Uint32Array(o3), this.groupSizes.set(n3), this.length = o3;
      for (var s3 = r3; s3 < o3; s3++)
        this.groupSizes[s3] = 0;
    }
    for (var i3 = this.indexOfGroup(e4 + 1), a3 = 0, c3 = t4.length; a3 < c3; a3++)
      this.tag.insertRule(i3, t4[a3]) && (this.groupSizes[e4]++, i3++);
  }, t3.clearGroup = function(e4) {
    if (e4 < this.length) {
      var t4 = this.groupSizes[e4], n3 = this.indexOfGroup(e4), r3 = n3 + t4;
      this.groupSizes[e4] = 0;
      for (var o3 = n3; o3 < r3; o3++)
        this.tag.deleteRule(n3);
    }
  }, t3.getGroup = function(e4) {
    var t4 = "";
    if (e4 >= this.length || 0 === this.groupSizes[e4])
      return t4;
    for (var n3 = this.groupSizes[e4], r3 = this.indexOfGroup(e4), o3 = r3 + n3, s3 = r3; s3 < o3; s3++)
      t4 += this.tag.getRule(s3) + "/*!sc*/\n";
    return t4;
  }, e3;
}();
var T = /* @__PURE__ */ new Map();
var x2 = /* @__PURE__ */ new Map();
var k = 1;
var V = function(e3) {
  if (T.has(e3))
    return T.get(e3);
  for (; x2.has(k); )
    k++;
  var t3 = k++;
  return "production" !== import_process.default.env.NODE_ENV && ((0 | t3) < 0 || t3 > 1 << 30) && D(16, "" + t3), T.set(e3, t3), x2.set(t3, e3), t3;
};
var B = function(e3) {
  return x2.get(e3);
};
var z = function(e3, t3) {
  t3 >= k && (k = t3 + 1), T.set(e3, t3), x2.set(t3, e3);
};
var M2 = "style[" + N3 + '][data-styled-version="5.3.11"]';
var G = new RegExp("^" + N3 + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)');
var L = function(e3, t3, n3) {
  for (var r3, o3 = n3.split(","), s3 = 0, i3 = o3.length; s3 < i3; s3++)
    (r3 = o3[s3]) && e3.registerName(t3, r3);
};
var F = function(e3, t3) {
  for (var n3 = (t3.textContent || "").split("/*!sc*/\n"), r3 = [], o3 = 0, s3 = n3.length; o3 < s3; o3++) {
    var i3 = n3[o3].trim();
    if (i3) {
      var a3 = i3.match(G);
      if (a3) {
        var c3 = 0 | parseInt(a3[1], 10), u3 = a3[2];
        0 !== c3 && (z(u3, c3), L(e3, u3, a3[3]), e3.getTag().insertRules(c3, r3)), r3.length = 0;
      } else
        r3.push(i3);
    }
  }
};
var Y = function() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
};
var q = function(e3) {
  var t3 = document.head, n3 = e3 || t3, r3 = document.createElement("style"), o3 = function(e4) {
    for (var t4 = e4.childNodes, n4 = t4.length; n4 >= 0; n4--) {
      var r4 = t4[n4];
      if (r4 && 1 === r4.nodeType && r4.hasAttribute(N3))
        return r4;
    }
  }(n3), s3 = void 0 !== o3 ? o3.nextSibling : null;
  r3.setAttribute(N3, "active"), r3.setAttribute("data-styled-version", "5.3.11");
  var i3 = Y();
  return i3 && r3.setAttribute("nonce", i3), n3.insertBefore(r3, s3), r3;
};
var H2 = function() {
  function e3(e4) {
    var t4 = this.element = q(e4);
    t4.appendChild(document.createTextNode("")), this.sheet = function(e5) {
      if (e5.sheet)
        return e5.sheet;
      for (var t5 = document.styleSheets, n3 = 0, r3 = t5.length; n3 < r3; n3++) {
        var o3 = t5[n3];
        if (o3.ownerNode === e5)
          return o3;
      }
      D(17);
    }(t4), this.length = 0;
  }
  var t3 = e3.prototype;
  return t3.insertRule = function(e4, t4) {
    try {
      return this.sheet.insertRule(t4, e4), this.length++, true;
    } catch (e5) {
      return false;
    }
  }, t3.deleteRule = function(e4) {
    this.sheet.deleteRule(e4), this.length--;
  }, t3.getRule = function(e4) {
    var t4 = this.sheet.cssRules[e4];
    return void 0 !== t4 && "string" == typeof t4.cssText ? t4.cssText : "";
  }, e3;
}();
var $2 = function() {
  function e3(e4) {
    var t4 = this.element = q(e4);
    this.nodes = t4.childNodes, this.length = 0;
  }
  var t3 = e3.prototype;
  return t3.insertRule = function(e4, t4) {
    if (e4 <= this.length && e4 >= 0) {
      var n3 = document.createTextNode(t4), r3 = this.nodes[e4];
      return this.element.insertBefore(n3, r3 || null), this.length++, true;
    }
    return false;
  }, t3.deleteRule = function(e4) {
    this.element.removeChild(this.nodes[e4]), this.length--;
  }, t3.getRule = function(e4) {
    return e4 < this.length ? this.nodes[e4].textContent : "";
  }, e3;
}();
var W = function() {
  function e3(e4) {
    this.rules = [], this.length = 0;
  }
  var t3 = e3.prototype;
  return t3.insertRule = function(e4, t4) {
    return e4 <= this.length && (this.rules.splice(e4, 0, t4), this.length++, true);
  }, t3.deleteRule = function(e4) {
    this.rules.splice(e4, 1), this.length--;
  }, t3.getRule = function(e4) {
    return e4 < this.length ? this.rules[e4] : "";
  }, e3;
}();
var U = C2;
var J = { isServer: !C2, useCSSOMInjection: !I };
var X = function() {
  function e3(e4, t4, n3) {
    void 0 === e4 && (e4 = w2), void 0 === t4 && (t4 = {}), this.options = y2({}, J, {}, e4), this.gs = t4, this.names = new Map(n3), this.server = !!e4.isServer, !this.server && C2 && U && (U = false, function(e5) {
      for (var t5 = document.querySelectorAll(M2), n4 = 0, r3 = t5.length; n4 < r3; n4++) {
        var o3 = t5[n4];
        o3 && "active" !== o3.getAttribute(N3) && (F(e5, o3), o3.parentNode && o3.parentNode.removeChild(o3));
      }
    }(this));
  }
  e3.registerId = function(e4) {
    return V(e4);
  };
  var t3 = e3.prototype;
  return t3.reconstructWithOptions = function(t4, n3) {
    return void 0 === n3 && (n3 = true), new e3(y2({}, this.options, {}, t4), this.gs, n3 && this.names || void 0);
  }, t3.allocateGSInstance = function(e4) {
    return this.gs[e4] = (this.gs[e4] || 0) + 1;
  }, t3.getTag = function() {
    return this.tag || (this.tag = (n3 = (t4 = this.options).isServer, r3 = t4.useCSSOMInjection, o3 = t4.target, e4 = n3 ? new W(o3) : r3 ? new H2(o3) : new $2(o3), new j3(e4)));
    var e4, t4, n3, r3, o3;
  }, t3.hasNameForId = function(e4, t4) {
    return this.names.has(e4) && this.names.get(e4).has(t4);
  }, t3.registerName = function(e4, t4) {
    if (V(e4), this.names.has(e4))
      this.names.get(e4).add(t4);
    else {
      var n3 = /* @__PURE__ */ new Set();
      n3.add(t4), this.names.set(e4, n3);
    }
  }, t3.insertRules = function(e4, t4, n3) {
    this.registerName(e4, t4), this.getTag().insertRules(V(e4), n3);
  }, t3.clearNames = function(e4) {
    this.names.has(e4) && this.names.get(e4).clear();
  }, t3.clearRules = function(e4) {
    this.getTag().clearGroup(V(e4)), this.clearNames(e4);
  }, t3.clearTag = function() {
    this.tag = void 0;
  }, t3.toString = function() {
    return function(e4) {
      for (var t4 = e4.getTag(), n3 = t4.length, r3 = "", o3 = 0; o3 < n3; o3++) {
        var s3 = B(o3);
        if (void 0 !== s3) {
          var i3 = e4.names.get(s3), a3 = t4.getGroup(o3);
          if (i3 && a3 && i3.size) {
            var c3 = N3 + ".g" + o3 + '[id="' + s3 + '"]', u3 = "";
            void 0 !== i3 && i3.forEach(function(e5) {
              e5.length > 0 && (u3 += e5 + ",");
            }), r3 += "" + a3 + c3 + '{content:"' + u3 + '"}/*!sc*/\n';
          }
        }
      }
      return r3;
    }(this);
  }, e3;
}();
var Z2 = /(a)(d)/gi;
var K = function(e3) {
  return String.fromCharCode(e3 + (e3 > 25 ? 39 : 97));
};
function Q(e3) {
  var t3, n3 = "";
  for (t3 = Math.abs(e3); t3 > 52; t3 = t3 / 52 | 0)
    n3 = K(t3 % 52) + n3;
  return (K(t3 % 52) + n3).replace(Z2, "$1-$2");
}
var ee = function(e3, t3) {
  for (var n3 = t3.length; n3; )
    e3 = 33 * e3 ^ t3.charCodeAt(--n3);
  return e3;
};
var te = function(e3) {
  return ee(5381, e3);
};
function ne(e3) {
  for (var t3 = 0; t3 < e3.length; t3 += 1) {
    var n3 = e3[t3];
    if (E(n3) && !_(n3))
      return false;
  }
  return true;
}
var re = te("5.3.11");
var oe = function() {
  function e3(e4, t3, n3) {
    this.rules = e4, this.staticRulesId = "", this.isStatic = "production" === import_process.default.env.NODE_ENV && (void 0 === n3 || n3.isStatic) && ne(e4), this.componentId = t3, this.baseHash = ee(re, t3), this.baseStyle = n3, X.registerId(t3);
  }
  return e3.prototype.generateAndInjectStyles = function(e4, t3, n3) {
    var r3 = this.componentId, o3 = [];
    if (this.baseStyle && o3.push(this.baseStyle.generateAndInjectStyles(e4, t3, n3)), this.isStatic && !n3.hash)
      if (this.staticRulesId && t3.hasNameForId(r3, this.staticRulesId))
        o3.push(this.staticRulesId);
      else {
        var s3 = _e(this.rules, e4, t3, n3).join(""), i3 = Q(ee(this.baseHash, s3) >>> 0);
        if (!t3.hasNameForId(r3, i3)) {
          var a3 = n3(s3, "." + i3, void 0, r3);
          t3.insertRules(r3, i3, a3);
        }
        o3.push(i3), this.staticRulesId = i3;
      }
    else {
      for (var c3 = this.rules.length, u3 = ee(this.baseHash, n3.hash), l4 = "", d3 = 0; d3 < c3; d3++) {
        var h2 = this.rules[d3];
        if ("string" == typeof h2)
          l4 += h2, "production" !== import_process.default.env.NODE_ENV && (u3 = ee(u3, h2 + d3));
        else if (h2) {
          var p2 = _e(h2, e4, t3, n3), f3 = Array.isArray(p2) ? p2.join("") : p2;
          u3 = ee(u3, f3 + d3), l4 += f3;
        }
      }
      if (l4) {
        var m3 = Q(u3 >>> 0);
        if (!t3.hasNameForId(r3, m3)) {
          var y3 = n3(l4, "." + m3, void 0, r3);
          t3.insertRules(r3, m3, y3);
        }
        o3.push(m3);
      }
    }
    return o3.join(" ");
  }, e3;
}();
var se = /^\s*\/\/.*$/gm;
var ie = [":", "[", ".", "#"];
function ae(e3) {
  var t3, n3, r3, o3, s3 = void 0 === e3 ? w2 : e3, i3 = s3.options, a3 = void 0 === i3 ? w2 : i3, c3 = s3.plugins, u3 = void 0 === c3 ? S2 : c3, l4 = new stylis_browser_esm_default(a3), d3 = [], p2 = function(e4) {
    function t4(t5) {
      if (t5)
        try {
          e4(t5 + "}");
        } catch (e5) {
        }
    }
    return function(n4, r4, o4, s4, i4, a4, c4, u4, l5, d4) {
      switch (n4) {
        case 1:
          if (0 === l5 && 64 === r4.charCodeAt(0))
            return e4(r4 + ";"), "";
          break;
        case 2:
          if (0 === u4)
            return r4 + "/*|*/";
          break;
        case 3:
          switch (u4) {
            case 102:
            case 112:
              return e4(o4[0] + r4), "";
            default:
              return r4 + (0 === d4 ? "/*|*/" : "");
          }
        case -2:
          r4.split("/*|*/}").forEach(t4);
      }
    };
  }(function(e4) {
    d3.push(e4);
  }), f3 = function(e4, r4, s4) {
    return 0 === r4 && -1 !== ie.indexOf(s4[n3.length]) || s4.match(o3) ? e4 : "." + t3;
  };
  function m3(e4, s4, i4, a4) {
    void 0 === a4 && (a4 = "&");
    var c4 = e4.replace(se, ""), u4 = s4 && i4 ? i4 + " " + s4 + " { " + c4 + " }" : c4;
    return t3 = a4, n3 = s4, r3 = new RegExp("\\" + n3 + "\\b", "g"), o3 = new RegExp("(\\" + n3 + "\\b){2,}"), l4(i4 || !s4 ? "" : s4, u4);
  }
  return l4.use([].concat(u3, [function(e4, t4, o4) {
    2 === e4 && o4.length && o4[0].lastIndexOf(n3) > 0 && (o4[0] = o4[0].replace(r3, f3));
  }, p2, function(e4) {
    if (-2 === e4) {
      var t4 = d3;
      return d3 = [], t4;
    }
  }])), m3.hash = u3.length ? u3.reduce(function(e4, t4) {
    return t4.name || D(15), ee(e4, t4.name);
  }, 5381).toString() : "", m3;
}
var ce = import_react3.default.createContext();
var ue = ce.Consumer;
var le = import_react3.default.createContext();
var de = (le.Consumer, new X());
var he = ae();
function pe() {
  return (0, import_react3.useContext)(ce) || de;
}
function fe2() {
  return (0, import_react3.useContext)(le) || he;
}
function me(e3) {
  var t3 = (0, import_react3.useState)(e3.stylisPlugins), n3 = t3[0], s3 = t3[1], c3 = pe(), u3 = (0, import_react3.useMemo)(function() {
    var t4 = c3;
    return e3.sheet ? t4 = e3.sheet : e3.target && (t4 = t4.reconstructWithOptions({ target: e3.target }, false)), e3.disableCSSOMInjection && (t4 = t4.reconstructWithOptions({ useCSSOMInjection: false })), t4;
  }, [e3.disableCSSOMInjection, e3.sheet, e3.target]), l4 = (0, import_react3.useMemo)(function() {
    return ae({ options: { prefix: !e3.disableVendorPrefixes }, plugins: n3 });
  }, [e3.disableVendorPrefixes, n3]);
  return (0, import_react3.useEffect)(function() {
    (0, import_shallowequal.default)(n3, e3.stylisPlugins) || s3(e3.stylisPlugins);
  }, [e3.stylisPlugins]), import_react3.default.createElement(ce.Provider, { value: u3 }, import_react3.default.createElement(le.Provider, { value: l4 }, "production" !== import_process.default.env.NODE_ENV ? import_react3.default.Children.only(e3.children) : e3.children));
}
var ye = function() {
  function e3(e4, t3) {
    var n3 = this;
    this.inject = function(e5, t4) {
      void 0 === t4 && (t4 = he);
      var r3 = n3.name + t4.hash;
      e5.hasNameForId(n3.id, r3) || e5.insertRules(n3.id, r3, t4(n3.rules, r3, "@keyframes"));
    }, this.toString = function() {
      return D(12, String(n3.name));
    }, this.name = e4, this.id = "sc-keyframes-" + e4, this.rules = t3;
  }
  return e3.prototype.getName = function(e4) {
    return void 0 === e4 && (e4 = he), this.name + e4.hash;
  }, e3;
}();
var ve = /([A-Z])/;
var ge2 = /([A-Z])/g;
var Se = /^ms-/;
var we = function(e3) {
  return "-" + e3.toLowerCase();
};
function Ee(e3) {
  return ve.test(e3) ? e3.replace(ge2, we).replace(Se, "-ms-") : e3;
}
var be = function(e3) {
  return null == e3 || false === e3 || "" === e3;
};
function _e(e3, n3, r3, o3) {
  if (Array.isArray(e3)) {
    for (var s3, i3 = [], a3 = 0, c3 = e3.length; a3 < c3; a3 += 1)
      "" !== (s3 = _e(e3[a3], n3, r3, o3)) && (Array.isArray(s3) ? i3.push.apply(i3, s3) : i3.push(s3));
    return i3;
  }
  if (be(e3))
    return "";
  if (_(e3))
    return "." + e3.styledComponentId;
  if (E(e3)) {
    if ("function" != typeof (l4 = e3) || l4.prototype && l4.prototype.isReactComponent || !n3)
      return e3;
    var u3 = e3(n3);
    return "production" !== import_process.default.env.NODE_ENV && (0, import_react_is.isElement)(u3) && console.warn(b2(e3) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), _e(u3, n3, r3, o3);
  }
  var l4;
  return e3 instanceof ye ? r3 ? (e3.inject(r3, o3), e3.getName(o3)) : e3 : g2(e3) ? function e4(t3, n4) {
    var r4, o4, s4 = [];
    for (var i4 in t3)
      t3.hasOwnProperty(i4) && !be(t3[i4]) && (Array.isArray(t3[i4]) && t3[i4].isCss || E(t3[i4]) ? s4.push(Ee(i4) + ":", t3[i4], ";") : g2(t3[i4]) ? s4.push.apply(s4, e4(t3[i4], i4)) : s4.push(Ee(i4) + ": " + (r4 = i4, null == (o4 = t3[i4]) || "boolean" == typeof o4 || "" === o4 ? "" : "number" != typeof o4 || 0 === o4 || r4 in unitless_browser_esm_default || r4.startsWith("--") ? String(o4).trim() : o4 + "px") + ";"));
    return n4 ? [n4 + " {"].concat(s4, ["}"]) : s4;
  }(e3) : e3.toString();
}
var Ne = function(e3) {
  return Array.isArray(e3) && (e3.isCss = true), e3;
};
function Ae(e3) {
  for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n3[r3 - 1] = arguments[r3];
  return E(e3) || g2(e3) ? Ne(_e(v2(S2, [e3].concat(n3)))) : 0 === n3.length && 1 === e3.length && "string" == typeof e3[0] ? e3 : Ne(_e(v2(e3, n3)));
}
var Ce = /invalid hook call/i;
var Ie = /* @__PURE__ */ new Set();
var Pe = function(e3, t3) {
  if ("production" !== import_process.default.env.NODE_ENV) {
    var n3 = "The component " + e3 + (t3 ? ' with the id of "' + t3 + '"' : "") + " has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.", r3 = console.error;
    try {
      var o3 = true;
      console.error = function(e4) {
        if (Ce.test(e4))
          o3 = false, Ie.delete(n3);
        else {
          for (var t4 = arguments.length, s3 = new Array(t4 > 1 ? t4 - 1 : 0), i3 = 1; i3 < t4; i3++)
            s3[i3 - 1] = arguments[i3];
          r3.apply(void 0, [e4].concat(s3));
        }
      }, (0, import_react3.useRef)(), o3 && !Ie.has(n3) && (console.warn(n3), Ie.add(n3));
    } catch (e4) {
      Ce.test(e4.message) && Ie.delete(n3);
    } finally {
      console.error = r3;
    }
  }
};
var Oe = function(e3, t3, n3) {
  return void 0 === n3 && (n3 = w2), e3.theme !== n3.theme && e3.theme || t3 || n3.theme;
};
var Re = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
var De = /(^-|-$)/g;
function je(e3) {
  return e3.replace(Re, "-").replace(De, "");
}
var Te = function(e3) {
  return Q(te(e3) >>> 0);
};
function xe(e3) {
  return "string" == typeof e3 && ("production" === import_process.default.env.NODE_ENV || e3.charAt(0) === e3.charAt(0).toLowerCase());
}
var ke = function(e3) {
  return "function" == typeof e3 || "object" == typeof e3 && null !== e3 && !Array.isArray(e3);
};
var Ve = function(e3) {
  return "__proto__" !== e3 && "constructor" !== e3 && "prototype" !== e3;
};
function Be(e3, t3, n3) {
  var r3 = e3[n3];
  ke(t3) && ke(r3) ? ze(r3, t3) : e3[n3] = t3;
}
function ze(e3) {
  for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n3[r3 - 1] = arguments[r3];
  for (var o3 = 0, s3 = n3; o3 < s3.length; o3++) {
    var i3 = s3[o3];
    if (ke(i3))
      for (var a3 in i3)
        Ve(a3) && Be(e3, i3[a3], a3);
  }
  return e3;
}
var Me = import_react3.default.createContext();
var Ge = Me.Consumer;
var Fe = {};
function Ye(e3, t3, n3) {
  var o3 = _(e3), i3 = !xe(e3), a3 = t3.attrs, c3 = void 0 === a3 ? S2 : a3, l4 = t3.componentId, d3 = void 0 === l4 ? function(e4, t4) {
    var n4 = "string" != typeof e4 ? "sc" : je(e4);
    Fe[n4] = (Fe[n4] || 0) + 1;
    var r3 = n4 + "-" + Te("5.3.11" + n4 + Fe[n4]);
    return t4 ? t4 + "-" + r3 : r3;
  }(t3.displayName, t3.parentComponentId) : l4, h2 = t3.displayName, p2 = void 0 === h2 ? function(e4) {
    return xe(e4) ? "styled." + e4 : "Styled(" + b2(e4) + ")";
  }(e3) : h2, v3 = t3.displayName && t3.componentId ? je(t3.displayName) + "-" + t3.componentId : t3.componentId || d3, g3 = o3 && e3.attrs ? Array.prototype.concat(e3.attrs, c3).filter(Boolean) : c3, N4 = t3.shouldForwardProp;
  o3 && e3.shouldForwardProp && (N4 = t3.shouldForwardProp ? function(n4, r3, o4) {
    return e3.shouldForwardProp(n4, r3, o4) && t3.shouldForwardProp(n4, r3, o4);
  } : e3.shouldForwardProp);
  var A, C3 = new oe(n3, v3, o3 ? e3.componentStyle : void 0), I2 = C3.isStatic && 0 === c3.length, P = function(e4, t4) {
    return function(e5, t5, n4, r3) {
      var o4 = e5.attrs, i4 = e5.componentStyle, a4 = e5.defaultProps, c4 = e5.foldedComponentIds, l5 = e5.shouldForwardProp, d4 = e5.styledComponentId, h3 = e5.target, p3 = function(e6, t6, n5) {
        void 0 === e6 && (e6 = w2);
        var r4 = y2({}, t6, { theme: e6 }), o5 = {};
        return n5.forEach(function(e7) {
          var t7, n6, s3, i5 = e7;
          for (t7 in E(i5) && (i5 = i5(r4)), i5)
            r4[t7] = o5[t7] = "className" === t7 ? (n6 = o5[t7], s3 = i5[t7], n6 && s3 ? n6 + " " + s3 : n6 || s3) : i5[t7];
        }), [r4, o5];
      }(Oe(t5, (0, import_react3.useContext)(Me), a4) || w2, t5, o4), m3 = p3[0], v5 = p3[1], g4 = function(e6, t6, n5, r4) {
        var o5 = pe(), s3 = fe2(), i5 = t6 ? e6.generateAndInjectStyles(w2, o5, s3) : e6.generateAndInjectStyles(n5, o5, s3);
        return "production" !== import_process.default.env.NODE_ENV && !t6 && r4 && r4(i5), i5;
      }(i4, r3, m3, "production" !== import_process.default.env.NODE_ENV ? e5.warnTooManyClasses : void 0), S3 = n4, b3 = v5.$as || t5.$as || v5.as || t5.as || h3, _2 = xe(b3), N5 = v5 !== t5 ? y2({}, t5, {}, v5) : t5, A2 = {};
      for (var C4 in N5)
        "$" !== C4[0] && "as" !== C4 && ("forwardedAs" === C4 ? A2.as = N5[C4] : (l5 ? l5(C4, isPropValid, b3) : !_2 || isPropValid(C4)) && (A2[C4] = N5[C4]));
      return t5.style && v5.style !== t5.style && (A2.style = y2({}, t5.style, {}, v5.style)), A2.className = Array.prototype.concat(c4, d4, g4 !== d4 ? g4 : null, t5.className, v5.className).filter(Boolean).join(" "), A2.ref = S3, (0, import_react3.createElement)(b3, A2);
    }(A, e4, t4, I2);
  };
  return P.displayName = p2, (A = import_react3.default.forwardRef(P)).attrs = g3, A.componentStyle = C3, A.displayName = p2, A.shouldForwardProp = N4, A.foldedComponentIds = o3 ? Array.prototype.concat(e3.foldedComponentIds, e3.styledComponentId) : S2, A.styledComponentId = v3, A.target = o3 ? e3.target : e3, A.withComponent = function(e4) {
    var r3 = t3.componentId, o4 = function(e5, t4) {
      if (null == e5)
        return {};
      var n4, r4, o5 = {}, s4 = Object.keys(e5);
      for (r4 = 0; r4 < s4.length; r4++)
        n4 = s4[r4], t4.indexOf(n4) >= 0 || (o5[n4] = e5[n4]);
      return o5;
    }(t3, ["componentId"]), s3 = r3 && r3 + "-" + (xe(e4) ? e4 : je(b2(e4)));
    return Ye(e4, y2({}, o4, { attrs: g3, componentId: s3 }), n3);
  }, Object.defineProperty(A, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(t4) {
    this._foldedDefaultProps = o3 ? ze({}, e3.defaultProps, t4) : t4;
  } }), "production" !== import_process.default.env.NODE_ENV && (Pe(p2, v3), A.warnTooManyClasses = function(e4, t4) {
    var n4 = {}, r3 = false;
    return function(o4) {
      if (!r3 && (n4[o4] = true, Object.keys(n4).length >= 200)) {
        var s3 = t4 ? ' with the id of "' + t4 + '"' : "";
        console.warn("Over 200 classes were generated for component " + e4 + s3 + ".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), r3 = true, n4 = {};
      }
    };
  }(p2, v3)), Object.defineProperty(A, "toString", { value: function() {
    return "." + A.styledComponentId;
  } }), i3 && (0, import_hoist_non_react_statics.default)(A, e3, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), A;
}
var qe = function(e3) {
  return function e4(t3, r3, o3) {
    if (void 0 === o3 && (o3 = w2), !(0, import_react_is.isValidElementType)(r3))
      return D(1, String(r3));
    var s3 = function() {
      return t3(r3, o3, Ae.apply(void 0, arguments));
    };
    return s3.withConfig = function(n3) {
      return e4(t3, r3, y2({}, o3, {}, n3));
    }, s3.attrs = function(n3) {
      return e4(t3, r3, y2({}, o3, { attrs: Array.prototype.concat(o3.attrs, n3).filter(Boolean) }));
    }, s3;
  }(Ye, e3);
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e3) {
  qe[e3] = qe(e3);
});
var He = function() {
  function e3(e4, t4) {
    this.rules = e4, this.componentId = t4, this.isStatic = ne(e4), X.registerId(this.componentId + 1);
  }
  var t3 = e3.prototype;
  return t3.createStyles = function(e4, t4, n3, r3) {
    var o3 = r3(_e(this.rules, t4, n3, r3).join(""), ""), s3 = this.componentId + e4;
    n3.insertRules(s3, s3, o3);
  }, t3.removeStyles = function(e4, t4) {
    t4.clearRules(this.componentId + e4);
  }, t3.renderStyles = function(e4, t4, n3, r3) {
    e4 > 2 && X.registerId(this.componentId + e4), this.removeStyles(e4, n3), this.createStyles(e4, t4, n3, r3);
  }, e3;
}();
var Ue = function() {
  function e3() {
    var e4 = this;
    this._emitSheetCSS = function() {
      var t4 = e4.instance.toString();
      if (!t4)
        return "";
      var n3 = Y();
      return "<style " + [n3 && 'nonce="' + n3 + '"', N3 + '="true"', 'data-styled-version="5.3.11"'].filter(Boolean).join(" ") + ">" + t4 + "</style>";
    }, this.getStyleTags = function() {
      return e4.sealed ? D(2) : e4._emitSheetCSS();
    }, this.getStyleElement = function() {
      var t4;
      if (e4.sealed)
        return D(2);
      var n3 = ((t4 = {})[N3] = "", t4["data-styled-version"] = "5.3.11", t4.dangerouslySetInnerHTML = { __html: e4.instance.toString() }, t4), o3 = Y();
      return o3 && (n3.nonce = o3), [import_react3.default.createElement("style", y2({}, n3, { key: "sc-0-0" }))];
    }, this.seal = function() {
      e4.sealed = true;
    }, this.instance = new X({ isServer: true }), this.sealed = false;
  }
  var t3 = e3.prototype;
  return t3.collectStyles = function(e4) {
    return this.sealed ? D(2) : import_react3.default.createElement(me, { sheet: this.instance }, e4);
  }, t3.interleaveWithNodeStream = function(e4) {
    return D(3);
  }, e3;
}();
"production" !== import_process.default.env.NODE_ENV && "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), "production" !== import_process.default.env.NODE_ENV && "test" !== import_process.default.env.NODE_ENV && "undefined" != typeof window && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, 1 === window["__styled-components-init__"] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window["__styled-components-init__"] += 1);
var styled_components_browser_esm_default = qe;

// node_modules/@polkadot/react-identicon/styled.js
var styled = styled_components_browser_esm_default.styled || styled_components_browser_esm_default.default || styled_components_browser_esm_default;

// node_modules/@polkadot/react-identicon/icons/Ethereum.js
function Identicon3({ address, className = "", size, style = {} }) {
  const imgSrc = (0, import_react4.useMemo)(() => (0, import_ethereum_blockies_base64.default)(address), [address]);
  return (0, import_jsx_runtime3.jsx)(StyledImg, { className, size, src: imgSrc, style });
}
var StyledImg = styled.img(({ size }) => `
  display: block;
  height: ${size}px;
  width: ${size}px;
`);
var Ethereum = import_react4.default.memo(Identicon3);

// node_modules/@polkadot/react-identicon/icons/Jdenticon.js
init_shim();
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);

// node_modules/jdenticon/dist/jdenticon-module.mjs
init_shim();
function parseHex(hash2, startPosition, octets) {
  return parseInt(hash2.substr(startPosition, octets), 16);
}
function decToHex(v3) {
  v3 |= 0;
  return v3 < 0 ? "00" : v3 < 16 ? "0" + v3.toString(16) : v3 < 256 ? v3.toString(16) : "ff";
}
function hueToRgb(m1, m22, h2) {
  h2 = h2 < 0 ? h2 + 6 : h2 > 6 ? h2 - 6 : h2;
  return decToHex(255 * (h2 < 1 ? m1 + (m22 - m1) * h2 : h2 < 3 ? m22 : h2 < 4 ? m1 + (m22 - m1) * (4 - h2) : m1));
}
function parseColor(color) {
  if (/^#[0-9a-f]{3,8}$/i.test(color)) {
    let result;
    const colorLength = color.length;
    if (colorLength < 6) {
      const r3 = color[1], g3 = color[2], b3 = color[3], a3 = color[4] || "";
      result = "#" + r3 + r3 + g3 + g3 + b3 + b3 + a3 + a3;
    }
    if (colorLength == 7 || colorLength > 8) {
      result = color;
    }
    return result;
  }
}
function hsl(hue, saturation, lightness) {
  let result;
  if (saturation == 0) {
    const partialHex = decToHex(lightness * 255);
    result = partialHex + partialHex + partialHex;
  } else {
    const m22 = lightness <= 0.5 ? lightness * (saturation + 1) : lightness + saturation - lightness * saturation, m1 = lightness * 2 - m22;
    result = hueToRgb(m1, m22, hue * 6 + 2) + hueToRgb(m1, m22, hue * 6) + hueToRgb(m1, m22, hue * 6 - 2);
  }
  return "#" + result;
}
function correctedHsl(hue, saturation, lightness) {
  const correctors = [0.55, 0.5, 0.5, 0.46, 0.6, 0.55, 0.55], corrector = correctors[hue * 6 + 0.5 | 0];
  lightness = lightness < 0.5 ? lightness * corrector * 2 : corrector + (lightness - 0.5) * (1 - corrector) * 2;
  return hsl(hue, saturation, lightness);
}
var GLOBAL = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : {};
var CONFIG_PROPERTIES = {
  V: "jdenticon_config",
  n: "config"
};
var rootConfigurationHolder = {};
function getConfiguration(paddingOrLocalConfig, defaultPadding) {
  const configObject = typeof paddingOrLocalConfig == "object" && paddingOrLocalConfig || rootConfigurationHolder[
    CONFIG_PROPERTIES.n
    /*MODULE*/
  ] || GLOBAL[
    CONFIG_PROPERTIES.V
    /*GLOBAL*/
  ] || {}, lightnessConfig = configObject["lightness"] || {}, saturation = configObject["saturation"] || {}, colorSaturation = "color" in saturation ? saturation["color"] : saturation, grayscaleSaturation = saturation["grayscale"], backColor = configObject["backColor"], padding2 = configObject["padding"];
  function lightness(configName, defaultRange) {
    let range = lightnessConfig[configName];
    if (!(range && range.length > 1)) {
      range = defaultRange;
    }
    return function(value) {
      value = range[0] + value * (range[1] - range[0]);
      return value < 0 ? 0 : value > 1 ? 1 : value;
    };
  }
  function hueFunction(originalHue) {
    const hueConfig = configObject["hues"];
    let hue;
    if (hueConfig && hueConfig.length > 0) {
      hue = hueConfig[0 | 0.999 * originalHue * hueConfig.length];
    }
    return typeof hue == "number" ? (
      // A hue was specified. We need to convert the hue from
      // degrees on any turn - e.g. 746° is a perfectly valid hue -
      // to turns in the range [0, 1).
      (hue / 360 % 1 + 1) % 1
    ) : (
      // No hue configured => use original hue
      originalHue
    );
  }
  return {
    W: hueFunction,
    o: typeof colorSaturation == "number" ? colorSaturation : 0.5,
    D: typeof grayscaleSaturation == "number" ? grayscaleSaturation : 0,
    p: lightness("color", [0.4, 0.8]),
    F: lightness("grayscale", [0.3, 0.9]),
    G: parseColor(backColor),
    X: typeof paddingOrLocalConfig == "number" ? paddingOrLocalConfig : typeof padding2 == "number" ? padding2 : defaultPadding
  };
}
var Point2 = class {
  /**
   * @param {number} x 
   * @param {number} y 
   */
  constructor(x3, y3) {
    this.x = x3;
    this.y = y3;
  }
};
var Transform = class {
  /**
   * @param {number} x The x-coordinate of the upper left corner of the transformed rectangle.
   * @param {number} y The y-coordinate of the upper left corner of the transformed rectangle.
   * @param {number} size The size of the transformed rectangle.
   * @param {number} rotation Rotation specified as 0 = 0 rad, 1 = 0.5π rad, 2 = π rad, 3 = 1.5π rad
   */
  constructor(x3, y3, size, rotation) {
    this.q = x3;
    this.t = y3;
    this.H = size;
    this.Y = rotation;
  }
  /**
   * Transforms the specified point based on the translation and rotation specification for this Transform.
   * @param {number} x x-coordinate
   * @param {number} y y-coordinate
   * @param {number=} w The width of the transformed rectangle. If greater than 0, this will ensure the returned point is of the upper left corner of the transformed rectangle.
   * @param {number=} h The height of the transformed rectangle. If greater than 0, this will ensure the returned point is of the upper left corner of the transformed rectangle.
   */
  I(x3, y3, w3, h2) {
    const right = this.q + this.H, bottom = this.t + this.H, rotation = this.Y;
    return rotation === 1 ? new Point2(right - y3 - (h2 || 0), this.t + x3) : rotation === 2 ? new Point2(right - x3 - (w3 || 0), bottom - y3 - (h2 || 0)) : rotation === 3 ? new Point2(this.q + y3, bottom - x3 - (w3 || 0)) : new Point2(this.q + x3, this.t + y3);
  }
};
var NO_TRANSFORM = new Transform(0, 0, 0, 0);
var Graphics = class {
  /**
   * @param {Renderer} renderer 
   */
  constructor(renderer) {
    this.J = renderer;
    this.u = NO_TRANSFORM;
  }
  /**
   * Adds a polygon to the underlying renderer.
   * @param {Array<number>} points The points of the polygon clockwise on the format [ x0, y0, x1, y1, ..., xn, yn ]
   * @param {boolean=} invert Specifies if the polygon will be inverted.
   */
  g(points, invert2) {
    const di = invert2 ? -2 : 2, transformedPoints = [];
    for (let i3 = invert2 ? points.length - 2 : 0; i3 < points.length && i3 >= 0; i3 += di) {
      transformedPoints.push(this.u.I(points[i3], points[i3 + 1]));
    }
    this.J.g(transformedPoints);
  }
  /**
   * Adds a polygon to the underlying renderer.
   * Source: http://stackoverflow.com/a/2173084
   * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the entire ellipse.
   * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the entire ellipse.
   * @param {number} size The size of the ellipse.
   * @param {boolean=} invert Specifies if the ellipse will be inverted.
   */
  h(x3, y3, size, invert2) {
    const p2 = this.u.I(x3, y3, size, size);
    this.J.h(p2, size, invert2);
  }
  /**
   * Adds a rectangle to the underlying renderer.
   * @param {number} x The x-coordinate of the upper left corner of the rectangle.
   * @param {number} y The y-coordinate of the upper left corner of the rectangle.
   * @param {number} w The width of the rectangle.
   * @param {number} h The height of the rectangle.
   * @param {boolean=} invert Specifies if the rectangle will be inverted.
   */
  i(x3, y3, w3, h2, invert2) {
    this.g([
      x3,
      y3,
      x3 + w3,
      y3,
      x3 + w3,
      y3 + h2,
      x3,
      y3 + h2
    ], invert2);
  }
  /**
   * Adds a right triangle to the underlying renderer.
   * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the triangle.
   * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the triangle.
   * @param {number} w The width of the triangle.
   * @param {number} h The height of the triangle.
   * @param {number} r The rotation of the triangle (clockwise). 0 = right corner of the triangle in the lower left corner of the bounding rectangle.
   * @param {boolean=} invert Specifies if the triangle will be inverted.
   */
  j(x3, y3, w3, h2, r3, invert2) {
    const points = [
      x3 + w3,
      y3,
      x3 + w3,
      y3 + h2,
      x3,
      y3 + h2,
      x3,
      y3
    ];
    points.splice((r3 || 0) % 4 * 2, 2);
    this.g(points, invert2);
  }
  /**
   * Adds a rhombus to the underlying renderer.
   * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the rhombus.
   * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the rhombus.
   * @param {number} w The width of the rhombus.
   * @param {number} h The height of the rhombus.
   * @param {boolean=} invert Specifies if the rhombus will be inverted.
   */
  K(x3, y3, w3, h2, invert2) {
    this.g([
      x3 + w3 / 2,
      y3,
      x3 + w3,
      y3 + h2 / 2,
      x3 + w3 / 2,
      y3 + h2,
      x3,
      y3 + h2 / 2
    ], invert2);
  }
};
function centerShape(index, g3, cell, positionIndex) {
  index = index % 14;
  let k2, m3, w3, h2, inner, outer;
  !index ? (k2 = cell * 0.42, g3.g([
    0,
    0,
    cell,
    0,
    cell,
    cell - k2 * 2,
    cell - k2,
    cell,
    0,
    cell
  ])) : index == 1 ? (w3 = 0 | cell * 0.5, h2 = 0 | cell * 0.8, g3.j(cell - w3, 0, w3, h2, 2)) : index == 2 ? (w3 = 0 | cell / 3, g3.i(w3, w3, cell - w3, cell - w3)) : index == 3 ? (inner = cell * 0.1, // Use fixed outer border widths in small icons to ensure the border is drawn
  outer = cell < 6 ? 1 : cell < 8 ? 2 : 0 | cell * 0.25, inner = inner > 1 ? 0 | inner : (
    // large icon => truncate decimals
    inner > 0.5 ? 1 : (
      // medium size icon => fixed width
      inner
    )
  ), // small icon => anti-aliased border
  g3.i(outer, outer, cell - inner - outer, cell - inner - outer)) : index == 4 ? (m3 = 0 | cell * 0.15, w3 = 0 | cell * 0.5, g3.h(cell - w3 - m3, cell - w3 - m3, w3)) : index == 5 ? (inner = cell * 0.1, outer = inner * 4, // Align edge to nearest pixel in large icons
  outer > 3 && (outer = 0 | outer), g3.i(0, 0, cell, cell), g3.g([
    outer,
    outer,
    cell - inner,
    outer,
    outer + (cell - outer - inner) / 2,
    cell - inner
  ], true)) : index == 6 ? g3.g([
    0,
    0,
    cell,
    0,
    cell,
    cell * 0.7,
    cell * 0.4,
    cell * 0.4,
    cell * 0.7,
    cell,
    0,
    cell
  ]) : index == 7 ? g3.j(cell / 2, cell / 2, cell / 2, cell / 2, 3) : index == 8 ? (g3.i(0, 0, cell, cell / 2), g3.i(0, cell / 2, cell / 2, cell / 2), g3.j(cell / 2, cell / 2, cell / 2, cell / 2, 1)) : index == 9 ? (inner = cell * 0.14, // Use fixed outer border widths in small icons to ensure the border is drawn
  outer = cell < 4 ? 1 : cell < 6 ? 2 : 0 | cell * 0.35, inner = cell < 8 ? inner : (
    // small icon => anti-aliased border
    0 | inner
  ), // large icon => truncate decimals
  g3.i(0, 0, cell, cell), g3.i(outer, outer, cell - outer - inner, cell - outer - inner, true)) : index == 10 ? (inner = cell * 0.12, outer = inner * 3, g3.i(0, 0, cell, cell), g3.h(outer, outer, cell - inner - outer, true)) : index == 11 ? g3.j(cell / 2, cell / 2, cell / 2, cell / 2, 3) : index == 12 ? (m3 = cell * 0.25, g3.i(0, 0, cell, cell), g3.K(m3, m3, cell - m3, cell - m3, true)) : (
    // 13
    !positionIndex && (m3 = cell * 0.4, w3 = cell * 1.2, g3.h(m3, m3, w3))
  );
}
function outerShape(index, g3, cell) {
  index = index % 4;
  let m3;
  !index ? g3.j(0, 0, cell, cell, 0) : index == 1 ? g3.j(0, cell / 2, cell, cell / 2, 0) : index == 2 ? g3.K(0, 0, cell, cell) : (
    // 3
    (m3 = cell / 6, g3.h(m3, m3, cell - 2 * m3))
  );
}
function colorTheme(hue, config4) {
  hue = config4.W(hue);
  return [
    // Dark gray
    correctedHsl(hue, config4.D, config4.F(0)),
    // Mid color
    correctedHsl(hue, config4.o, config4.p(0.5)),
    // Light gray
    correctedHsl(hue, config4.D, config4.F(1)),
    // Light color
    correctedHsl(hue, config4.o, config4.p(1)),
    // Dark color
    correctedHsl(hue, config4.o, config4.p(0))
  ];
}
function iconGenerator(renderer, hash2, config4) {
  const parsedConfig = getConfiguration(config4, 0.08);
  if (parsedConfig.G) {
    renderer.m(
      parsedConfig.G
      /*backColor*/
    );
  }
  let size = renderer.k;
  const padding2 = 0.5 + size * parsedConfig.X | 0;
  size -= padding2 * 2;
  const graphics = new Graphics(renderer);
  const cell = 0 | size / 4;
  const x3 = 0 | padding2 + size / 2 - cell * 2;
  const y3 = 0 | padding2 + size / 2 - cell * 2;
  function renderShape(colorIndex, shapes, index2, rotationIndex, positions) {
    const shapeIndex = parseHex(hash2, index2, 1);
    let r3 = rotationIndex ? parseHex(hash2, rotationIndex, 1) : 0;
    renderer.L(availableColors[selectedColorIndexes[colorIndex]]);
    for (let i3 = 0; i3 < positions.length; i3++) {
      graphics.u = new Transform(x3 + positions[i3][0] * cell, y3 + positions[i3][1] * cell, cell, r3++ % 4);
      shapes(shapeIndex, graphics, cell, i3);
    }
    renderer.M();
  }
  const hue = parseHex(hash2, -7) / 268435455, availableColors = colorTheme(hue, parsedConfig), selectedColorIndexes = [];
  let index;
  function isDuplicate(values) {
    if (values.indexOf(index) >= 0) {
      for (let i3 = 0; i3 < values.length; i3++) {
        if (selectedColorIndexes.indexOf(values[i3]) >= 0) {
          return true;
        }
      }
    }
  }
  for (let i3 = 0; i3 < 3; i3++) {
    index = parseHex(hash2, 8 + i3, 1) % availableColors.length;
    if (isDuplicate([0, 4]) || // Disallow dark gray and dark color combo
    isDuplicate([2, 3])) {
      index = 1;
    }
    selectedColorIndexes.push(index);
  }
  renderShape(0, outerShape, 2, 3, [[1, 0], [2, 0], [2, 3], [1, 3], [0, 1], [3, 1], [3, 2], [0, 2]]);
  renderShape(1, outerShape, 4, 5, [[0, 0], [3, 0], [3, 3], [0, 3]]);
  renderShape(2, centerShape, 1, null, [[1, 1], [2, 1], [2, 2], [1, 2]]);
  renderer.finish();
}
function sha1(message) {
  const HASH_SIZE_HALF_BYTES = 40;
  const BLOCK_SIZE_WORDS = 16;
  var i3 = 0, f3 = 0, urlEncodedMessage = encodeURI(message) + "%80", data = [], dataSize, hashBuffer = [], a3 = 1732584193, b3 = 4023233417, c3 = ~a3, d3 = ~b3, e3 = 3285377520, hash2 = [a3, b3, c3, d3, e3], blockStartIndex = 0, hexHash = "";
  function rotl2(value, shift) {
    return value << shift | value >>> 32 - shift;
  }
  for (; i3 < urlEncodedMessage.length; f3++) {
    data[f3 >> 2] = data[f3 >> 2] | (urlEncodedMessage[i3] == "%" ? parseInt(urlEncodedMessage.substring(i3 + 1, i3 += 3), 16) : urlEncodedMessage.charCodeAt(i3++)) << (3 - (f3 & 3)) * 8;
  }
  dataSize = ((f3 + 7 >> 6) + 1) * BLOCK_SIZE_WORDS;
  data[dataSize - 1] = f3 * 8 - 8;
  for (; blockStartIndex < dataSize; blockStartIndex += BLOCK_SIZE_WORDS) {
    for (i3 = 0; i3 < 80; i3++) {
      f3 = rotl2(a3, 5) + e3 + // Ch
      (i3 < 20 ? (b3 & c3 ^ ~b3 & d3) + 1518500249 : (
        // Parity
        i3 < 40 ? (b3 ^ c3 ^ d3) + 1859775393 : (
          // Maj
          i3 < 60 ? (b3 & c3 ^ b3 & d3 ^ c3 & d3) + 2400959708 : (
            // Parity
            (b3 ^ c3 ^ d3) + 3395469782
          )
        )
      )) + (hashBuffer[i3] = i3 < BLOCK_SIZE_WORDS ? data[blockStartIndex + i3] | 0 : rotl2(hashBuffer[i3 - 3] ^ hashBuffer[i3 - 8] ^ hashBuffer[i3 - 14] ^ hashBuffer[i3 - 16], 1));
      e3 = d3;
      d3 = c3;
      c3 = rotl2(b3, 30);
      b3 = a3;
      a3 = f3;
    }
    hash2[0] = a3 = hash2[0] + a3 | 0;
    hash2[1] = b3 = hash2[1] + b3 | 0;
    hash2[2] = c3 = hash2[2] + c3 | 0;
    hash2[3] = d3 = hash2[3] + d3 | 0;
    hash2[4] = e3 = hash2[4] + e3 | 0;
  }
  for (i3 = 0; i3 < HASH_SIZE_HALF_BYTES; i3++) {
    hexHash += // Get word (2^3 half-bytes per word)
    (hash2[i3 >> 3] >>> // Append half-bytes in reverse order
    (7 - (i3 & 7)) * 4 & 15).toString(16);
  }
  return hexHash;
}
function isValidHash(hashCandidate) {
  return /^[0-9a-f]{11,}$/i.test(hashCandidate) && hashCandidate;
}
function computeHash(value) {
  return sha1(value == null ? "" : "" + value);
}
function svgValue(value) {
  return (value * 10 + 0.5 | 0) / 10;
}
var SvgPath = class {
  constructor() {
    this.v = "";
  }
  /**
   * Adds a polygon with the current fill color to the SVG path.
   * @param points An array of Point objects.
   */
  g(points) {
    let dataString = "";
    for (let i3 = 0; i3 < points.length; i3++) {
      dataString += (i3 ? "L" : "M") + svgValue(points[i3].x) + " " + svgValue(points[i3].y);
    }
    this.v += dataString + "Z";
  }
  /**
   * Adds a circle with the current fill color to the SVG path.
   * @param {Point} point The upper left corner of the circle bounding box.
   * @param {number} diameter The diameter of the circle.
   * @param {boolean} counterClockwise True if the circle is drawn counter-clockwise (will result in a hole if rendered on a clockwise path).
   */
  h(point, diameter, counterClockwise) {
    const sweepFlag = counterClockwise ? 0 : 1, svgRadius = svgValue(diameter / 2), svgDiameter = svgValue(diameter), svgArc = "a" + svgRadius + "," + svgRadius + " 0 1," + sweepFlag + " ";
    this.v += "M" + svgValue(point.x) + " " + svgValue(point.y + diameter / 2) + svgArc + svgDiameter + ",0" + svgArc + -svgDiameter + ",0";
  }
};
var SvgRenderer = class {
  /**
   * @param {SvgElement|SvgWriter} target 
   */
  constructor(target) {
    this.A;
    this.B = {};
    this.N = target;
    this.k = target.k;
  }
  /**
   * Fills the background with the specified color.
   * @param {string} fillColor  Fill color on the format #rrggbb[aa].
   */
  m(fillColor) {
    const match = /^(#......)(..)?/.exec(fillColor), opacity = match[2] ? parseHex(match[2], 0) / 255 : 1;
    this.N.m(match[1], opacity);
  }
  /**
   * Marks the beginning of a new shape of the specified color. Should be ended with a call to endShape.
   * @param {string} color Fill color on format #xxxxxx.
   */
  L(color) {
    this.A = this.B[color] || (this.B[color] = new SvgPath());
  }
  /**
   * Marks the end of the currently drawn shape.
   */
  M() {
  }
  /**
   * Adds a polygon with the current fill color to the SVG.
   * @param points An array of Point objects.
   */
  g(points) {
    this.A.g(points);
  }
  /**
   * Adds a circle with the current fill color to the SVG.
   * @param {Point} point The upper left corner of the circle bounding box.
   * @param {number} diameter The diameter of the circle.
   * @param {boolean} counterClockwise True if the circle is drawn counter-clockwise (will result in a hole if rendered on a clockwise path).
   */
  h(point, diameter, counterClockwise) {
    this.A.h(point, diameter, counterClockwise);
  }
  /**
   * Called when the icon has been completely drawn.
   */
  finish() {
    const pathsByColor = this.B;
    for (let color in pathsByColor) {
      if (pathsByColor.hasOwnProperty(color)) {
        this.N.O(
          color,
          pathsByColor[color].v
          /*dataString*/
        );
      }
    }
  }
};
var SVG_CONSTANTS = {
  P: "http://www.w3.org/2000/svg",
  R: "width",
  S: "height"
};
var SvgWriter = class {
  /**
   * @param {number} iconSize - Icon width and height in pixels.
   */
  constructor(iconSize) {
    this.k = iconSize;
    this.C = '<svg xmlns="' + SVG_CONSTANTS.P + '" width="' + iconSize + '" height="' + iconSize + '" viewBox="0 0 ' + iconSize + " " + iconSize + '">';
  }
  /**
   * Fills the background with the specified color.
   * @param {string} fillColor  Fill color on the format #rrggbb.
   * @param {number} opacity  Opacity in the range [0.0, 1.0].
   */
  m(fillColor, opacity) {
    if (opacity) {
      this.C += '<rect width="100%" height="100%" fill="' + fillColor + '" opacity="' + opacity.toFixed(2) + '"/>';
    }
  }
  /**
   * Writes a path to the SVG string.
   * @param {string} color Fill color on format #rrggbb.
   * @param {string} dataString The SVG path data string.
   */
  O(color, dataString) {
    this.C += '<path fill="' + color + '" d="' + dataString + '"/>';
  }
  /**
   * Gets the rendered image as an SVG string.
   */
  toString() {
    return this.C + "</svg>";
  }
};
function toSvg(hashOrValue, size, config4) {
  const writer = new SvgWriter(size);
  iconGenerator(
    new SvgRenderer(writer),
    isValidHash(hashOrValue) || computeHash(hashOrValue),
    config4
  );
  return writer.toString();
}
var documentQuerySelectorAll = (
  /** @type {!Function} */
  typeof document !== "undefined" && document.querySelectorAll.bind(document)
);

// node_modules/@polkadot/react-identicon/icons/Jdenticon.js
var import_react5 = __toESM(require_react(), 1);
function Identicon4({ className = "", publicKey, size, style = {} }) {
  const html = (0, import_react5.useMemo)(() => ({ __html: toSvg(publicKey.substring(2), size) }), [publicKey, size]);
  return (0, import_jsx_runtime4.jsx)("div", { className, dangerouslySetInnerHTML: html, style });
}
var Jdenticon = import_react5.default.memo(Identicon4);

// node_modules/@polkadot/react-identicon/icons/Polkadot.js
init_shim();
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
function renderCircle({ cx, cy, fill, r: r3 }, key) {
  return (0, import_jsx_runtime5.jsx)("circle", { cx, cy, fill, r: r3 }, key);
}
function Identicon5({ address, className = "", isAlternative = false, size, style = {} }) {
  const circles = (0, import_react6.useMemo)(() => polkadotIcon(address, { isAlternative }), [address, isAlternative]);
  return (0, import_jsx_runtime5.jsx)("svg", { className, height: size, id: address, name: address, style, viewBox: "0 0 64 64", width: size, children: circles.map(renderCircle) });
}
var Polkadot = import_react6.default.memo(Identicon5);

// node_modules/@polkadot/react-identicon/Identicon.js
init_shim();
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react_copy_to_clipboard = __toESM(require_lib(), 1);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/bundle.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/Settings.js
init_shim();
var import_store = __toESM(require_store_legacy(), 1);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/defaults/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/defaults/crypto.js
init_shim();
var CRYPTOS = [
  {
    info: "sr25519",
    text: "Schnorrkel (sr25519, recommended)",
    value: "sr25519"
  },
  {
    info: "ed25519",
    text: "Edwards (ed25519, alternative)",
    value: "ed25519"
  },
  {
    info: "ecdsa",
    text: "ECDSA (Non BTC/ETH compatible)",
    value: "ecdsa"
  }
];
var CRYPTOS_ETH = [
  {
    info: "ethereum",
    text: "ECDSA (ETH compatible)",
    value: "ethereum"
  }
];
var CRYPTOS_LEDGER = [
  ...CRYPTOS,
  {
    info: "ed25519-ledger",
    text: "Ledger (ed25519, BIP32 derivation)",
    value: "ed25519-ledger"
  }
];

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/defaults/endpoints.js
init_shim();
var ENDPOINTS = [
  {
    info: "local",
    text: "Local Node (Own, 127.0.0.1:9944)",
    value: "ws://127.0.0.1:9944/"
  }
];
var ENDPOINT_DEFAULT = ENDPOINTS[0];

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/defaults/ledger.js
init_shim();
var LEDGER_CONN_DEFAULT = "none";
var LEDGER_CONN = [
  {
    info: "none",
    text: "Do not attach Ledger devices",
    value: "none"
  },
  // Deprecated
  // {
  //   info: 'u2f',
  //   text: 'Attach Ledger via U2F',
  //   value: 'u2f'
  // },
  {
    info: "webusb",
    text: "Attach Ledger via WebUSB (Chrome, recommended)",
    value: "webusb"
  },
  {
    info: "hid",
    text: "Attach Ledger via WebHID (Chrome, experimental)",
    value: "hid"
  }
];

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/defaults/ss58.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/interfaces.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/defaults/index.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/defaults/genesis.js
init_shim();
var knownGenesis2 = {
  acala: [
    "0xfc41b9bd8ef8fe53d58c7ea67c794c7ec9a73daf05e6d54b14ff6342c99ba64c"
  ],
  ajuna: [
    "0xe358eb1d11b31255a286c12e44fe6780b7edb171d657905a97e39f71d9c6c3ee"
  ],
  "aleph-node": [
    "0x70255b4d28de0fc4e1a193d7e175ad1ccef431598211c55538f1018651a0344e"
  ],
  astar: [
    "0x9eb76c5184c4ab8679d2d5d819fdf90b9c001403e9e17da2e14b6d8aec4029c6"
  ],
  basilisk: [
    "0xa85cfb9b9fd4d622a5b28289a02347af987d8f73fa3108450e2b4a11c1ce5755"
  ],
  bifrost: [
    "0x262e1b2ad728475fd6fe88e62d34c200abe6fd693931ddad144059b1eb884e5b"
  ],
  "bifrost-kusama": [
    "0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed"
  ],
  bittensor: [
    "0x2f0555cc76fc2840a25a6ea3b9637146806f1f44b090c175ffde2a7e5ab36c03"
  ],
  centrifuge: [
    "0xb3db41421702df9a7fcac62b53ffeac85f7853cc4e689e0b93aeb3db18c09d82",
    "0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5"
  ],
  cere: [
    "0x81443836a9a24caaa23f1241897d1235717535711d1d3fe24eae4fdc942c092c"
  ],
  composable: [
    "0xdaab8df776eb52ec604a5df5d388bb62a050a0aaec4556a64265b9d42755552d"
  ],
  darwinia: [
    "0xe71578b37a7c799b0ab4ee87ffa6f059a6b98f71f06fb8c84a8d88013a548ad6"
  ],
  "dock-mainnet": [
    "0x6bfe24dca2a3be10f22212678ac13a6446ec764103c0f3471c71609eac384aae",
    "0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9"
  ],
  edgeware: [
    "0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b"
  ],
  enjin: [
    "0xd8761d3c88f26dc12875c00d3165f7d67243d56fc85b4cf19937601a7916e5a9"
  ],
  equilibrium: [
    "0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925"
  ],
  genshiro: [
    "0x9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243"
  ],
  hydradx: [
    "0xafdc188f45c71dacbaa0b62e16a91f726c7b8699a9748cdf715459de6b7f366d",
    "0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc",
    "0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9",
    "0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047",
    "0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2"
    // Snakenet Gen1
  ],
  "interlay-parachain": [
    "0xbf88efe70e9e0e916416e8bed61f2b45717f517d7f3523e33c7b001e5ffcbc72"
  ],
  karura: [
    "0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b"
  ],
  khala: [
    "0xd43540ba6d3eb4897c28a77d48cb5b729fea37603cbbfc7a86a73b72adb3be8d"
  ],
  kulupu: [
    "0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba"
  ],
  kusama: [
    "0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe",
    "0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636",
    "0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf"
    // Kusama CC1
  ],
  matrixchain: [
    "0x3af4ff48ec76d2efc8476730f423ac07e25ad48f5f4c9dc39c778b164d808615"
  ],
  nodle: [
    "0x97da7ede98d7bad4e36b4d734b6055425a3be036da2a332ea5a7037656427a21"
  ],
  origintrail: [
    "0xe7e0962324a3b86c83404dbea483f25fb5dab4c224791c81b756cfc948006174"
  ],
  p3d: [
    "0x6c5894837ad89b6d92b114a2fb3eafa8fe3d26a54848e3447015442cd6ef4e66"
  ],
  parallel: [
    "0xe61a41c53f5dcd0beb09df93b34402aada44cb05117b71059cce40a2723a4e97"
  ],
  pendulum: [
    "0x5d3c298622d5634ed019bf61ea4b71655030015bde9beb0d6a24743714462c86"
  ],
  phala: [
    "0x1bb969d85965e4bb5a651abbedf21a54b6b31a21f66b5401cc3f1e286268d736"
  ],
  picasso: [
    "0x6811a339673c9daa897944dcdac99c6e2939cc88245ed21951a0a3c9a2be75bc",
    "0xe8e7f0f4c4f5a00720b4821dbfddefea7490bcf0b19009961cc46957984e2c1c"
  ],
  polkadex: [
    "0x3920bcb4960a1eef5580cd5367ff3f430eef052774f78468852f7b9cb39f8a3c"
  ],
  polkadot: [
    "0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3"
  ],
  polymesh: [
    "0x6fbd74e5e1d0a61d52ccfe9d4adaed16dd3a7caa37c6bc4d0c2fa12e8b2f4063"
  ],
  quartz: [
    "0xcd4d732201ebe5d6b014edda071c4203e16867305332301dc8d092044b28e554"
  ],
  rococo: [
    "0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e",
    "0xaaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897",
    "0x037f5f3c8e67b314062025fc886fcd6238ea25a4a9b45dce8d246815c9ebe770",
    "0xc196f81260cf1686172b47a79cf002120735d7cb0eb1474e8adce56618456fff",
    "0xf6e9983c37baf68846fedafe21e56718790e39fb1c582abc408b81bc7b208f9a",
    "0x5fce687da39305dfe682b117f0820b319348e8bb37eb16cf34acbf6a202de9d9",
    "0xe7c3d5edde7db964317cd9b51a3a059d7cd99f81bdbce14990047354334c9779",
    "0x1611e1dbf0405379b861e2e27daa90f480b2e6d3682414a80835a52e8cb8a215",
    "0x343442f12fa715489a8714e79a7b264ea88c0d5b8c66b684a7788a516032f6b9",
    "0x78bcd530c6b3a068bc17473cf5d2aff9c287102bed9af3ae3c41c33b9d6c6147",
    "0x47381ee0697153d64404fc578392c8fd5cba9073391908f46c888498415647bd",
    "0x19c0e4fa8ab75f5ac7865e0b8f74ff91eb9a100d336f423cd013a8befba40299"
  ],
  sora: [
    "0x7e4e32d0feafd4f9c9414b0be86373f9a1efa904809b683453a9af6856d38ad5"
  ],
  stafi: [
    "0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80"
  ],
  statemine: [
    "0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a"
  ],
  statemint: [
    "0x68d56f15f85d3136970ec16946040bc1752654e906147f7e43e9d539d7c3de2f"
  ],
  subsocial: [
    "0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8"
  ],
  ternoa: [
    "0x6859c81ca95ef624c9dfe4dc6e3381c33e5d6509e35e147092bfbc780f777c4e"
  ],
  unique: [
    "0x84322d9cddbf35088f1e54e9a85c967a41a56a4f43445768125e61af166c7d31"
  ],
  vtb: [
    "0x286bc8414c7000ce1d6ee6a834e29a54c1784814b76243eb77ed0b2c5573c60f",
    "0x7483b89572fb2bd687c7b9a93b242d0b237f9aba463aba07ec24503931038aaa"
  ],
  westend: [
    "0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"
  ],
  xxnetwork: [
    "0x50dd5d206917bf10502c68fb4d18a59fc8aa31586f4e8856b493e43544aa82aa"
  ],
  zeitgeist: [
    "0x1bf2a2ecb4a868de66ea8610f2ce7c8c43706561b6476031315f6640fe38e060"
  ]
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/defaults/icons.js
init_shim();
var knownIcon2 = {
  centrifuge: "polkadot",
  kusama: "polkadot",
  polkadot: "polkadot",
  sora: "polkadot",
  statemine: "polkadot",
  statemint: "polkadot",
  westmint: "polkadot"
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/defaults/ledger.js
init_shim();
var knownLedger2 = {
  acala: 787,
  ajuna: 354,
  "aleph-node": 643,
  astar: 810,
  bifrost: 788,
  "bifrost-kusama": 788,
  centrifuge: 747,
  composable: 354,
  darwinia: 354,
  "dock-mainnet": 594,
  edgeware: 523,
  enjin: 1155,
  equilibrium: 99999997,
  genshiro: 99999996,
  hydradx: 354,
  "interlay-parachain": 354,
  karura: 686,
  khala: 434,
  kusama: 434,
  matrixchain: 1155,
  nodle: 1003,
  origintrail: 354,
  parallel: 354,
  pendulum: 354,
  phala: 354,
  picasso: 434,
  polkadex: 799,
  polkadot: 354,
  polymesh: 595,
  quartz: 631,
  sora: 617,
  stafi: 907,
  statemine: 434,
  statemint: 354,
  ternoa: 995,
  unique: 661,
  vtb: 694,
  xxnetwork: 1955,
  zeitgeist: 354
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/defaults/testnets.js
init_shim();
var knownTestnet2 = {
  "": true,
  "cess-testnet": true,
  "dock-testnet": true,
  jupiter: true,
  "mathchain-testnet": true,
  p3dt: true,
  subspace_testnet: true,
  "zero-alphaville": true
};

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/interfaces.js
var UNSORTED2 = [0, 2, 42];
var TESTNETS2 = ["testnet"];
function toExpanded2(o3) {
  var _a, _b;
  const network = o3.network || "";
  const nameParts = network.replace(/_/g, "-").split("-");
  const n3 = o3;
  n3.slip44 = knownLedger2[network];
  n3.hasLedgerSupport = !!n3.slip44;
  n3.genesisHash = knownGenesis2[network] || [];
  n3.icon = knownIcon2[network] || "substrate";
  n3.isTestnet = !!knownTestnet2[network] || TESTNETS2.includes(nameParts[nameParts.length - 1]);
  n3.isIgnored = n3.isTestnet || !(o3.standardAccount && ((_a = o3.decimals) == null ? void 0 : _a.length) && ((_b = o3.symbols) == null ? void 0 : _b.length)) && o3.prefix !== 42;
  return n3;
}
function filterSelectable2({ genesisHash, prefix }) {
  return !!genesisHash.length || prefix === 42;
}
function filterAvailable2(n3) {
  return !n3.isIgnored && !!n3.network;
}
function sortNetworks2(a3, b3) {
  const isUnSortedA = UNSORTED2.includes(a3.prefix);
  const isUnSortedB = UNSORTED2.includes(b3.prefix);
  return isUnSortedA === isUnSortedB ? isUnSortedA ? 0 : a3.displayName.localeCompare(b3.displayName) : isUnSortedA ? -1 : 1;
}
var allNetworks2 = esm_default.map(toExpanded2);
var availableNetworks2 = allNetworks2.filter(filterAvailable2).sort(sortNetworks2);
var selectableNetworks2 = availableNetworks2.filter(filterSelectable2);

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/packageInfo.js
init_shim();
var packageInfo15 = { name: "@polkadot/networks", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "12.6.1" };

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/defaults/ss58.js
var PREFIX_DEFAULT = -1;
var defaultNetwork = {
  info: "default",
  text: "Default for the connected node",
  value: -1
};
var networks = availableNetworks2.map(({ displayName, network, prefix }) => ({
  info: network,
  text: displayName,
  value: prefix
}));
var PREFIXES = [defaultNetwork, ...networks];

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/defaults/ui.js
init_shim();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/defaults/type.js
init_shim();
var isPolkadot = typeof window !== "undefined" && window.location.host.includes("polkadot");

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/defaults/ui.js
var UIMODE_DEFAULT = !isPolkadot && typeof window !== "undefined" && window.location.host.includes("ui-light") ? "light" : "full";
var UIMODES = [
  {
    info: "full",
    text: "Fully featured",
    value: "full"
  },
  {
    info: "light",
    text: "Basic features only",
    value: "light"
  }
];
var UITHEME_DEFAULT = isPolkadot ? "polkadot" : "substrate";
var UITHEMES = [
  {
    info: "polkadot",
    text: "Polkadot",
    value: "polkadot"
  },
  {
    info: "substrate",
    text: "Substrate",
    value: "substrate"
  }
];
var ICON_DEFAULT = "default";
var ICON_DEFAULT_HOST = isPolkadot ? "polkadot" : "substrate";
var ICONS = [
  {
    info: "default",
    text: "Default for the connected node",
    value: "default"
  },
  {
    info: "polkadot",
    text: "Polkadot",
    value: "polkadot"
  },
  {
    info: "substrate",
    text: "Substrate",
    value: "substrate"
  },
  {
    info: "beachball",
    text: "Beachball",
    value: "beachball"
  }
];
var NOTIFICATION_DEFAULT = "popup";

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/defaults/index.js
var CAMERA_DEFAULT = "off";
var CAMERA = [
  {
    info: "on",
    text: "Allow camera access",
    value: "on"
  },
  {
    info: "off",
    text: "Do not allow camera access",
    value: "off"
  }
];
var LANGUAGE_DEFAULT = "default";
var LOCKING_DEFAULT = "session";
var LOCKING = [
  {
    info: "session",
    text: "Once per session",
    value: "session"
  },
  {
    info: "tx",
    text: "On each transaction",
    value: "tx"
  }
];
var METADATA_UP_DEFAULT = "off";
var METADATA_UP = [
  {
    info: "off",
    text: "Do not auto-update extension metadata",
    value: "off"
  },
  {
    info: "on",
    text: "Auto-update extension metadata",
    value: "on"
  }
];
var STORAGE_DEFAULT = "off";
var STORAGE = [
  {
    info: "on",
    text: "Allow local in-browser account storage",
    value: "on"
  },
  {
    info: "off",
    text: "Do not allow local in-browser account storage",
    value: "off"
  }
];

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/Settings.js
function withDefault(options, option, fallback) {
  const _option = option || fallback;
  return options.some(({ value }) => value === _option) ? _option : fallback;
}
var Settings = class {
  constructor() {
    const settings2 = import_store.default.get("settings") || {};
    this.__internal__emitter = new import_index.default();
    this.__internal__apiUrl = typeof settings2.apiUrl === "string" && settings2.apiUrl || hasProcess && import_process.default.env && import_process.default.env["WS_URL"] || ENDPOINT_DEFAULT.value;
    this.__internal__apiType = { param: this.__internal__apiUrl, type: "json-rpc" };
    this.__internal__camera = withDefault(CAMERA, settings2.camera, CAMERA_DEFAULT);
    this.__internal__ledgerConn = withDefault(LEDGER_CONN, settings2.ledgerConn, LEDGER_CONN_DEFAULT);
    this.__internal__i18nLang = settings2.i18nLang || LANGUAGE_DEFAULT;
    this.__internal__icon = settings2.icon || ICON_DEFAULT;
    this.__internal__locking = settings2.locking || LOCKING_DEFAULT;
    this.__internal__metadataUp = withDefault(METADATA_UP, settings2.storage, METADATA_UP_DEFAULT);
    this.__internal__notification = settings2.notification || NOTIFICATION_DEFAULT;
    this.__internal__prefix = isUndefined(settings2.prefix) ? PREFIX_DEFAULT : settings2.prefix;
    this.__internal__storage = withDefault(STORAGE, settings2.storage, STORAGE_DEFAULT);
    this.__internal__uiMode = settings2.uiMode || UIMODE_DEFAULT;
    this.__internal__uiTheme = settings2.uiTheme || UITHEME_DEFAULT;
  }
  get camera() {
    return this.__internal__camera;
  }
  get apiType() {
    return this.__internal__apiType;
  }
  get apiUrl() {
    return this.__internal__apiUrl;
  }
  get i18nLang() {
    return this.__internal__i18nLang;
  }
  get icon() {
    return this.__internal__icon;
  }
  get notification() {
    return this.__internal__notification;
  }
  get ledgerConn() {
    return this.__internal__ledgerConn;
  }
  get locking() {
    return this.__internal__locking;
  }
  get metadataUp() {
    return this.__internal__metadataUp;
  }
  get prefix() {
    return this.__internal__prefix;
  }
  get storage() {
    return this.__internal__storage;
  }
  get uiMode() {
    return this.__internal__uiMode;
  }
  get uiTheme() {
    return this.__internal__uiTheme;
  }
  get availableCamera() {
    return CAMERA;
  }
  get availableCryptos() {
    return CRYPTOS;
  }
  get availableCryptosEth() {
    return CRYPTOS_ETH;
  }
  get availableCryptosLedger() {
    return CRYPTOS_LEDGER;
  }
  get availableIcons() {
    return ICONS;
  }
  get availableLedgerConn() {
    return LEDGER_CONN;
  }
  get availableLocking() {
    return LOCKING;
  }
  get availableMetadataUp() {
    return METADATA_UP;
  }
  get availableNodes() {
    return ENDPOINTS;
  }
  get availablePrefixes() {
    return PREFIXES;
  }
  get availableStorage() {
    return STORAGE;
  }
  get availableUIModes() {
    return UIMODES;
  }
  get availableUIThemes() {
    return UITHEMES;
  }
  get() {
    return {
      apiType: this.__internal__apiType,
      apiUrl: this.__internal__apiUrl,
      camera: this.__internal__camera,
      i18nLang: this.__internal__i18nLang,
      icon: this.__internal__icon,
      ledgerConn: this.__internal__ledgerConn,
      locking: this.__internal__locking,
      metadataUp: this.__internal__metadataUp,
      notification: this.__internal__notification,
      prefix: this.__internal__prefix,
      storage: this.__internal__storage,
      uiMode: this.__internal__uiMode,
      uiTheme: this.__internal__uiTheme
    };
  }
  set(settings2) {
    this.__internal__apiType = settings2.apiType || this.__internal__apiType;
    this.__internal__apiUrl = settings2.apiUrl || this.__internal__apiUrl;
    this.__internal__camera = settings2.camera || this.__internal__camera;
    this.__internal__ledgerConn = settings2.ledgerConn || this.__internal__ledgerConn;
    this.__internal__i18nLang = settings2.i18nLang || this.__internal__i18nLang;
    this.__internal__icon = settings2.icon || this.__internal__icon;
    this.__internal__locking = settings2.locking || this.__internal__locking;
    this.__internal__metadataUp = settings2.metadataUp || this.__internal__metadataUp;
    this.__internal__notification = settings2.notification || this.__internal__notification;
    this.__internal__prefix = isUndefined(settings2.prefix) ? this.__internal__prefix : settings2.prefix;
    this.__internal__storage = settings2.storage || this.__internal__storage;
    this.__internal__uiMode = settings2.uiMode || this.__internal__uiMode;
    this.__internal__uiTheme = settings2.uiTheme || this.__internal__uiTheme;
    const newValues = this.get();
    import_store.default.set("settings", newValues);
    this.__internal__emitter.emit("change", newValues);
  }
  on(type, cb) {
    this.__internal__emitter.on(type, cb);
  }
};
var settings = new Settings();

// node_modules/@polkadot/react-identicon/node_modules/@polkadot/ui-settings/defaults/chains.js
init_shim();
var chains = selectableNetworks2.filter((n3) => n3.genesisHash.length).reduce((chains2, { genesisHash, network }) => objectSpread(chains2, { [network]: genesisHash }), {});

// node_modules/@polkadot/react-identicon/Identicon.js
var Fallback = Beachball;
var DEFAULT_SIZE = 64;
var Components = {
  beachball: Beachball,
  empty: Empty,
  ethereum: Ethereum,
  jdenticon: Jdenticon,
  polkadot: Polkadot,
  substrate: Jdenticon
};
var BaseIcon = class extends import_react7.default.PureComponent {
  constructor() {
    super(...arguments);
    this.state = {
      address: "",
      publicKey: "0x"
    };
    this.onCopy = () => {
      const { onCopy } = this.props;
      const { address } = this.state;
      if (address && onCopy) {
        onCopy(address);
      }
    };
  }
  static setDefaultPrefix(prefix) {
    BaseIcon.prefix = prefix;
  }
  static getDerivedStateFromProps({ prefix = BaseIcon.prefix, theme, value }, prevState) {
    if (theme === "ethereum") {
      const address = isU8a(value) ? ethereumEncode(value) : value || "";
      return { address, publicKey: "" };
    }
    try {
      const address = isU8a(value) || isHex(value) ? encodeAddress(value, prefix) : value || "";
      const publicKey = u8aToHex(decodeAddress(address, false, prefix));
      return address === prevState.address ? null : {
        address,
        publicKey
      };
    } catch {
      return {
        address: "",
        publicKey: "0x"
      };
    }
  }
  render() {
    const { address } = this.state;
    const wrapped = this.getWrapped(this.state, this.props);
    return !address ? wrapped : (0, import_jsx_runtime6.jsx)(import_react_copy_to_clipboard.default, { onCopy: this.onCopy, text: address, children: wrapped });
  }
  getWrapped({ address, publicKey }, { Custom }) {
    const { className = "", isAlternative, isHighlight, size = DEFAULT_SIZE, style = {}, theme = settings.icon } = this.props;
    const Component = !address ? Empty : Custom || Components[theme === "default" ? ICON_DEFAULT_HOST : theme] || Fallback;
    return (0, import_jsx_runtime6.jsx)(StyledDiv, { className: `ui--IdentityIcon  ${className}`, style, children: (0, import_jsx_runtime6.jsx)(Component, { address, className: isHighlight ? "highlight" : "", isAlternative, publicKey, size }) }, address);
  }
};
BaseIcon.prefix = void 0;
function Icon(props) {
  return (0, import_jsx_runtime6.jsx)(BaseIcon, { ...props });
}
var StyledDiv = styled.div`
  cursor: copy;
  display: inline-block;
  line-height: 0;

  > .container {
    position: relative;

    > div,
    > svg {
      position: relative;
    }

    &.highlight:before {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      box-shadow: 0 0 5px 2px #aaa;
      content: '';
    }
  }
`;
var Identicon6 = import_react7.default.memo(Icon);

// node_modules/@polkadot/react-identicon/index.js
var react_identicon_default = Identicon6;
export {
  Beachball,
  Empty,
  Ethereum,
  Identicon6 as Identicon,
  Jdenticon,
  Polkadot,
  react_identicon_default as default,
  packageInfo8 as packageInfo
};
/*! Bundled license information:

ethereum-blockies-base64/dist/main.js:
  (**
   * A handy class to calculate color values.
   *
   * @version 1.0
   * @author Robert Eisele <robert@xarg.org>
   * @copyright Copyright (c) 2010, Robert Eisele
   * @link http://www.xarg.org/2010/03/generate-client-side-png-files-using-javascript/
   * @license http://www.opensource.org/licenses/bsd-license.php BSD License
   *
   *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@polkadot_react-identicon.js.map
